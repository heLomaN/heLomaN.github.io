var tipuesearch = {"pages":[{"title":"About Me","text":"I'm a Software Engineer working on computer graphics, human-computer interaction, and some image processing. I started my career as a game-logic/graphics/system-architecture/low-level-optimization technology programmer and before joining Kwai I worked or learned professionally in the game industry for almost 5 years. I believe I am an proble solver. Handling practice problems and challenges always attracts me.","tags":"pages","url":"pages/about-me.html","loc":"pages/about-me.html"},{"title":"Resume","text":"Education University of Science and Technology of China MS, Electrical Engineering and Information Science 2012-2015 University of Science and Technology of China BS, School of Gifted Young 2008-2012 Experiences Graduate Student at USTC University of Science and Technology of China (USTC),HeFei,China September 2012 - July 2015 (3 years) Electrical Engineering College Student at USTC University of Science and Technology of China (USTC),HeFei,China September 2008 - July 2012 (4 years) Electrical Engineering Honors and Awards New Students Award 2007,Second Prize of National Olympiad in Psysics in Provinces Projects Extracurricular Experiences 2009-2011 Network Administration of the School of Gifted Young Jan,2012 China Construction Bank Sep,2012-Jan,2012 Minister of Graduate Union of Infomatic Academy Feb,2013-Dec,2013 Vice President of Video Union of USTC Skills Technical Skills Proficiency in C, C++, Matlab,Python Familiar with Java, Git,Pelican,HTML,CSS,JavaScript Solid basis of Wireless Communication Language Skills Able to communicate in English; Proficient in reading and writing English technical articles TOEFL :Not tested Passed CET-4/6 Fluent in Mandarin","tags":"pages","url":"pages/resume.html","loc":"pages/resume.html"},{"title":"git0710","text":"使用Git完成版本控制 我经常同时保存一个程序或一个文档的不同版本，采取的方式就是文件名上面加上日期。 版本控制在团队开发大型项目中是必须的。版本控制系统，可以给程序员自由的修改，很方便的开发多个分支实验新特性，共享代码也很方便。 Git是Linux Torvalds为Linux Kernel编写的版本控制系统，速度快且高效。 有很多版本控制系统，但是相比他们git有以下优点： - 本地存储，不需要联网，速度快 - 易于学习使用 - 提供staging(缓冲区)，使 - 有github等适合分享的网站 git的常用命令 git config --global user.name \"\" 或者改为 user.email \"\" ,之后用 git config --globa --list 查看 git init 在当前目录下的.git文件夹内建立一个空仓库 git status 查看当前分支状态，默认的branch是master git add . 添加所有文件到仓库 git add file1 dir/ 添加文件或目录 git commit 打开提交备注的编辑页面，hash( # )字符开头的行会被忽略 git commit -a -m \"message\" 添加所有更改，跳过 git add 忽略某些文件，在 .gitignore 文件中添加相应的目录或文件名即可。这个文件也应该添加到仓库。hash开头可以写注释。这个功能很有用，JD就曾经有程序员把后台系统的管理员密码提交到了github上。 git跟踪的是文件的内容，而不是文件。修改文件后，需要把修改后的文件再次加入仓库，否则下次commit时不会记录此次更新。 git分支 git branch newbranch 从当前状态创建新的branch git checkout newbranch 切换到新的branch git merge newbranch 把newbranch的改动提交到当前branch git stash 这个命令会缓存当前的更改 git stash apply 会应用缓存的更改 apply之后再 git checkout file 可以取消部分文件来自缓存的更改 git amend git commit --amend 可以更改最后一个的提交 查看分支历史 git log 可以看到当前branch的commit历史 git shortlog 可以看到当前branch的commit历史简略索引 git log --all 查看所有分支的commit历史 gitk 图形化显示当前分支历史 gitk --all 图形化显示所有分支历史 git log --all --graph --oneline 使用文本图形化显示所有分支历史 git tag git tag -a v0.5 -m 'this is our half-way release' 创建一个tag git describe 查看当前版本 与远程服务器交互（github） 常用流程 git init git add * git commit -m \"message\" git remote add origin git@*.git/httsp:...*.git //origin为标签，可任意更改 git push origin master //b把master推送到origin git add -i 可以交互性的更新文件/撤销，查看更改 http://www.open-open.com/lib/view/open1328069733264.html","tags":"misc","url":"pages/2021/01/git0710.html","loc":"pages/2021/01/git0710.html"},{"title":"20171127移动端阴影渲染","text":"如何在移动端渲染阴影 为啥 手机的性能相比PC非常差劲，如何渲染出视觉效果好的阴影是一个大难题 现有的方案 如王者荣耀在低配机型，直接在英雄底部贴一张固定的阴影图 消耗最少，相当于decal 而王者荣耀在高配机型上，会使用投影阴影 需要用stencil处理多重阴影 难以支持投影到平面 shadow map很少被采用，因为手机端浮点纹理支持不够，性能也比较耗 软阴影的实现 实时软阴影需要pcf随机采样","tags":"misc","url":"pages/2017/11/20171127yi-dong-duan-yin-ying-xuan-ran.html","loc":"pages/2017/11/20171127yi-dong-duan-yin-ying-xuan-ran.html"},{"title":"20170609设计模式","text":"设计模式的思考 设计模式六大原则 单一职责原则 即一个类只负责一项职责，必要时分解 里氏替换原则 子类可以扩展父类的功能，但不能改变父类原有的功能，如有必要，添加一个父类子类共同的基类 依赖倒置原则 高层不依赖低层，也即是高层（父类）定义好接口，低层（子类）实现。 接口隔离原则 为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用 迪米特法则 一个对象应该对其他对象保持最少的了解。低耦合，高内聚。 开闭原则 软件实体如类、模块和函数应该对扩展开放，对修改关闭。 UML类图中常见几种关系 泛化（Generalization） 即继承 依赖(Dependency) A使用B 关联（Association) B是A的成员变量 聚合（Aggregation） 一种强关联，A可以包含一个BB 组合(Composition) B是A的成员变量，是A的一部分 23种设计模式 单例模式 工厂模式：简单、方法、抽象 原型模式 模版方法模式 常用，子类实现不同的算法函数 建造者模式 中介者模式 将对象间一对多的关联转变为一对一的关联，可以将网状结构变为星状结构。终结者会很复杂 比如多个对象之间均有交互，那么为了简化引用关系，实现一个中介类，中介对象和交互对象之间包含对方的引用。中介对象可以实现为单例以避免交互对象对中介对象的引用，仅中介对象保持所有交互对象的引用 观察者模式 适应于UI事件处理，可以动态更改关联，可同时通知一批多个观察者 有pull和push两种实现方法 访问者模式 装饰模式 比起静态继承，可以直接修饰对象而不是类 外观模式 适合封装内部实现 适配器模式 用于转换接口，适应新提出的需求 代理模式 一般使用继承、组合实现，接口不变，但中间添加了一些控制条件 命令模式 把请求调用封装为命令对象，方便实现命令日志、命令队列 组合模式 让客户端不再区分操作的是组合对象还是叶子对象，而是以一种统一的方式来操作：设计一个抽象的组件类，让它可以代表组合对象和叶子对象 方便递归，可以实现xm/json解析、行为树 桥接模式 用于解决多种维度的变化，组合多种子类，可替换多继承 状态模式 用于实现状态机 策略模式 享元模式 可理解为缓冲池 解释器模式 解释器是一个简单的语法分析工具，做编译器可用到 迭代器模式","tags":"misc","url":"pages/2017/06/20170609she-ji-mo-shi.html","loc":"pages/2017/06/20170609she-ji-mo-shi.html"},{"title":"20170209光照渲染路径","text":"unity shader入门精要 光照渲染路径 主要方法有如下三种 顶点照明渲染路径 Vertex Lit Rendering Path 前向渲染路径 Forward Rendering Path 延迟光照渲染路径 Deferred Lighting Rendering Path Vertex Lit Rendering Path 是Forward Rendering Path的一个子集 所有的光照都是在顶点层级上计算的，此渲染路径不支持大部分的逐像素渲染效果：如，阴影、法线贴图、灯光遮罩、高精度的高光 Forward Rendering Path 影响物体的最亮的几个光源使用逐像素光照模式。接下来，最多有4个点光源会以逐顶点渲染的方式被计算 N个物体、M个光源就需要N*M次渲染，光源较多时性能会受影响 Deferred Lighting Rendering Path 延迟渲染复杂度仅与屏幕分辨率有关 延迟渲染需要两个Pass，一个用于填充G Buffer，一个用于计算光照 屏幕后处理的实现 OnRenderImage函数可以很方便的对屏幕渲染图像进行处理,只需将实现此函数的脚本添加到camera上 OnRenderImage可以多个串流叠加 用于实现边缘检测、高斯模糊、Bloom效果、运动模糊都很方便","tags":"misc","url":"pages/2017/02/20170209guang-zhao-xuan-ran-lu-jing.html","loc":"pages/2017/02/20170209guang-zhao-xuan-ran-lu-jing.html"},{"title":"20160906android_opengl","text":"安卓平台OpenGL ES的调用 开发游戏如果直接使用OpenGL是比较痛苦的，最好的办法是使用封装好的引擎，但很有必要了解在安卓java代码直接调用OpenGL的渲染方法 固定渲染管线只可通过配置实现不同的效果，而可编程渲染管线通过一般编程的方式实现，可以实现更加灵活的效果 OpenGL ES OpenGL从3.0开始，而OpenGL ES从2.0开始，支持可编程管线 下图中橙色两块儿即为可编程部分，而顶点和片段着色器要相互配合好才能发挥最大性能 一般通用编程模式为写好两个shader的代码，每次运行程序时即时编译运行 代码框架 在manifest中声明OpenGL ES <uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" /> 在入口Acitvity中需要使用GLSurfaceView作为主视图 在GLSurfaceView中可以扩展出一些其他函数，需要创建一个GLSurfaceView.Renderer的派生类对象负责显示 GLSurfaceView.Renderer需要关注三个函数： onSurfaceCreated：仅调用一次 onDrawFrame：每次显示都调用 onSurfaceChanged：view大小变化时调用 3D坐标变换 安卓同样有对应坐标变换的库 Matrix MVP变换的实际乘法顺序是PVM V可以通过 setLookAtM 得到 P则是 orthoM frustumM/perspectiveM 生成，其中perspectiveM是对frustumM的封装，只是在API Level 14后才存在 M如果不是I的话，表明模型有位置偏移 使用shader画图 需要创建一个顶点shader、一个片段shader，以及一个program 通过 glCreateShader 可以创建一个shader，之后调用 glShaderSource 、 glCompileShader 分别设置shader代码和编译 progam则通过 glCreateProgram 创建，调用 glAttachShader 添加这两个shader，调用 glLinkProgram 进行\"链接\"生成可执行指令，使用时要 glUseProgram 示例代码 OpenGLES20Activity.java package com . example . androiddeveloper ; // import android.support.v7.app.ActionBarActivity ; import android.os.Bundle ; import android.view.Menu ; import android.view.MenuItem ; import android.view.MotionEvent ; import javax.microedition.khronos.opengles.GL10 ; import android.app.Activity ; import android.content.Context ; import android.opengl. * ; public class OpenGLES20Activity extends Activity { private GLSurfaceView mGLView ; @Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); // Create a GLSurfaceView instance and set it // as the ContentView for this Activity . mGLView = new MyGLSurfaceView ( this ); setContentView ( mGLView ); } } class MyGLSurfaceView extends GLSurfaceView { private final MyGLRenderer mRenderer ; public MyGLSurfaceView ( Context context ){ super ( context ); // Create an OpenGL ES 2.0 context setEGLContextClientVersion ( 2 ); // setRenderMode ( GLSurfaceView . RENDERMODE_WHEN_DIRTY ); mRenderer = new MyGLRenderer (); // Set the Renderer for drawing on the GLSurfaceView setRenderer ( mRenderer ); } private final float TOUCH_SCALE_FACTOR = 180.0 f / 320 ; private float mPreviousX ; private float mPreviousY ; @Override public boolean onTouchEvent ( MotionEvent e ) { // MotionEvent reports input details from the touch screen // and other input controls . In this case , you are only // interested in events where the touch position changed . float x = e . getX (); float y = e . getY (); switch ( e . getAction ()) { case MotionEvent . ACTION_MOVE : float dx = x - mPreviousX ; float dy = y - mPreviousY ; // reverse direction of rotation above the mid - line if ( y > getHeight () / 2 ) { dx = dx * - 1 ; } // reverse direction of rotation to left of the mid - line if ( x < getWidth () / 2 ) { dy = dy * - 1 ; } mRenderer . setAngle ( mRenderer . getAngle () + (( dx + dy ) * TOUCH_SCALE_FACTOR )); requestRender (); } mPreviousX = x ; mPreviousY = y ; return true ; } } MyGLRenderer.java package com . example . androiddeveloper ; import javax.microedition.khronos.opengles.GL10 ; import android.opengl.GLES20 ; import android.opengl.GLSurfaceView ; import android.opengl.Matrix ; import android.os.SystemClock ; public class MyGLRenderer implements GLSurfaceView . Renderer { private Triangle mTriangle ; private final float [] mMVPMatrix = new float [ 16 ]; private final float [] mProjectionMatrix = new float [ 16 ]; private final float [] mViewMatrix = new float [ 16 ]; public void onSurfaceCreated ( GL10 unused , javax . microedition . khronos . egl . EGLConfig config ) { // Set the background frame color GLES20 . glClearColor ( 0.0 f , 0.0 f , 0.0 f , 1.0 f ); mTriangle = new Triangle (); } private float [] mRotationMatrix = new float [ 16 ]; public void onDrawFrame ( GL10 unused ) { float [] scratch = new float [ 16 ]; long time = SystemClock . uptimeMillis () % 4000L ; float angle = 0.090 f * (( int ) time ); Matrix . setRotateM ( mRotationMatrix , 0 , mAngle , 0 , 0 , - 1.0 f ); GLES20 . glClear ( GLES20 . GL_COLOR_BUFFER_BIT ); Matrix . setLookAtM ( mViewMatrix , 0 , 0 , 0 , - 3 , 0 f , 0 f , 0 f , 0 f , 1.0 f , 0.0 f ); Matrix . multiplyMM ( mMVPMatrix , 0 , mProjectionMatrix , 0 , mViewMatrix , 0 ); Matrix . multiplyMM ( scratch , 0 , mMVPMatrix , 0 , mRotationMatrix , 0 ); mTriangle . draw ( scratch ); } public void onSurfaceChanged ( GL10 unused , int width , int height ) { GLES20 . glViewport ( 0 , 0 , width , height ); float ratio = ( float ) width / height ; Matrix . frustumM ( mProjectionMatrix , 0 , - ratio , ratio , - 1 , 1 , 3 , 7 ); } public static int loadShader ( int type , String shaderCode ){ // create a vertex shader type ( GLES20 . GL_VERTEX_SHADER ) // or a fragment shader type ( GLES20 . GL_FRAGMENT_SHADER ) int shader = GLES20 . glCreateShader ( type ); // add the source code to the shader and compile it GLES20 . glShaderSource ( shader , shaderCode ); GLES20 . glCompileShader ( shader ); return shader ; } public volatile float mAngle ; public float getAngle () { return mAngle ; } public void setAngle ( float angle ) { mAngle = angle ; } } Triangle.java package com . example . androiddeveloper ; import java.nio.ByteBuffer ; import java.nio.ByteOrder ; import java.nio.FloatBuffer ; import android.opengl.GLES20 ; public class Triangle { private FloatBuffer vertexBuffer ; // number of coordinates per vertex in this array static final int COORDS_PER_VERTEX = 3 ; static float triangleCoords [] = { // in counterclockwise order : 0.0 f , 0.622008459 f , 0.0 f , // top - 0.5 f , - 0.311004243 f , 0.0 f , // bottom left 0.5 f , - 0.311004243 f , 0.0 f // bottom right }; // Set color with red , green , blue and alpha ( opacity ) values float color [] = { 0.63671875 f , 0.76953125 f , 0.22265625 f , 1.0 f }; private final int mProgram ; public Triangle () { // initialize vertex byte buffer for shape coordinates ByteBuffer bb = ByteBuffer . allocateDirect ( // ( number of coordinate values * 4 bytes per float ) triangleCoords . length * 4 ); // use the device hardware 's native byte order bb . order ( ByteOrder . nativeOrder ()); // create a floating point buffer from the ByteBuffer vertexBuffer = bb . asFloatBuffer (); // add the coordinates to the FloatBuffer vertexBuffer . put ( triangleCoords ); // set the buffer to read the first coordinate vertexBuffer . position ( 0 ); int vertexShader = MyGLRenderer . loadShader ( GLES20 . GL_VERTEX_SHADER , vertexShaderCode ); int fragmentShader = MyGLRenderer . loadShader ( GLES20 . GL_FRAGMENT_SHADER , fragmentShaderCode ); // create empty OpenGL ES Program mProgram = GLES20 . glCreateProgram (); // add the vertex shader to program GLES20 . glAttachShader ( mProgram , vertexShader ); // add the fragment shader to program GLES20 . glAttachShader ( mProgram , fragmentShader ); // creates OpenGL ES program executables GLES20 . glLinkProgram ( mProgram ); } private final String vertexShaderCode = \"uniform mat4 uMVPMatrix;\" + \"attribute vec4 vPosition;\" + \"void main() {\" + \" gl_Position = uMVPMatrix * vPosition;\" + \"}\" ; private final String fragmentShaderCode = \"precision mediump float;\" + \"uniform vec4 vColor;\" + \"void main() {\" + \" gl_FragColor = vColor;\" + \"}\" ; private int mPositionHandle ; private int mColorHandle ; private final int vertexCount = triangleCoords . length / COORDS_PER_VERTEX ; private final int vertexStride = COORDS_PER_VERTEX * 4 ; // 4 bytes per vertex private int mMVPMatrixHandle ; public void draw ( float [] mvpMatrix ) { // Add program to OpenGL ES environment GLES20 . glUseProgram ( mProgram ); // get handle to vertex shader 's vPosition member mPositionHandle = GLES20 . glGetAttribLocation ( mProgram , \"vPosition\" ); // Enable a handle to the triangle vertices GLES20 . glEnableVertexAttribArray ( mPositionHandle ); // Prepare the triangle coordinate data GLES20 . glVertexAttribPointer ( mPositionHandle , COORDS_PER_VERTEX , GLES20 . GL_FLOAT , false , vertexStride , vertexBuffer ); // get handle to fragment shader 's vColor member mColorHandle = GLES20 . glGetUniformLocation ( mProgram , \"vColor\" ); // Set color for drawing the triangle GLES20 . glUniform4fv ( mColorHandle , 1 , color , 0 ); mMVPMatrixHandle = GLES20 . glGetUniformLocation ( mProgram , \"uMVPMatrix\" ); GLES20 . glUniformMatrix4fv ( mMVPMatrixHandle , 1 , false , mvpMatrix , 0 ); // Draw the triangle GLES20 . glDrawArrays ( GLES20 . GL_TRIANGLES , 0 , vertexCount ); // Disable vertex array GLES20 . glDisableVertexAttribArray ( mPositionHandle ); } } 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/09/20160906android_opengl.html","loc":"pages/2016/09/20160906android_opengl.html"},{"title":"20160823安卓逆向工程","text":"安卓逆向简介 常用逆向方法 Apk文件格式 Apk文件其实是一个zip文件，解压之后可以看到其中的目录结构 AndroidManifest.xml 已经过编译，包括activity、权限等配置 classes.dex java程序生成的.class文件经过打包生成 resources.arsc 资源文件索引 res 此文件夹包括布局文件、图片、strings等文件，可以通过R.java引用 lib 用到的第三方库，包括.so文件。.so文件不易破解 assets 不经编译的资源文件，可以通过AssetManager类访问 META-INF 应用签名文件，用于验证apk中的文件没有被修改过 使用dex2jar和jdgui查看java代码 首先将apk或者apk中的dex文件拖到 d2j-dex2jar.bat 上，会得到一个jar文件 用jdgui打开此jar文件，即可看到java源码 注意，部分源码无法正确得到 使用apktool反编译和打包 反编译命令 apktool d *.apk 重新打包命令 apktool p folder 使用auto-sign重签名 将apk改名为update.zip,复制到签名工具的目录下,运行Sign.bat 重新打包之前可以修改smali文件夹下的源码达到破解的目的 使用IDA Pro查看.so文件 窗口左侧选中函数后，按F5可以在Pseudocode窗口查看反编译得到的C代码 同样可以动态调试.so代码 常用apk保护方法 加固/加壳 加壳指的是将dex文件加密后和加密apk写入一个新的dex文件，运行时首先通过加密apk解密得到源dex文件，再通过DexClassLoader动态加载源dex 运行时必然将源dex加载到内存中运行，因此在加载源dex后dump内存中对应区块即可得到源dex文件，即脱壳成功 混淆 混淆java或者C#(Unity)代码，即使反编译也无法看懂源代码，增加分析代码逻辑的难度 对于java代码，可以配置proguard脚本生成apk时混淆classes.dex 对于Unity项目，反编译后得到的Assembly-CSharp.dll即可使用.NET Reflector直接查看源代码，建议使用Obfuscar混淆 运行时验证 目的是防止二次打包 可以对dex文件进行验证 阻止内存修改 要对抗八门神器这种内存修改器，可以将关键变量实时加密，仅在使用时解密 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/08/20160823an-zhuo-ni-xiang-gong-cheng.html","loc":"pages/2016/08/20160823an-zhuo-ni-xiang-gong-cheng.html"},{"title":"20160706python的几个基本问题","text":"python的几个基本问题 标识符皆引用 所有标识符皆引用，只是指向了一个分配好的对象 list中存储的也是对元素的引用，dict等容器也是如此 is和== is和is not用来检测两个标识符是否指向同一个对象 ==和!=用来检测两个标识符指向的对象的值是否相等 通常使用后者，仅当需要测试是否同一个对象时才使用前者 除法和余数 m/n = q ---- r 必有m = n*q + r r与n同号，且abs(r) < abs(n) 函数参数传引用 python函数传参数相当于赋值操作，把实参赋值给形参 返回值也相当于赋值操作 异常处理 使用大量检测来保证函数的输入正确是没有必要的，可能花费的代价更高","tags":"misc","url":"pages/2016/07/20160706pythonde-ji-ge-ji-ben-wen-ti.html","loc":"pages/2016/07/20160706pythonde-ji-ge-ji-ben-wen-ti.html"},{"title":"20160616vrui","text":"VR游戏的UI设计 除了按钮还可以探索其他交互方式 Fuse按钮 使用一个焦点来指示视线位置，长时间注视来确认点击 按钮摆放 按钮要足够大，间隔也要足够大 暴风VR在播放视频时把按钮放到最底下，很不错 倒计时按钮 注视过程中提供一些反馈，如桶被填满、圆环转一圈等效果 最好提供直接点击的确认方式 按钮辅助 GearVR触摸板+按钮辅助 不能掉帧 头控要考虑可移动范围 尽量减少头部移动 血条显示位置","tags":"misc","url":"pages/2016/06/20160616vrui.html","loc":"pages/2016/06/20160616vrui.html"},{"title":"20160612安卓按键键码修改","text":"安卓系统按键映射修改 谨记录下靠着自己摸索，安卓平板使用时一个bug的解决方案，及修改按钮功能的方法。这个bug目前搜不到解决方案，能独立解决还是很有成就感的 解决反复打开谷歌语音搜索的bug 手里一部驰为hi8，是国产双系统平板，在安卓系统下如果插上耳机会自动暂停和播放音乐，并反复打开谷歌搜索 这个bug目前网上没有找到答案。自己猜测，应该是耳机接口不匹配，相当于一直按着线控耳机上的播放/暂停按钮出现的情况 安卓系统基于linux，应该有办法修改按键键码的，谷歌知道，/system/usr/keylayout/qwerty.kl中保存了按键配置信息。但打开后看到注释写明此文件已不再使用，新系统采用的是Generic.kl文件中的配置 打开Generic.kl可以看到其中数据全都是如下格式 key 163 MEDIA_NEXT key 164 MEDIA_PLAY_PAUSE ... key 172 HOME 很明显，数字就是键码，而后面的大写字母则是对应的功能。遍历整个文件，只有上述提到的164关联了play和pause两个功能，大胆猜测这就是线控耳机的那个按钮。遂注释掉这一行重启平板，果然反复启动谷歌语音搜索的bug不见了，音乐播放器也不会反复自动打开了，当然，如果有需要使用线控耳机也不能用了~ 屏蔽Win按钮 经常使用这个平板玩儿虚荣，最为烦恼的是玩儿着玩儿着不小心碰到类Win按钮，直接回到了桌面，再次切换回游戏的话，都已经输了一波了。因此解决上述问题后有了屏蔽Win按钮的想法 这个按钮对应的键码想必就是HOME了，这个kl文件中总共有两行key都是HOME，两次试验确定 key 102 HOME 才对应Win键，同样注释掉，搞定~ 嗯，这个kl文件同样采用的是 # 作为行注释标记 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/06/20160612an-zhuo-an-jian-jian-ma-xiu-gai.html","loc":"pages/2016/06/20160612an-zhuo-an-jian-jian-ma-xiu-gai.html"},{"title":"20160606python定时杀进程","text":"python定时杀进程 之前写了个python脚本用selenium+phantomjs爬新帖子，在循环拉取页面的过程中，phantomjs总是block住，使用WebDriverWait设置最长等待时间无效。用firefox替换phantomjs无改善 因为这个脚本不会长期使用，因此采取临时办法，新开一个子线程固定周期杀死phantomjs进程，这样selenium就会在block最多不超过此周期后返回。当然在爬虫脚本中做一些微调防止部分url被跳过 定时执行任务采用sched模块，很多人将其与crontab相提并论 杀死特定进程的命令 kill -9 pid 命令可以无条件终止对应pid进程 获取名为phantomjs的进程pid ps命令列出进程信息 grep过滤得指定名字的进程信息 awk '{print $2}' 提取第二列pid信息 最终命令为：kill -9 `ps -aux|grep phantomjs|awk '{print $2}'` python可以用os.system()执行shell命令 使用sched模块周期执行任务 sched模块使用heapq保存event队列，其event为namedtuple类型 sched需要提供两个函数，一个用来获取时间变化，一个用于等待一段时间，可自定义 基本API sched.scheduler(time_func, sleep_func) 函数返回一个scheduler对象，time_func是一个返回数字的计时函数，而sleep_func可接受此数字参数，并延时相应时间 scheduler.enter(delay, priority, action, argument) 在 delay 时间段后，用参数 argument 调用 action ， argument 必须是一个tuple。若要在固定时刻运行，则应调用 scheduler.enterabs scheduler.cancel(event) 取消定时任务。event为enter函数返回值 scheduler.run() 开始执行 任务时间重叠 在执行任务时有可能要block一段时间，任务返回后可能已经超过下一个任务的定时时刻，这种情况下会立刻执行下一个任务，而不会跳过 周期执行 类似于递归调用，写一个wrapper function，在任务里面再次定时下一次任务即可 def wrapper(func, delay): scheduler.enter(delay, 0, wrapper, (func, delay)) func() 最终代码 import os , time , sched schedule = sched . scheduler ( time . time , time . sleep ) cmd = '''kill -9 `ps -aux|grep phantomjs|awk '{print $2}'` ''' def recycle_eval ( c , inc ): schedule . enter ( inc , 0 , recycle_eval , ( c , inc )) os . system ( c ) print time . ctime (), 'phantomjs killed' if __name__ == '__main__' : inc = 180 schedule . enter ( inc , 0 , recycle_eval , ( cmd , inc )) schedule . run () 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/06/20160606pythonding-shi-sha-jin-cheng.html","loc":"pages/2016/06/20160606pythonding-shi-sha-jin-cheng.html"},{"title":"20160506unity_camera","text":"Unity的camera组件 文章介绍的是个大概，其中rendering paths和culling、clear flag还有更详细的用法 正交和透视 unity的camera支持两种投影方式：正交和透视 人眼看到的物体，近处的比较大、远处的比较小，unity的摄像机支持这种透视效果，称为透视相机 如果不需要物体大小随到摄像机的距离改变，可以采用正交投影 可视区域 一般摄像机仅关注一个范围内的物体，垂直于摄像机z轴有两个平面，分别称为远、近裁剪平面，只有两个平面之间的物体才会投影到摄像机 对于正交投影，可视区域为一个长方体 对于透视投影，可视区域为一个锥体的一部分，锥体顶端是摄像机，锥体底面为远裁剪面，并被近裁剪面切割掉顶部 背景图和天空盒 在户外场景，投影到2D平面后部分区域是没有任何投影的，这时可以用背景色填充，但更逼真的方法是使用天空盒 摄像机转动时会看到天空盒的不同位置，但位置始终在天空盒的正中心 天空盒是由6张图片拼接成的立方体盒子，显示在所有物体之后 多摄像头切换 如果多个摄像头可用，则深度最大的摄像头会显示在最上方，覆盖其他摄像头。可以设置disable完成多个摄像头之间的切换 使用第二个摄像机显示小地图 深度调高，以显示在上方 设置viewport rect，调整占用2D屏幕的大小 摄像头射线投影 2D屏幕上的任意点都对应一条射线，可以使用ScreenPointToRay和ViewportPointToRay来获得此射线 此射线起点位于近裁剪面 camera组件参数 Clear Flags:使用什么清除像素缓存？比如天空盒或当前camera的背景色 Depth only选项配合Culling Mask可以完成单独显示一个物体不被遮挡的效果，如fps游戏中的枪 Background:背景色 Culling Mask:仅渲染选中的layer Projection:正交或透视 Size:当选中正交时，设置可视区域大小 FOV:当选中透视时，y轴方向视角 Clipping Planes:裁剪面位置 Viewport Rect:显示在屏幕上的大小、位置 Depth:深度，值大的渲染在最前面 Rendering Path:渲染方法，包括： 延迟光照Deffered Lighting:将lighting在屏幕空间进行 Target Texture:用于截图，如果使用则会停止渲染到屏幕 HDR:开启HDR 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/05/20160506unity_camera.html","loc":"pages/2016/05/20160506unity_camera.html"},{"title":"20160526python开发环境管理pip和virtualenv","text":"python开发环境管理：pip和virtualenv 不同的python软件需要不同的开发环境，互相之间甚至可能有冲突，怎么处理？使用pip、virtualenv和virtualenvwrapper可以迅速的搭建、转移开发环境，并隔离冲突。 软件包管理 pip是easy_install的替代品，distribute是setuptools的替代品 pip使用 使用参考文档为： pip pip install test 安装test包 pip list 列出已经安装的包 pip install --upgrade test 升级test包 pip uninstall test 卸载 pip install test==4.4 指定版本 pip install test>=4.4 指定最小版本号 pip freeze > requirements.txt 到处当前python环境的依赖库要求 pip install -r requirements.txt 根据依赖文件安装库 virtualenv virtualenv是用来创建独立python运行环境的工具 可以创建单独的安装目录，解决了依赖项、版本和权限的问题。比如pip不需要sudo了 创建虚拟环境 virtualenv test 命令将在当前目前下建立一个名为test的文件夹 此文件夹下python环境会自动安装pip，方便安装其他程序 默认将能使用系统中已经安装的包，可以使用 --no-site-packages 禁止 启动虚拟环境 source test/bin/activate 启动之后，可以看到命令行头部出现 (test) 字样，表明启动成功 退出 deactivate 用于退出虚拟环境 rm -r test 用于删除虚拟环境 virtualenvwrapper virtualenvwrapper是virtualenv的一个扩展，使虚拟环境的管理更加容易 参考文档 virtualenvwrapper 安装 使用 sudo pip install 之后使用以下命令设置开发环境，可以将最后一行加入 .bash_profile ，以后就无需重复初始化了 $ mkdir -p $WORKON_HOME $ export WORKON_HOME = ~/Envs $ source /usr/local/bin/virtualenvwrapper.sh 方便起见，直接将以下代码加入 .bashrc ，因为有些环境下 .bash_profile 不会被执行 # 设置 virtualenv 工作的目录 . 我们放在用户跟目录下 export WORKON_HOME = $ HOME / . virtualenvs # ensure all new environments are isolated from the site - packages directory export VIRTUALENVWRAPPER_VIRTUALENV_ARGS = '--no-site-packages' # use the same directory for virtualenvs as virtualenvwrapper export PIP_VIRTUALENV_BASE = $ WORKON_HOME # makes pip detect an active virtualenv and install to it export PIP_RESPECT_VIRTUALENV = true if [[ - r / usr / local / bin / virtualenvwrapper . sh ]]; then source / usr / local / bin / virtualenvwrapper . sh else echo \"WARNING: Can't find virtualenvwrapper.sh\" fi 常用命令 mkvirtualenv test 创建名为test的虚拟环境 workon 或者 lsvirtualenv 列出所有虚拟环境 workon test 启动或者切换虚拟环境 rmvirtualenv test 删除虚拟环境 deactivate 退出 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/05/20160526pythonkai-fa-huan-jing-guan-li-piphe-virtualenv.html","loc":"pages/2016/05/20160526pythonkai-fa-huan-jing-guan-li-piphe-virtualenv.html"},{"title":"20160523python_json_csv","text":"使用python开发json、csv数据格式转换工具 json和xml是业界常用的数据格式，而游戏行业经常使用csv配表，包括本地化文本和数值。本文介绍csv和json序列化、逆序列化相关的python库，以及开发工具常用的命令行解析库--getopt csv模块 csv文件格式并不统一，存在多种分隔符，而csv模块可以很方便的读写csv文件 csv.reader 返回一个reader迭代器，迭代器每次给出一个字符串列表，对应于csv文件中的一行 csv.writer 相应的，返回一个writer，调用 writerrow([stra,strb,...strc]) 可以将数据写入文件 csv.DictReader 创建一个DictReader类，对比reader迭代器，每次迭代给出一个字典对应一行，参数Reader.fieldnames给出了字典的key csv.DictWriter 类似writer，但输出的是字典 json模块 dump(obj, fp)将对象序列化后写入文件fp，indent选项可格式化json文件 dumps(obj)返回obj序列化之后的字符串 load(fp)从文件对象fp中反序列化，支持str或unicode loads(s)从字符串中反序列化 getopt解析命令行 getopt模块在c语言中也有，python实现了同样功能的模块 与sys模块配合，获取命令行参数 sys.argv为命令行列表 sys.argv[1:]可传递给getopt使用，去除了第一个参数（脚本名） getopt.getopt(sys,argv[1:], options[, long_options]) options为短选项，例如 hi: ，表示可以 -h 或者 -i xxx 的方式使用， : 表示该选项必须附加参数 long_options为长选项，例如 ['help', 'input='] ，可以 --help 或者 --input xxx 的格式使用， = 表示该选项必须附加参数 第一个返回值为 (option, value) 的pair列表，第二个返回值为解析后剩余的参数 例如命令行参数为 -h -i xxx yyy ，则返回值为 [('-h', ''), ('-i', xxx)], ['yyy'] 获得pair列表后，根据其中的数据进行不同的操作 csv转换为json文件工具举例 下面为csv文件转换为json的样例代码，以csv第一列作为json dict的key import sys , getopt import csv import json from ast import literal_eval def main ( argv ): pretty = False try : opts , args = getopt . getopt ( argv , \"hp\" ) except getopt . GetoptError : print 'test.py [-p]' sys . exit ( 2 ) for opt , arg in opts : if opt == '-h' : print 'test.py [-p]' sys . exit () elif opt == '-p' : pretty = True data = read_csv ( \"test.csv\" ) #print(json.dumps(data, sort_keys=False, indent=4, separators=(',', ': '),encoding=\"utf-8\",ensure_ascii=False)) write_json ( data , \"test.json\" , pretty ) def read_csv ( file ): csv_rows = {} def format ( source ): try : source = literal_eval ( source ) except : pass finally : return source with open ( file ) as csvfile : reader = csv . DictReader ( csvfile ) title = reader . fieldnames for row in reader : csv_rows [ format ( row [ title [ 0 ]])] = { title [ i ]: format ( row [ title [ i ]]) for i in range ( len ( title )) if not title [ i ] . startswith ( '_' )} return csv_rows def write_json ( data , json_file , format = True ): with open ( json_file , \"w\" ) as f : if format : f . write ( json . dumps ( data , sort_keys = False , indent = 4 , separators = ( ',' , ': ' ), encoding = \"utf-8\" , ensure_ascii = False )) else : f . write ( json . dumps ( data )) if __name__ == \"__main__\" : main ( sys . argv [ 1 :]) 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/05/20160523python_json_csv.html","loc":"pages/2016/05/20160523python_json_csv.html"},{"title":"20160516排队论","text":"排队论与提单","tags":"misc","url":"pages/2016/05/20160516pai-dui-lun.html","loc":"pages/2016/05/20160516pai-dui-lun.html"},{"title":"20160516unity编辑器扩展","text":"Unity编辑器扩展之EditorWindow 继承这个类的编辑器脚本可以用来创建一个编辑器窗口，类似Inspector窗口 若要在这个类中添加一些控件，可以使用GUI和GUILayout控件，还可以使用编辑器专用控件EditorGUI/EditorGUILayout 脚本创建 在Assets/Editor文件夹下创建脚本，并继承UnityEditor.EditorWindow 在OnGUI函数中写控件代码 窗口显示的触发 一般使用MenuItem属性创建一个菜单选项，点击后调用此函数显示窗口，如 EditorWindow.GetWindow(typeof(MyWindow)) 为窗口添加控件 上述提到的EditorGUILayout等类中包含类各种控件，比如 IntField, IntPopup, IntSlider, Vector2Field, TextField 等等 将创建这些控件的代码放在OnGUI函数中，则每一次渲染窗口都会执行一次 其他功能 Update():对于可见窗口，每秒调用100次 OnDestroy():关闭窗口时调用 OnFocus():窗口被选中时调用 OnLostFocus():窗口不再被选中时调用 例子 以下为示例，还可参考Unity官方文档EditorWindow部分 using UnityEditor ; using UnityEngine ; public class MyExt : EditorWindow { private int param1 = - 1 ; private float param2 = 0 ; private string name = \"\" ; private int id = 0 ; [ MenuItem ( \"MyExt/Edit\" , false , 1 )] private static void Init () { MyExt editor = ( MyExt ) EditorWindow . GetWindow ( typeof ( MyExt )); editor . Show (); } void OnGUI () { GUILayout . Label ( \"Section1\" , EditorStyles . boldLabel ); param1 = EditorGUILayout . IntField ( \"param1 int\" , param1 ); if ( GUILayout . Button ( \"Load\" )) { Debug . Log ( \"Load\" ); } GUILayout . Label ( \"Section2\" , EditorStyles . boldLabel ); param2 = EditorGUILayout . FloatField ( \"param2 float\" , param2 ); name = EditorGUILayout . TextField ( \"Name\" , name ); id = EditorGUILayout . IntSlider ( \"id 0~8\" , id , 0 , 100 ); } } 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/05/20160516unitybian-ji-qi-kuo-zhan.html","loc":"pages/2016/05/20160516unitybian-ji-qi-kuo-zhan.html"},{"title":"20160506Unity中的layer和tag","text":"Unity中的layer和tag layer和tag均用于标识不同类别的gameobject，侧重点不同 Layer Unity中默认已经有8种layer，但可以自行设置layer，上限32种，对应于一个int值的32位 对于场景中的gameobject，均可以设置其layer。 用于camera layer和camera配合起来，可以达到尽在camera上渲染特定层gameobject的效果 相机有culling mask属性，也是对应于一个32位int值，如果对应layer的bit为1，则渲染此layer到此摄像机，在inspector界面可以选择多个layer，也可以在代码中设置多个layer的mask，比如 camera.cullingMask = 1<<10 + 1<< 5 camera的clipping planes属性有类似的作用，可限制绘制的物体距离范围，仅在范围内的将会被绘制。比如在房间中，紧贴camera的墙可以隐藏掉 用于raycast raycast可检测一条射线与gameobject的碰撞，检测时可以定义layermask参数，从而只和这些layer的物体发生碰撞 做raycast之前，通常要生成一条射线，相应的api为 ScreenPointToRay 从摄像机到屏幕坐标的射线 ViewportPointToRay 从摄像机到视口坐标的射线。视口坐标是相对于相机标准化的坐标，左下角为(0,0)，右上角(1,1)。视口坐标可以和世界坐标、屏幕坐标相互转换 做raycast时，定义相关layermusk Physics.Raycast(ray, disance, layermask) 如果没有定义layermask，则仅忽略IgnoreRaycast layer的物体 用于灯光 通过设置仅照亮特定layer Tag 可以通过 GameObject.FindWithTay() 快速搜索到相关物体 作者Focustc，来自于 CSDN","tags":"misc","url":"pages/2016/05/20160506unityzhong-de-layerhe-tag.html","loc":"pages/2016/05/20160506unityzhong-de-layerhe-tag.html"},{"title":"20160405python新式类和经典类","text":"python的new style class和classic class 新式类是为了统一type和object引进的，旧式类已在python3中移除 首先看一下以下代码 class X : pass class Y ( object ): pass print type ( X ), type ( X ()) print type ( Y ), type ( Y ()) print type ( object ), object . __class__ , object . __base__ print type ( type ), type . __class__ , type . __base__ <type 'classobj'> <type 'instance'> <type 'type'> <class '__main__.Y'> <type 'type'> <type 'type'> None <type 'type'> <type 'type'> <type 'object'> 上述代码中，X为经典类，继承object的新式类Y则相当于新定义了一个类型 新类型系统/对象模型 首先， type() 和` class ``是等价的，给出对象的类型 type和object是对象模型的两个原生object type和object的关系 type是所有type的type，而object同时是所有type的基类 type是type的一个实例，type是object 的子类 object是type的一个实例，不存在父类 type object指的是可以实例化、派生子类的object，即各种class/类，其type为type。none-type object的type不是type，不可实例化，不可派生子类，称为实例 参考 python types and objects __dict__ 字段 类和实例均有 __dict__ 字段，当取object的属性时，首先到实例的 __dict__ 中查找，如果找不到，则到 __class__.__dict__ 中查找，之后会到基类中查找（ __class__.__bases__ ） 一些内置类型没有 __dict__ ，如list、tuple","tags":"misc","url":"pages/2016/04/20160405pythonxin-shi-lei-he-jing-dian-lei.html","loc":"pages/2016/04/20160405pythonxin-shi-lei-he-jing-dian-lei.html"},{"title":"20160331python不要使用mutable类型默认参数","text":"python勿使用mutable值作为默认参数 首先看以下一段代码 def append ( num , container = []): container . append ( num ) return container print append . func_defaults print append ( 1 ) print append ( 2 ) ([],) [ 1 ] [ 1 , 2 ] 为什么返回结果发生了改变？python函数执行时，默认参数只会在def函数时初始化一次，并不会每次运行时都发生改变，以后每次调用都使用同一个默认参数变量。 默认参数 函数的默认参数存放在 func_defaults ，调用函数时若没有传入默认参数，则取出 func_defaults 中的值赋给此形参 如果默认值为mutable类型，则为传引用，多次调用时必然出现类似上述的错误 默认参数不要使用mutable类型，使用immutable类型，如None，更合适 上述函数正确的实现方式为 def append ( num , container = None ): if ( container is None ): container = [] container . append ( num ) return container","tags":"misc","url":"pages/2016/03/20160331pythonbu-yao-shi-yong-mutablelei-xing-mo-ren-can-shu.html","loc":"pages/2016/03/20160331pythonbu-yao-shi-yong-mutablelei-xing-mo-ren-can-shu.html"},{"title":"20160324查看unity的scene流程","text":"Unity新项目如何快速理清顶层代码结构 半路上手新项目时弄懂scene切换流程是有必要的，scene切换可以说是unity最上层的代码资源结构 要再进一步弄清脚本调用顺序的话，就要选择一个参照标准，时刻停下来，看调用入口 思路 首先我们在入口scene（第一个scene）中添加新的GameObject，绑定脚本，每帧打印当前scene的名字，并防止在scene切换时销毁 根据打印输出的scene名字，在代码中搜索 LoadLevel 如果 LoadLevel 有一个专门的脚本管理器封装，那么查看被调用位置即得知scene切换入口；如果 LoadLevel 分布在脚本中，则被调用位置即为切换入口 找到切换入口之后，从入口scene开始，分别打开每个scene，并运行。查看运行前后Hierarchy中的GameObject变化，即可知道每个scene初始化时做了什么，再查看scene中脚本的awake和start函数 这样一来，代码的顶层结构即可得到，可根据需要再继续细查每一个功能模块入口。 查看功能模块逻辑时，可以搜索相应的单词，比如武器系统搜索 weapon 。找到相应的脚本，在init部分加入 Debug.Break() ，暂停运行，观察scene中的资源。进而在init部分打印一些log，运行时可以直观的看到调用堆栈 代码示例 以下是打印当前scene的名字的脚本 public class test : MonoBehaviour { private AsyncOperation async ; void Start () { DontDestroyOnLoad ( this ); } void Update () { Debug . Log ( Application . loadedLevelName ); } }","tags":"misc","url":"pages/2016/03/20160324cha-kan-unityde-sceneliu-cheng.html","loc":"pages/2016/03/20160324cha-kan-unityde-sceneliu-cheng.html"},{"title":"20160323unity切换场景","text":"Unity中的场景切换 与电影类似，一个游戏往往需要多个场景。而如果场景中资源较少，那么可以很快的完成切换，如果较多的话，可能需要十几秒时间。在这段时间内播放加载动画等等，可以减少玩家的不耐烦。 同步切换场景 Application.LoadLevel() Application.LoadLevelAdditive() 加载完成后保留旧场景中资源 异步切换场景 Application.LoadLevelAsync() 异步加载场景，加载过程中当前场景不会卡死。返回值包含加载进度 代码示例： public class test : MonoBehaviour { private AsyncOperation async ; void Start () { Debug . Log ( Time . time ); StartCoroutine ( \"Switch\" ); } void Update () { Debug . Log ( async . progress ); } IEnumerator Switch () { async = Application . LoadLevelAsync ( \"LoadingScene\" ); yield return async ; } } Application.LoadLevelAdditiveAsync 加载新场景完成后不释放旧资源 通常做场景切换时，首先切换到一个较小的loading动画场景，之后异步加载新场景 无缝场景切换 场景管理对象需要一直存在： Object.DontDestroyOnLoad() 可以防止切换场景时销毁 异步加载新资源，并逐步销毁旧资源","tags":"misc","url":"pages/2016/03/20160323unityqie-huan-chang-jing.html","loc":"pages/2016/03/20160323unityqie-huan-chang-jing.html"},{"title":"20160314ugui","text":"ugui Canvas的三种渲染方式 screen space overlay UI永远出现在画面最前端 无需camera和light 可以自动适配屏幕 screen space camera 可以在UI上层显示特效和模型 显示效果受到相机透视或者正交的影响 world space 把UI视为3D模型","tags":"misc","url":"pages/2016/03/20160314ugui.html","loc":"pages/2016/03/20160314ugui.html"},{"title":"20160314char_pointer","text":"char * 和 char* 的区别 这两种写法编译上面都没有问题，但是在某些情况下会造成歧义 char* p1, p2 这样的写法声明了指针p1，字符p2 char *p1, *p2 这样的写法表示声明了两个指向字符的指针 * 是变量的修饰符 *p 表示p是一个指针，是修饰p的，而不是修饰 char 的 因此*和p之间不要有空格，否则就会造成误解，误以为 char* 是一种数据类型，继而出现上述错误","tags":"misc","url":"pages/2016/03/20160314char_pointer.html","loc":"pages/2016/03/20160314char_pointer.html"},{"title":"20160229文本编码","text":"文本编码 文本编码这个问题自三年前就困扰着我，当时是用Python处理多国语言时出现的bug，最后问题解决了，但其中具体逻辑并不懂。后来零零散散接触了不少资料，算是大致弄明白，记录如下。 unicode与ascii等编码方案 ascii ascii编码方案一共规定了128个字符对应的二进制表示，只占用了一个字节的后面7bit，最高位为0 欧洲国家使用128个符号不足以表示所有字母，使用了最高位。因此不同的国家128~255表示不同的符号，并不通用，即为扩展的ascii码，包括ISO-8859-1~15。这些都是单个字节编码。 ISO-8859-1 ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，没有被收录在ISO-8859-1当中 ISO-8859-1编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃 Latin1是ISO-8859-1的别名，有些环境下写作Latin-1 gb2312 一种双字节编码，包含6763个汉字 gbk 对gb2312的扩展，可以表示21003个汉字，兼容gb2312 gb18030 unicode的一种天朝实现 采用单、双、四字节编码，兼容gb2312 base64 base64使用64个可打印字符表示二进制数据。每个单元包含6bit。转换后每76个单元要加上一个换行符。 可打印字符包括： A-Z a-z 0-9 以及两个其他不定符号，大部分实现为 + / 将每3个字符编码为4个单元，不足3个的用 = 补足 unicode unicode试图表示所有的字符 采用unicode的系统、平台有： windows NT及后续系统、java采用utf16作为内置编码 .net, mac, kde同样使用unicode utf-8是unix-like操作系统的主要存储编码方案 utf-8是html文件最常用的unicode编码 XML及其子集XHTML采用UTF-8作为标准字集 编码方案 对每个字符规定了一个码点：code point unicode现在包括17个平面，每个平面最多可以存放65536个字符，也即需要至少21个bit才足够表示所有码点。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0016到1016，共计17个平面 首先的256个字符编码与ISO-8859-1相同 表示方式为 U+ 紧跟十六进制表示。基本平面（BMP U+0000到U+FFFF）中采用四个数字（2byte），16个辅助平面（SMP U+10000到U+10FFFF）中采用5~6个数字 实现方案 实现方案包括Unicode Transformation Format (UTF)和Universal Coded Character Set (UCS)两种 unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF） utf8：8bit变长编码，详细实现见下一节 utf16：16bit变长编码，下有详述 utf32：32bit定长编码，完全对应unicode usc-2：2byte定长编码，utf16的子集，JavaScript使用此编码方案。因为不能表示更多字符，后续在此基础上发展出了utf16 usc-4：等价于utf32 gb18030 utf16 对BMP中的字符使用2byte表示，SMP使用4byte BMP从U+D800到U+DFFF之间的码位区段是永久保留不映射到Unicode字符 辅助平面的字符位共有2&#94;20个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小2&#94;10），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小2&#94;10），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 对于两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。 utf8 采用1~4个byte对unicode进行编码，每个字元只有1byte，不存在字节序问题 unicode和utf8编码对应关系 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 单字节字符的最高有效比特永远为0。 多字节序列中的首个字元组的几个最高有效比特决定了序列的长度。最高有效位为110的是2字节序列，而1110的是三字节序列，如此类推。 多字节序列中其余的字节中的首两个最高有效比特为10 具体为何根据这样麻烦的规则编码呢？一是防止解码出现歧义，二是尽量压缩存储空间。如果学过编码理论或者信息论应当很容易明白。 相对于utf16 utf16编码效率/性能较高，字符到字节转换更为方便 utf8消耗存储空间较少 文本和IO IO时经常需要对文本进行编解码或编码格式转化 在硬盘文件中：以文件编码格式存储 在内存中：java和c#用utf16 如何显示在屏幕上：显卡驱动（虚拟设备）根据输入字节及编码渲染 网络：按照应用层商定的协议编解码 utf8和BOM 什么是BOM BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。 utf不同编码实现的BOM定义： UTF-8 EF BB BF UTF-16（大端序） FE FF UTF-16（小端序） FF FE UTF-32（大端序） 00 00 FE FF UTF-32（小端序） FF FE 00 00 对于utf8，没有字节顺序的议题。UTF-8编码过的字节顺序标记则被用来标示它是UTF-8的文件。它只用来标示一个UTF-8的文件，而不用来说明字节顺序。 对于utf16和utf32，用来表示大端还是小段 BOM相当于魔数（magic number） 图像文件、ELF文件、class文件都存在魔数 linux命令file能根据魔数（libmagic）判断文件类型 文件扩展名更重要的作用是让系统决定当用户想打开这个文件的时候用哪种软件运行，如Windows系统中exe文件是可执行档，doc文件默认用Microsoft Word打开的Word文件。 记事本四种另存为的编码格式 ANSI（对于英文系统即ASCII编码，中文系统则为GB2312或Big5编码） \"Unicode\"（对应UTF-16 LE） \"Unicode big endian\"（对应UTF-16 BE） \"UTF-8\"：带 BOM 的 UTF-8 使用utf8不要包含BOM 不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。 许多windows程序（包含记事本）会添加字节顺序标记到UTF-8文件。然而，在类Unix系统中，这种作法则不被建议采用。因为它会妨碍到如shell脚本开头的一些重要的码的正确处理。它亦会影响到无法识别它的编程语言。 参考 wiki:BOM wiki:Unicode 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2016/03/20160229wen-ben-bian-ma.html","loc":"pages/2016/03/20160229wen-ben-bian-ma.html"},{"title":"20160218pythonChallenge","text":"pythonChallenge 可以将url里的/pc改成/pcc来查看上一题的参考代码 0 计算2&#94;38即可，替换*.html 1 观察知为移位加密，需要了解的api有： ord()和chr()用于在char和ascii数字之间转换 推荐使用string.translate()来解密，string.maketrans可以用来生成table 用同样的算法对url中的map进行解密即可得到下一url 2 根据提示，查看网页源码，要求统计字符串中的低频字符，得到之后拼接成一个单词即可 3 要求找到一个小写字母，左右两边均有三个大写字母相邻，使用re模块的findall方法，建议看看参考代码，其中给出了多种使用re的方案 \"\" .join ( re.findall ( ' [ &#94; A-Z ][ A-Z ] { 3 } ([ a-z ])[ A-Z ] { 3 } [ &#94; A-Z ] ' , text )) .join ( x [ 1 ] for x in re.findall ( ' ( &#94;| [ &#94; A-Z ])[ A-Z ] { 3 } ([ a-z ])[ A-Z ] { 3 } ([ &#94; A-Z ] | $ ) ' , text )) .join ( re.findall ( ' ( ? : &#94;| [ &#94; A-Z ])[ A-Z ] { 3 } ([ a-z ])[ A-Z ] { 3 } ( ? :[ &#94; A-Z ] | $ ) ' , text )) .join ( re.findall ( \"(?<=[&#94;A-Z][A-Z]{3})[a-z](?=[A-Z]{3}[&#94;A-Z])\" , text )) 使用 () 包围起来一个group，返回值为group 4","tags":"misc","url":"pages/2016/02/20160218pythonchallenge.html","loc":"pages/2016/02/20160218pythonchallenge.html"},{"title":"20160129Unity调用Native代码","text":"Unity调用Native代码 iOS iOS程序入口 安卓 安卓程序入口 生命周期 是否可见 是否可触摸","tags":"misc","url":"pages/2016/01/20160129unitydiao-yong-nativedai-ma.html","loc":"pages/2016/01/20160129unitydiao-yong-nativedai-ma.html"},{"title":"20160113Android编程权威指南","text":"设备默认使用/res/layout目录下布局资源。水平时将尝试使用res/layout-land下资源 设备配置如果发生改变,activity将会销毁后重新创建","tags":"misc","url":"pages/2016/01/20160113androidbian-cheng-quan-wei-zhi-nan.html","loc":"pages/2016/01/20160113androidbian-cheng-quan-wei-zhi-nan.html"},{"title":"20151014 命令行字典","text":"命令行字典 作为一个有追求的程序员，当然想把一切操作通过键盘来完成，让手指保持在键盘上。那么，如何做到用键盘来查询英文单词呢？突发奇想在命令行里用python脚本来爬取有道词典的查询结果，使用 requests + BeautifulSoup 实现，效果还不错。 代码 代码放在了 heLomaN@Github 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/usr/bin/env python # coding=utf-8 import requests as rq from BeautifulSoup import BeautifulSoup as bs def query ( word ): query_dict = { 'le' : 'eng' , 'q' : word } r = rq . get ( 'http://dict.youdao.com/search' , query_dict ) soup = bs ( r . text ) trans_div = soup . find ( 'div' , { 'class' : 'trans-container' }) #print trans_div interpretations = trans_div . findAll ( 'li' ) for elem in interpretations : print ' \\t ' , elem . string if __name__ == '__main__' : word = raw_input ( 'Query: \\t ' ) while ( word != 'q' ): query ( word ) word = raw_input ( 'Query: \\t ' ) 执行脚本后，输入待查询单词即可，输入 q 可退出执行 机制非常简单，构造查询url，获得html后找到对应于释义的div，打印其中内容 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2015/10/20151014-ming-ling-xing-zi-dian.html","loc":"pages/2015/10/20151014-ming-ling-xing-zi-dian.html"},{"title":"20150409C++中的容器","text":"C++中的容器 容器与容器适配器 容器包括vector, deque, list, map, multimap, set, multiset。容器适配器包括基于deque的stack和queue，基于vector的priority_queue。string也实现了stl的接口。 因为编写C++程序时经常需要查找容器的函数接口，故作此总结。C++新引入的容器与函数未引入。主要参考自： STL Containers and Container Adaptors 序列容器 包括vector，deque，list 共有函数 构造函数 ContainerType<T> c; ContainerType<T> c(num); ContainerType<T> c(num, val); ContainerType<T> c(inIterBegin, inIterEnd); //复制构造函数 ContainerType<T> c(otherLikeContainer); ContainerType<T> c = otherLikeContainer; 赋值构造函数 c1 = c2 比较运算 c1 == c2 c1 != c2 c1 < c2 //按元素逐个比较 c1 <= c2 c1 > c2 c1 >= c2 容量 empty() size() max_size() resize(num, val = default) 迭代器和引用 begin() end() rbegin() rend() front() back() 插入值 push_back(val) insert(iter, val) insert(iter, num, val) insert(iter, inIterBegin, inIterEnd) 赋值（换掉容器内所有元素） assign(inIterBegin, inIterEnd) assign(num, val) 删除元素 pop_back() erase(iter) erase(iterBegin, iterEnd) clear() 其他 swap(otherLikeContainer) get_allocator() 特有函数 vector特有 reserve(num) capacity() list特有 merge(otherList) //按照大小顺序合并，二者必须是有序的 merge(otherList, binPred) remove(val) remove_if(unPred) reverse() sort() sort(binPred) splice(iter, otherList) //将otherList中所有元素移动到iter处 splice(iter, otherList, otherIterBegin, otherIterEnd) unique() unique(binPred) vector和deque特有 at(index) //会检查下标范围 operator[](index) deque和list特有 push_front(val) pop_front() 容器适配器 包括stack，queue，priority_queue 共有函数 c1 = c2 empty() size() push(val) pop() 特有函数 queue特有函数 front() back() stack和priority_queue 特有函数 top() == != < <= > >= 序列容器与容器适配器函数表格 参见 The STL Sequential Containers and Container Adaptors, and their Member Functions 关联容器 包括map, multimap, set, multiset 共有函数 赋值 c1 = c2 比较 == != < <= > >= 容量 empty() const size() const max_size() 迭代器 begin() end() rbegin() rend() 插入值 insert(p, val) insert(start, end) 删除 erase(someKey) erase(iter) erase(start, end) clear() 查找 count(someKey) find(someKey) //返回迭代器 lower_bound(someKey) //大于等于someKey的迭代器 upper_bound(someKey) //大于someKey的迭代器 equal_range(someKey) 其他 swap(otherLikeContainer) get_allocator() //key和val比较的函数对象 key_comp() value_comp() 特有函数 其实不存在特有函数，只是这些函数的接口略有不同 - map/multimap特有构造函数 ContainerType<keyType, ValueType> c; ContainerType<KeyType, ValueType> c(inIterBegin, inIterEnd); ContainerType<KeyType, ValueType> c(otherLikeContainer); set/multiset特有构造函数 ContainerType<T> c; ContainerType<T> c(inIterBegin, inIterEnd); ContainerType<T> c(otherLikeContainer); map特有成员函数 operator [ someKey ] map/set特有成员函数 //返回值为pair<iterator, true/false（是否已经含有此值）> insert(val) multimap/multiset特有成员函数 //返回iterator insert(val) 关联容器函数表格 参见 The STL Associative Containers and their Member Functions 其他 包括string，bitset等类容器 string 构造函数 string s; string s(c_string_value); string s(char_array, size_type_count); string s(string_value); string s(string_value, size_type_index); string s(string_value, size_type_index, size_type_count); string s(size_type_count, char_value); string s(input_iterator_start, input_iterator_end); 取char s [ i ] s . at ( i ) // 边界检查 迭代器 s.begin() s.end() s.rbegin() s.rend() append与赋值 operator+= s.append(string_value) s.append(c_string_value) s.append(size_type_count, char_value) s.append(c_string_value, size_type_count) s.append(c_string_value, size_type_index, size_type_count) s.append(first_input_iterator, last_input_iterator) // operator= s.assign(string_value) s.assign(c_string_value) s.assign(size_type_count, char_value) s.assign(c_string_value, size_type_count) s.assign(c_string_value, size_type_index, size_type_count) s.assign(start_input_iterator, end_input_iterator) 转换为c-string s.copy(char_array, size_type_count, size_type_index) s.c_str() //返回以\\0结束的char数组地址，数组归s所有，不要更改 s.data() //返回不以\\0结束的char数组地址，数组归s所有，不要更改 子串 s.substr(size_type_index) s.substr(size_type_index, size_type_count) 容量及调整容量 s.empty() s.capacity() s.length() s.size() s.max_size() s.reserve(size_type_value) s.resize(size_type_value, char_value) s.resize(size_type_value) 删除 s.clear() s.erase() //删除所有字符 s.erase(size_type_index) s.erase(size_type_index, size_type_count) s.erase(iterator_position) s.erase(first_iterator, last_iterator) 查找 //所有的find均返回下标值，若找不到，返回string::npos // //查找char s.find(char_value) s.find(char_value, size_type_index) s.rfind(char_value) s.rfind(char_value, size_type_index) // //查找string s.find(string_value) s.find(string_value, size_type_index) //从index处开始查找 //从后向前查找 s.rfind(string_value) s.rfind(string_value, size_type_index) //查找cstring s.find(c_string_value, size_type_index, size_type_count) s.rfind(c_string_value, size_type_index, size_type_count) // s.find_first_of(char_value) s.find_first_of(char_value, size_type_index) s.find_first_not_of(char_value) s.find_first_not_of(char_value, size_type_index) // //查找在/不在string中的char，返回下标 s.find_first_of(string_value) s.find_first_of(string_value, size_type_index) s.find_first_not_of(string_value) s.find_first_not_of(string_value, size_type_index) // s.find_first_of(c_string_value, size_type_index, size_type_count) s.find_first_not_of(string_value, size_type_index, size_type_count) // s.find_last_of(char_value) s.find_last_of(char_value, size_type_index) s.find_last_not_of(char_value) s.find_last_not_of(char_value, size_type_index) // s.find_last_of(string_value) s.find_last_of(string_value, size_type_index) s.find_last_not_of(string_value) s.find_last_not_of(string_value, size_type_index) // s.find_last_of(c_string_value, size_type_index, size_type_count) s.find_last_not_of(string_value, size_type_index, size_type_count) 插入值 s.insert(size_type_index, string_variable) s.insert(size_type_index, c_string_value) s.insert(size_type_index1, string_variable, size_type_index2, size_type_count) s.insert(size_type_index, c_string_value, size_type_count) s.insert(size_type_index, size_type_count, char_value)//c++中函数形参总是count在val之前 s.insert(iterator_position, size_type_count, char_value) s.insert(iterator_position, char_value) s.insert(iterator_position, input_iterator_first, input_iterator_last) // s.push_back(char_value) 字符/字符串替换 s.replace(size_type_index, size_type_count, string_value) s.replace(iterator_first, iterator_last, string_value s.replace(size_type_index1, size_type_count1, string_value, size_type_index2, size_type_count2) s.replace(size_type_index, size_type_count, c_string_value) s.replace(iterator_first, iterator_last, c_string_value) s.replace(size_type_index, size_type_count1, c_string_value, size_type_count2) s.replace(iterator_first, iterator_last, c_string_value, size_type_count) s.replace(size_type_index, size_type_count1, size_type_count2, char_value) s.replace(iterator_first, iterator_last, size_type_count, char_value) s.replace(iterator_first, iterator_last, input_iterator_start, input_iterator_end) 比较 //==, !=, <, > <=, >=已经重载 // //compare返回值为int：s-other s.compare(string_value) s.compare(size_type_index, size_type_count, string_value) s.compare(size_type_index1, size_type_count1, string_value, size_type_index2, size_type_count2) // s.compare(c_string_value) s.compare(size_type_index, size_type_count, c_string_value) s.compare(size_type_index, size_type_count1, c_string_value, size_type_count2) 其他函数 s.swap(string_variable) // //以下三个非成员函数 swap(string_variable1, string_variable2) // getline(inStream, string_variable) // string结果不包含delimiter getline(inStream, string_variable, char_delimiter_value) 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点我","tags":"misc","url":"pages/2015/04/20150409czhong-de-rong-qi.html","loc":"pages/2015/04/20150409czhong-de-rong-qi.html"},{"title":"20141229 python的类","text":"python的类 module的属性与作用域 属性分为只读的和可写的。可写的属性也可以删除： del a.attr 内置namespace在 __builtin__ 模块下，程序中的语句在 __main__ 中 如果一个name生命为global，则所有的引用赋值可以直接找到此name。否则，此name是只读的，任意写操作都会新建一个同名局部变量 类 __init__ 在类实例化时被调用 python的对象分为类对象、实例对象、方法对象 将可变类型作为类对象会带来多个其实例对象修改同一个可变类型，最好放入 __init__ 中作为实例对象 数据属性可能覆盖同名方法属性 可以将函数对象赋值给类对象作为成员 每个对象都有一个类型： object.__class__ 派生和继承 继承： class derived(base): 派生类中所有方法都是虚的 多继承：搜索时从左到右，深度搜索 name mangling：以两个下划线开始的属性将被替换为 _classname__spam","tags":"misc","url":"pages/2014/12/20141229-pythonde-lei.html","loc":"pages/2014/12/20141229-pythonde-lei.html"},{"title":"20141208 python数据类型","text":"Python中的数据类型 字符串和数组是immutable的 使用 type(var) 可以很方便的确认变量类型 使用 id(var) 可以查看每个变量对象的id，id相同表示两个对象在内存中位置相同，节省了开销 tuple、list、dict分别用 () [] {} 表示 数据类型间转换： int() float() complex() str() list() tuple() 布尔类型 True 和 False 布尔运算：and or not 整数Int 超出一个范围后，会自动转换为Long数据类型，也可以使用 345L 的方式强制使用long类型 浮点数Float 字符串 字符串用单引号 ' ' 、双引号 \" \" 、三引号 ''' ''' ，其中三引号内的字符串可以分成多行书写 \\ 表示转义，而字符串前加入r可以防止转义 split join 是最常用的方法，用于分词，在list和string之间转换 列表List 用 [] 表示，包含的元素可以是不同类型的任何类型 方法包括：append extend insert remove reverse pop index count sort len del + * 可以对两个、多个list进行连接 sort：对list排序 list slice:类似于matlab，使用形式为 a[start:end:step] ，可以使用负数表示从后向前数，下标区间前开后闭 in:可以使用in判断是否在list中 'a' in ['a','b'] 元组Tuple 与List的不同之处在于初始化后不能更改 若要创建单元素的tuple则需要在变量后添加一个逗号，如 type(('a',)) 与list相同，支持slice 集合Set 元素不可重复，包含集合运算 字典Dict key必须为不可变类型 keys() values() 方法获取key和valuelist 判断key是否存在： dct.has_key('key') clear:清空字典内容 python控制语句 if if...elif...else for 按照顺序迭代序列 for i in range(10) break continue 循环语句的else子句：在for或者while执行结束后，如果不是由break中断，则执行else字句中的代码 pass 表示什么也不做，用于占位 list comprehension [expr for var in iterable if cond_expr] 方便的使用已有列表生成新列表 [2**i for i in list(range(10)) if i%2 == 0] map reduce filter都可以使用这种方式实现 generator expression (expr for var in iterable if cond_expr) 更节省内存，返回一个generator 操作符优先级 从最优先开始：slice/属性/调用 幂 正负/按位取反 乘除取余 加减 移位 按位与/异或/或 比较 布尔运算 if_else lambda表达式 = 不能放在表达式中，与C不同 函数 docstring 第一行是用途的简短描述，第二行空白 函数参数 每个函数调用都会创建一个被调函数的局部符号表，参数传递使用call by value（对象的引用） 没有return语句的函数返回值为None，没有参数的return语句也返回None 可以使用 = 指定默认参数值，调用时可以不给出默认参数值，或者给出部分默认参数值。而默认值在函数定义时已经指定，即代码执行到def methodname时 函数调用时positional argument可以与keyword arguments混用，但positional argument一定要在前面。keyword arguments出现顺序随意 *name 作为函数参数可以接收到所有不在形参列表中的positional argument， **name 可以接收到所有不在形参列表中的keyword arguments 相反的，可以在调用函数时，使用 *name``**name 展开已有的tuple/list或者dict作为函数参数 函数嵌套 与C语言不同，函数定义内可以包含另一个函数的定义，即函数嵌套 嵌套外部函数称为外部作用域。变量查找顺序为LEGB（L：Local，E：Enclosing，G：Global，B：Built-in） 查找变量时，若有对变量的赋值操作但没有用global，则为局部变量，按照：局部作用域-外部作用域-全局作用域-python内建作用域的顺序查找。若变量已经被声明为global，则直接从全局作用域开始查找 最内嵌套作用域规则：由一个赋值语句引进的名字在这个赋值语句所在的作用域里是可见（起作用）的，而且在其内部嵌套的每个作用域里也可见，除非它被嵌套于内部的，引进同样名字的另一条赋值语句所遮蔽/覆盖 发生函数嵌套后，如果内部函数引用了外部函数的局部变量，那么外部函数的局部变量将被静态存储，即当函数退出后，其局部变量所占内存也不会被释放 。为什么？参考 http://developer.51cto.com/art/200809/90863_4.htm global 若函数内部变量和外部变量同名，通常，如果函数内部对变量进行赋值，那么此变量认为是局部变量；若函数内从未有赋值，则此变量为全局变量 若使用global声明，则可以在函数内部对全局变量赋值 书写规范 参照PEP8风格 每行不超过79个字符 运算符前后和逗号后面使用空格，但是括号里侧不加空格 类使用CamelCase，函数使用lower_case_with_underscores 只使用ASCII编码 遍历技巧 enumerate 可以同时得到索引下标和对应的值 for ind,val in enumerate(list_a) zip 同时成对读取元素 for p,q in zip(list_a, list_b) reversed 反向遍历 for i in reversed(list_a) sorted 遍历排序后序列，源列表不变 for i in sorted(list_a) iteritems 遍历字典时同时得到key和value for k, v in dct.iteritems() generator和yield 含有yield语句的函数返回值为类型generator，其next方法可以一次函数调用到下一个yield语句 每次发生next调用时，函数执行完yield后挂起，返回yield值，保存函数状态。下次调用时从yield语句后执行到再次遇到yield 内置函数 python内置，包括之前提到的id type等等，包括数学运算、集合运算、逻辑运算、反射、IO等等。可以参考 http://jianfeihit.iteye.com/blog/1835272 enumerate:返回一个generator，next调用返回一个tuple(index, value) xrange:与range类似，但返回一个generator，节省内存 eval:计算表达式的值 execfile:执行文件 hasattr：检测对象是否具有某个属性","tags":"misc","url":"pages/2014/12/20141208-pythonshu-ju-lei-xing.html","loc":"pages/2014/12/20141208-pythonshu-ju-lei-xing.html"},{"title":"20140914面试题集锦","text":"面试题集锦 谨对一些看过的面试题做一些总结 以下部分来自于纸上谈兵 为什么正二十面体的体积面积比比四边形的大？ 正态分布和均匀分布之间是否可以相互转换？ 三门、女孩、三囚犯问题： http://zhiqiang.org/blog/science/three-doors-related-problems.html 找到和为k的子数组 一个与世隔绝的岛屿上有13个黑人、15个白人和17个黄种人。任何两种不同皮肤的人遇到一起，就会都变成另外一种颜色。问是否可能所有人都变成同一种颜色？ 你有100个硬币。首先你将它分成两堆，分别有x枚和y枚硬币，得到它们的乘积。再任意将其中的一堆分成两堆，得到两个小堆的硬币数量的乘积。这样一直分下去直到每个堆只有一枚硬币无法再分为止。将所有得到的乘积加起来，问最后这样的乘积和最大是多少？","tags":"misc","url":"pages/2014/09/20140914mian-shi-ti-ji-jin.html","loc":"pages/2014/09/20140914mian-shi-ti-ji-jin.html"},{"title":"20140910碰撞检测","text":"向量点乘","tags":"misc","url":"pages/2014/09/20140910peng-zhuang-jian-ce.html","loc":"pages/2014/09/20140910peng-zhuang-jian-ce.html"},{"title":"20140908《全景探秘游戏设计艺术》精华 用户体验 游戏平衡性","text":"《全景探秘游戏设计艺术》精华 用户体验 游戏平衡性 一本很好的游戏设计书籍，暂时关注的是用户体验部分，比如，用户喜欢什么，什么可以带来乐趣，以及游戏的平衡性 男性与女性的区别 男性喜欢的游戏要素 征服：控制一切 竞争：与他人竞争来表明自己是最棒的 破坏：破坏带来快感 空间谜题：男性有更好的空间推理能力 尝试和失败：男性不喜欢阅读说明，更喜欢通过尝试和失败来学习 女性喜欢的游戏要素 情感：比如爱情与浪漫 与真实世界关联：如换装、虚拟人生、偷菜 照料别人：如宠物养成和游戏中的治疗师 对话和字谜：如填字游戏，仙剑 照实例学习：按照教程来学习 游戏的乐趣 美学：精美的画面和优美的背景音乐，是感官的乐趣，如三位一体，梦幻的画面 幻想：把自己幻想成现实中无法成为的事物，如凡人修仙传 叙述：一个连续事件的戏剧性揭示过程，仙剑系列 挑战：解决游戏中给出的问题，是游戏的核心乐趣 伙伴关系：友谊与合作 探索新事物：对世界的探险和对某个策略的探索 表达：表达自我和创造事物的乐趣，比如minecraft 服从：遵从并适应游戏世界的规则 游戏玩家的分类 成功者：乐于完成游戏目标，主要乐趣在于挑战 探险家：希望了解世界的广度，主要乐趣是探索 社交者：乐趣是寻找伙伴关系 杀手：喜欢对抗和击败别人 一些其他的游戏乐趣 对乐趣即将到来的期待 幸灾乐祸：坏人得到惩罚、对抗类游戏 赠与礼物 幽默 选择的自主权 因成就而自豪 清除：如吃光所有豆子，杀掉所有敌人，拿到所有经验 经历恐惧之后安全，如left 4 dead，求生之路 逆境得胜 难以置信 游戏的平衡 公平性 挑战和成功：合理的难度，保持在沉浸区间 提供有意义的平衡的选择，如策略、装备、角色、衣服的选择 技能和几率：对应判断和承担风险 动脑和动手哦 对抗和协作 游戏时间长短 奖励的数量：逐渐增多、时间随机化 惩罚的轻重、方式 自由与控制：波斯王子游戏最后的场景，视角交由游戏控制以显得更激烈 游戏复杂性","tags":"misc","url":"pages/2014/09/20140908quan-jing-tan-mi-you-xi-she-ji-yi-zhu-jing-hua-yong-hu-ti-yan-you-xi-ping-heng-xing.html","loc":"pages/2014/09/20140908quan-jing-tan-mi-you-xi-she-ji-yi-zhu-jing-hua-yong-hu-ti-yan-you-xi-ping-heng-xing.html"},{"title":"20140908《金领简历》精华 创业公司 面试机会 简历","text":"《金领简历》精华 创业公司 面试机会 简历 《金领简历》在我看来是一本非常好的书，把面试之前的提前准备工作讲的非常到位，可惜在图书馆里没人借这本书。 本文主要讲关于是否选择去创业公司、如何得到面试机会、如何写出优秀的简历。 创业公司的特点 创业公司的有利之处 全面锻炼能力： 有机会培养各种技能，但如果是只专注某个领域的人才，应该避免加入创业公司 晋升机会更大：如果公司扩大规模，很容易成为团队领导 控制力与影响力：可以凭借自己的工作表现影响公司的发展，可以对具体事项提意见 能够迅速知道结果：通常几个月就能知道自己的决策是好是坏 高回报：有可能变得富有，但同时承担风险 创业公司的不利因素 需要长时间工作：需要大量的加班 工作职责不清晰：各种杂事都要做 低收入：薪酬低于业界标准，只能靠给股票期权来弥补，公司倒闭则成了废纸 信誉度低：如果公司倒闭，重新找工作时简历上工作经历是污点 得到的指导少：只能摸索着学习，而大公司或专业人士能够教给你一套解决问题的有效方法 像免费午餐等大公司提供的福利并不是关键，无关紧要 在大公司和创业公司之间做选择 去创业公司的机会随时都有 大公司能够学会真正的软件开发：代码审查、编程风格等 选择大公司就得到了短期辞掉工作加入创业公司的免费通行证 找工作的准备 GPA通常只是在简历筛选过程中有影响，是可以通过其他方面的成就补救的 实习与兼职 尝试为教授的研究工作提供帮助 联系创业公司提供免费帮助 成为非赢利性组织的志愿者 自己做出点名堂 开创一家公司，实现脑子里的一种想法/项目，可以到网站上雇佣人来做这个 撰写一个博客，并保持更新 创办一个俱乐部或组织 如何得到面试 网申：尽快申请，并使用JD里面的关键词，最好向JD里的邮箱同时发送求职邮件。不靠谱 内推 在社交网站上问问这些公司的朋友 让公司员工了解你：评论其博客，或写博客跟帖他的博客 联系HR 校友网络 招聘大会 准备好电梯演讲：我是谁，做过什么工作，擅长的事情，感兴趣的事情 调查研究心仪的公司：注重哪些素质？自己如何体现这些素质？ 准备开放性问题 准备一些自己背景相关的问题，巧妙作答以说明自己取得的重大成就和解决的重大挑战 定制简历：为不同职位定制不同的简历 衣着得体：衣着应与面试的衣服类似 跟踪后续进展：取得名片或邮箱地址，回去后发邮件跟踪，内容写自己对公司的兴趣、自己能为公司做什么、附上简历 可以有项目作品展示、看过的书籍展示 猎头 控制自己简历流向，要知道猎头公司的名字 在网络上做出贡献 创建一个网站：包括基本信息、简历、照片、做过的项目列表 开通一个博客，无论是不是技术的都可以 去别人的博客撰写客座博客文章 在论坛上解答问题 加入github，提交patch 简历 优秀简历的特点 成就导向，而不是职责导向 可量化的结果，如模块算法的大O表示法 目标明确：针对职位定制简历 有通用意义，使非专业人士也能了解你的贡献 简洁、清晰 组织良好：最能体现自己的能力的信息要非常突出 美国/加拿大职位简历中不能有种族、信仰、婚姻状况、照片 工作经验5年以下的简历最好保持在一页，不要让不痛不痒的经历埋没的真正的亮点","tags":"misc","url":"pages/2014/09/20140908jin-ling-jian-li-jing-hua-chuang-ye-gong-si-mian-shi-ji-hui-jian-li.html","loc":"pages/2014/09/20140908jin-ling-jian-li-jing-hua-chuang-ye-gong-si-mian-shi-ji-hui-jian-li.html"},{"title":"20140904reactive programming scala","text":"第一周 Quickcheck 实现一个heap 第二周 Simulations 电路仿真 每个器件固定时延，线路没有时延 或门仿真 多路分离器仿真 流行病仿真 使用矩阵模拟城市 飞机使用概率对结果又影响 图形显示接口 第三周 NodeScala 使用future实现一个异步服务器 可以对系统库中已有的类添加方法 扩展future对象，并添加取消方法 实现异步HTTP服务器 第四周 Wikipedia Suggestions 开发一个维基百科建议应用的图形界面，允许用户输入字符时实时显示可能的选择 第五周 Actor Binary Tree 实现一个基于actor的二叉树，可以全异步的并行执行 插入和contains查询都是自顶向下一条路径，remove采用标记的方法 实现GC方法 第六周 Replicated KV Store KV是一个最简单的数据库形式 本次实现一个分布式有备份的KV存储，分布式系统中的每个节点为一个actor，同时需要一些辅助的actor 系统包含一个主节点，负责复制所有改变到所有副节点。所有节点组成一个分布式数据库，备份节点随时可能加入或掉线 仅有主节点接受修改事件（插入与删除），所有的节点接受查找事件，允许副节点给出可能修改过的过期的数据 比现实系统做的简化如下 仅主节点会更新数据 主节点不会宕机 成员关系由一个可靠的子系统维护 数据更新速度较慢，不需要因为系统负载过大拒绝请求 如果拒绝更新后数据会处于可能不一致的状态，后续需要对此key重写以修复 希望客户端不会在请求处理完之前重用请求的id 系统组件 kv存储包括：主节点，副节点，节点调度器，一致性保持器 客户端：读取或更新数据 读取更新协议：一致性保证 主副节点保证同一个key的更新保持顺序，不同的key之间不需要 客户端在不同副节点最后读取结果一致，中间可以不一致 主节点更新数据后返回ack或者failed，应在至多1s内返回","tags":"misc","url":"pages/2014/09/20140904reactive-programming-scala.html","loc":"pages/2014/09/20140904reactive-programming-scala.html"},{"title":"20140727如何写出一个较好的快速排序程序","text":"写出一个较好的快速排序程序 快速排序是常用的排序算法之一，但要想写出一个又快又准的使用程序，就不是那么简单了 需要注意的事项 首先要写正确。通常使用递归实现。其递归相当于二叉树展开，因此如果要用迭代实现的话需要使用一个队列来保存后续遍历信息。 快速排序需要找到一个pivot值，如果顺序选择pivot则易造成N&#94;2的复杂度，如果使用随机数则效果最好，但开销又太大，采取三数中值法比较合适。三数中值法指的是选取第一个值，最后一个值，数组中间的值的中值。有文献表明可以提升5%的运行时间。 当数组长度较小时，如10个元素以下，最好使用插入排序或者选择排序完成，以防止复杂度常数因子过大或多次函数调用带来的开销。而递归到底层数组长度总是会变小的，因此这么做非常有必要。 在合并前后两部分数组时，采用两边夹方法，在前后两部分各找到一个大于和小于的值再交换。相比通常情况下找到比pivot小的值就进行交换，能提高运行效率。 实现代码 代码如下。包括插入排序insert_sort，递归函数，三分中值函数三个辅助函数。 三分中值函数其实采用的是插入排序。通过三次比较，确定中值。 插值算法使用临时变量tmp避免了大量swap函数调用。 #include < iostream > #include < iomanip > #include < vector > #include < cstdlib > #include < ctime > #include < algorithm > using namespace std ; inline void swap ( vector < int >& num , int p , int q ) { int t = num [ p ] ; num [ p ] = num [ q ] ; num [ q ] = t ; } void insert_sort ( vector < int >& num ) { int tmp , j ; for ( int i = 1 ; i < num . size (); i ++ ) { tmp = num [ i ] ; for ( j = i - 1 ; j >= 0 && num [ j ] > tmp ; j --) num [ j + 1 ] = num [ j ] ; num [ j + 1 ] = tmp ; } } int quick_sort_sub ( vector < int >& num , int p , int q ) { if ( p >= q ) return 0 ; // if 4 elements or less , use insert sort if ( p + 10 > q ) { vector < int > tnum ( num . begin () + p , num . begin () + q + 1 ); insert_sort ( tnum ); for ( int i = 0 ; i < tnum . size (); i ++ ) num [ p + i ] = tnum [ i ] ; } int idx = quick_three_partition ( num , p , q ); swap ( num , idx , q ); int pivot = num [ q ] ; int left = p , right = q - 1 ; while ( 1 ) { while ( num [ left ] < pivot ) ++ left ; while ( num [ right ] >= pivot ) --right; if ( left < right ) swap ( num , left , right ); else break ; } swap ( num , left , q ); quick_sort_sub ( num , p , left - 1 ); quick_sort_sub ( num , left + 1 , q ); return left ; } void quick_sort ( vector < int >& num ) { quick_sort_sub ( num , 0 , num . size () - 1 ); } int main () { const int n = 10 ; /*int num_array[n]= {2,1}; vector<int> num(num_array, num_array + n);*/ srand ( time ( NULL ) ); vector < int > num ( n ); for ( auto & e : num ) e = rand () % n ; quick_sort ( num ); for ( auto & e : num ) cout << setw ( 4 ) << e << ' ' ; cout << endl ; cout << \"vector is sorted? : \" << is_sorted ( num . begin (), num . end ()) << endl ; return 0 ; } 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140727ru-he-xie-chu-yi-ge-jiao-hao-de-kuai-su-pai-xu-cheng-xu.html","loc":"pages/2014/08/20140727ru-he-xie-chu-yi-ge-jiao-hao-de-kuai-su-pai-xu-cheng-xu.html"},{"title":"20140820火车运煤问题","text":"火车运煤问题 刚面试问到这个题，可惜一直没有为此类问题准备，差点就回答出来了 题目内容 你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大——每一公里需要耗一吨煤。请问，作为一个懂编程的煤老板的你，你会怎么运送才能运最多的煤到集市？ 分析 很显然每次走全程的话是无法到达终点的，更别说剩余部分煤。必然把煤全部运到中间某点，然后再继续运 假设第一次把煤全部运输到中间某点A，距离为x，那么消耗的煤的数量为5x，因为要往返两次，再单程一次把剩下的1000吨运往A点。 如果A点剩余煤量3000-5x大于2000，那么下一次假设从A运输到B，距离为y，消耗的煤的数量同样是5y。 如果A点剩余煤量小于2000，那么从A到B只需往返一次，再单程一次，消耗煤的数量为3y。 由此可见，从一点到另外一点距离为s，中途不折返，如果初始煤量在3000~2000之间，需要消耗5s吨煤 同理得到，s距离不折返初始煤量在2000~1000之间，需要消耗3s吨煤 s距离不折返初始煤量在1000~0之间，需要消耗s吨煤 那么最终的策略为每次选择单位消耗最小的方式运输，第一次消耗5x，第二次消耗3y，第三次消耗z。满足第一次消耗之后剩余2000吨，第二次消耗之后剩余1000吨 结果 x=200。转为单位消耗3的方式运输，y=333。转为单位消耗1的方式运输，z=（1000-x-y）= 467。剩余533吨煤 如果换一种思路，要求n 1000吨煤最多可以运输多远，那么有n=1时为1000 1，n=2时为1000 （1+1/3）。继续下去得到传输距离为1000 (1+1/3+1/5+...+1/(2*n-1))。级数不收敛，表明只要煤足够多，能用运输到足够远 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140820huo-che-yun-mei-wen-ti.html","loc":"pages/2014/08/20140820huo-che-yun-mei-wen-ti.html"},{"title":"20140811thttpd源码解析 定时器模块","text":"thttpd源码解析 定时器模块 thttpd是非常轻量级的http服务器，可执行文件仅50kB。名称中的第一个 t 表示tiny, turbo, 或throttling 与lighttpd、memcached、redis相比非常小巧，仅有不到8k行，而后三者大小分别为：60k,13k,86k 支持HTTP/1.1和CGI；采用IO复用实现，单线程，可移植；实现了基于URL的文件流量限制功能 特别适用于大量静态数据访问的场景，如图片存储 2004年已经停止维护，有一个关于X-Forwarded-For HTTP header的bug。后来出现stthhpd基于此项目 性能比较参考 对比 本文针对timer模块进行分析 timer模块 包括timer.h,timer.c两个文件 使用全局开放式散列表，默认大小67，每个hash节点上的值按照时间顺序排列 ClientData定义如下： typedef union { void* p; int i; long l; } ClientData; TimerProc类型声明如下： void TimerProc( ClientData client_data, struct timeval* nowP ) 。函数将在定时器超时时调用 Timer结构定义如下： typedef struct TimerStruct { TimerProc* timer_proc; ClientData client_data; long msecs; int periodic; struct timeval time; struct TimerStruct* prev; struct TimerStruct* next; int hash; } Timer; void tmr_init( void ) 初始化定时器包，即定时器hash表 Timer* tmr_create( struct timeval* nowP, TimerProc* timer_proc, ClientData client_data, long msecs, int periodic ) 创建一个定时器，指定是一次性/周期性，加入散列表 定时器的时间设置为nowP的时刻加上msecs毫秒之后，若nowP为0，设置为当前时刻加上msecs毫秒 timeval* tmr_timeout( struct timeval* nowP ) 返回到下次触发的时间间隔 调用tmr_mstimeout得到 tmr_mstimeout( struct timeval* nowP ) 返回到下次触发时间间隔的毫秒数，即从nowP开始，经过多少毫秒hash表中会有一个定时器触发 因为hash表中的每个链表都是有序的，遍历一次hash表即可 void tmr_run( struct timeval* nowP ) 遍历hash表，如果定时器没有超时，调用timer_proc 如果定时器是周期性的，则调用后时间后延msecs，如果是非周期性的，则调用tmr_cancel去除 void tmr_reset( struct timeval* nowP, Timer* timer ) 重新开始运行定时器，时钟设置为当前时间nowP加上定时时长 void tmr_cancel( Timer* timer ) 释放定时器，由于tmr_run中对所有非周期性定时器都已经调用tmr_cancel，用户无需再自己对非周期定时器调用 将timers加入free_timers链表，节省free和malloc的开销，相当于一个缓冲池 void tmr_cleanup( void ) 清空定时器包，释放所有无用的内存：free_timers链表 void tmr_destroy( void ) 调用tmr_cancel释放所有定时器，为退出做准备， void tmr_logstats( long secs ) 生成调试log信息，记录当前已分配、使用中、free的定时器个数 操作hash表的静态函数 hash：由 (time.tv_sec &#94; time.tv_usec) % 67 得到hash值 l_add:插入一个定时器 l_remove:移除一个定时器 re_sort:定时器结构体含有之前的hash值，如果定时器的值改变，移除后重新计算hash，插入到正确的位置 timer模块的使用 在main函数中使用类timer模块 调用tmr_init初始化 创建周期为OCCASIONAL_TIME的周期定时器，回调函数为occasional 创建周期为5s的周期定时器，回调函数为idle 创建周期为THROTTLE_TIME的周期定时器，回调update_throttles 创建周期为STATS_TIME的周期定时器，回调show_stats 在主要事件处理循环中： 如果没有socket发生事件，调用一次tmr_run，continue 如果有新连接，continue，以保证新连接优先得到处理 如果有事件发生，则处理事件 运行一次tmr_run occasional 调用mmc_cleanup 调用tmr_cleanup，清除无用的定时器内存池 设置watchdog_flag = 1，使watchdog知道程序仍在运行 idle update_throttles 更新流量控制 show_stats 调用函数logstats，记录信息 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140811thttpdyuan-ma-jie-xi-ding-shi-qi-mo-kuai.html","loc":"pages/2014/08/20140811thttpdyuan-ma-jie-xi-ding-shi-qi-mo-kuai.html"},{"title":"《算法之道》精华","text":"《算法之道》精华 本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书 这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考 本文仅包括算法设计部分，算法分析略去，并没有严格按照章节顺序来记录 附录 算法随想 有人喜欢遍历，希望踏遍千山万水，人生丰富多彩；有人一生贪婪，眼界不宽，及时行乐；有人注定穷搜，辛辛苦苦，收获有限；有人善用时空均衡，用最少的时间办最多的事情，十分精明；有人会分治，再难的问题也能解决；有人动态规划，积少成多 第三章 分治与递归 生活中的例子：天平秤球以辨明次品；乘法运算；世界杯晋级赛；秦国合纵连横 分治策略步骤：1，将问题分为若干小问题；2，递归解决这些子问题；3，合并子问题的解答，得到大问题的解 标准分治策略的定义里面包含递归： T(n) = aT(n/b) + f(n) 递归式复杂度大师解法： T(n) = aT(n/b) + f(n) = a&#94;2T(n/b&#94;2) + af(n/b) + f(n) = a&#94;(log_b(n)) T(1) + a&#94;(log_b(n-1) f(n/b&#94;(log_b(n-1))) +...+a&#94;2f(n/b&#94;2) + af(n/b) + f(n) = O(n&#94;log_b(a)) + sum(a&#94;j f(n/b&#94;j))|(j = 0...log_b(n-1)) 前项为递归树最后一层节点数，后项为递归树各层分治过程分解与合并的代价 f(n) < n&#94;log_b(a)时，T(n) = O(n&#94;log_b(a)) f(n) > n&#94;log_b(a) : T(n) = O(f(n)) 算法题中常见分治例子：乘方运算、矩阵乘法、斐波那契数列的矩阵乘方解法、VLSI布线 第四章 动态规划 动态规划是一种更有针对性的分治，分解得到的小问题很多重复，保存已经计算得到的结果可以免去重复计算 动态规划每一步做出一个最优选择，该最优选择与子问题的最优解组合得到大问题的最优解 具体步骤： 证明问题的解决方案中包括一个选择，选择后剩下一个或多个子问题 设计递归描述方式，得到递归方程 证明对大问题的最优解包括对所有子问题的最优解 证明子问题之间重叠 两个原则：最优子结构，重叠子问题 动态规划的时间复杂度：全部子问题数量x选择成本 算法题中常见动态规划例子：最长公共子序列（最长递增、最长递减子序列，编辑距离）、最优二叉搜索树 第五章 贪婪选择思想 动态规划在做出选择之前，将所有选择的结果做了比较，而如果选择的时候不经过比较，而是直接选择局部最优，就是贪婪 贪婪的目的只是找出一种可行解，在一定情况下找出的是最优解 贪婪与动态规划相同，都是一种分治策略。但与动态规划不同，贪婪将大问题分解为一个，而不是多个子问题 具体步骤： 将原问题表述为一个做出一个选择，然后剩下唯一一个子问题的形式 证明所有的最优选择里面总有一个是贪婪选择 证明贪婪选择加上对剩下子问题的最优解导致大问题的最优解 贪婪的两个原则：最优子结构（大问题的最优解包括小问题的最优解），贪婪选择属性 贪婪选择属性：每个小问题可以贪婪选择获得 算法题中常见贪婪例子： 背包问题：财宝是否可以分割、每件财宝是否可以重复拿四个版本 教室课程规划 最小生成树 Kruskal算法，每次加入一个不形成环的最小的边，复杂度为O(E log(V)) Prime算法：每次加入距离最近的点，并降距，复杂度为O(V&#94;2)，采用堆实现，可以达到O(E log(V)) 霍夫曼编码 第六章 随机化思想 蒙特卡洛算法：大概率输出正确答案，复杂度固定 常见随机化算法例子： 素性测试：根据费马小定理，若p为素数，则 (a&#94;p - a) % p == 0 ；如果测试一百次都成立，则为合数的概率只有2&#94;(-100) 矩阵乘积结果验证：取随机二进制01矢量z，有zAB = z(AB) 线性时间最小生成树算法 第十章 排序与次序 插入排序 从无序部分抽取一张插入有序部分 为原地排序，无需占用临时存储空间 最优情况下为O(n)，平均O(n&#94;2) 折半插入排序 插入时使用二分查找 归并排序 分治，从中间分解，分别排序后进行仔细的合并 异地排序，需要占用额外空间 n>=30时性能比插入排序更好。复杂度固定为O(nlog(n)) 快排 分治，复杂的部分在于分解，而归并复杂在于合并 原地排序 最坏情况为O(n&#94;2)，但只要不是每次都是最坏，复杂度就不是n&#94;2，具有韧性 任何基于比较的排序，决策树高度至少为nlog(n) 计数排序 元素值范围必须有限 空间复杂度高 O(n) 基数排序 从最低位到最高位排序，每一位排序都采用稳定排序，如计数排序 一位排序应该选择log(n)个比特，使整体成本最低 桶排序 把n元素按值分到n个桶里，每个桶内部进行插入排序，将各桶首位相连 元素应该是均匀分布 快速次序选择：求第K大的数 使用快排的partition 最差O(n&#94;2)，平均O(n) 线性最差快速次序选择 将元素每5个一组，分别取中值。在n/5个中值里面找到中值，作为partition的pivot 为什么 *不每3个一组？ 保证pivot左边右边至少3n/10个元素 最差O(n) 第十一章 搜索与散列 顺序搜索 在序列里面如果搜索频率从头到尾指数递减，则为O(1) 折半搜索 对于有序序列，为O(logn) 常数搜索：散列搜索 直接散列：非常简单，不会发生碰撞，空间浪费大 除法（模除法）散列 元素对散列表大小m取模得到 m必须为素数，否则造成不均匀散射。比如m包含因子d，而大部分元素对d余数相等 m不能靠近2的幂。如m为2的幂，散列结果将不依赖元素的所有位。靠近也不行， 为什么 ？ 乘法散列 h(k) = (A * k ) % 2&#94;r >> (w - r)，w为计算机字宽，A为2&#94;(w-1)与2&#94;w之间的一个奇数 乘方取中法：乘方n次（常取n=2），取中间r位 开放寻址散列：散列碰撞时纵深扩展，添加一个链表 平均搜索时间为O(1+a)，a为加载因子 封闭寻址散列：散列碰撞时为元素找到另一个位置 找另一个位置的操作称为探寻 线性探寻 h(k,i) = (h'(k) + i) % m ，h'(k)为家位 向单方向寻找未被占用的位置 易出现顶级聚集 非线性探寻 平方探寻 h(k,i) = (h'(k) + c1 * i + c2 * i&#94;2) % m 易出现次级聚集 双重散列探寻 使用两个散列函数h1、h2来构造新散列函数 h(k,i) = (h1(k) + i * h2(k) ) mod m 伪随机探寻 使用伪随机序列 存在次级聚集 不成功搜索的探寻次数期望为 1/(1-a) 成功搜索探寻次数最多为 1 / a * ln( 1/(1-a)) 封闭散列不能删除元素，可以放标记解决。如果插入相比搜索非常稀疏，则可以通过重新散列解决空位问题 随机化散列 找到一组散列函数，每次随机选择一个不同的散列函数 用于避免单个散列函数极端情况下聚集效应严重 全域散列 一组H个散列函数，将任意两个不同的元素映射到同一位置的函数个数为H/m 完美散列 n个元素，构造m=O(n)大小的散列表，使搜索最坏达到O(1) 采用双层散列，第一层大小n，第二层每个表的大小为落到第一层位置i上的元素个数的平方 空间消耗为O(n) 第十二章 最短路径 如果图中有负环，则不存在最短路径 单源多点最短路径 Dijkstra算法 贪婪算法，要求不存在负路径 最优子结构：最短路径里的每一段都是两点之间的最短路径 贪婪选择属性：路径向外延伸的下一个节点就是离源点最近的节点 每次选取离源点最近的节点，更新所有与此节点相邻节点的距离 时间复杂度为O(V&#94;2)，采用堆实现，可以达到O(E log(V))。与Prim算法相同 Bellman-Ford算法 可以应对负权重 进行V-1轮降距，每次更新图中所有边 复杂度为O(VE) BFS 各边权重相等的情况 O(V+E) 多源多点最短路径 Floyd-Warshall算法 动态规划算法 子问题为从i到j，中间结点只属于集合1...k的最短路径长度 c_ijk = min{c_ij(k-1), c_ik(k-1) + ckj(k-1)}|k 复杂度O(n&#94;3) Jonhson算法 等效变换为无负权重的图，使用Dijkstra算法 添加一个节点s，到所有点路径长度为0，运行Bellman-Ford算法，对节点赋值 对每个节点运行Dijkstra算法 复杂度主要是Dijkstra算法运算，为O(VE + V&#94;2 log(V)) 若Bellman-Ford算法报告有负环存在，不能使用此方法 第十三章 易解与难解 易解指的是多项式问题，难解指的是指数级问题 决策问题 需要输出答案是/否 若回答为是，通常需要一个证人来证明。对一个潜在证人，证明之后即为真证人 优化问题和决策问题之间可以相互转化 P类问题 确定性多项式时间可解 对于一个决策问题，输入的大小为n，能在n的多项式时间内解决，正确输出是/否 NP类问题 非确定性多项式时间可解 对于一个决策问题，大小为n的潜在证人，能在n的多项式时间内解决，正确输出此证人是否为真 P类问题指的是能否多项式时间给出答案，NP类问题指的是能否在多项式时间内判断一个潜在答案是否正确 （确定性）图灵机 图灵机为一个状态机，根据当前状态、下一个输入字符确定输出、磁头移动方向、下一个状态 任一个问题、算法都能表述为一个字符串，因此图灵机可以解决很多问题 非确定性图灵机 与确定性图灵机相比，给定状态与输入可以有多种选择 能够同时进入所有状态路径，且能做出最好的选择以达到接受状态 非确定性算法：在非确定性图灵机上运行的算法 NP问题的另一个定义：使用非确定性算法，在多项式时间内解决 P与NP的关系 所有P类问题都是NP的 所有NP不一定是P，直觉如此，但无法证明 部分NP为P，目前已经找到多项式解法，目前没有找到多项式解法的NP问题称为 NP-hard 第十四章 NP完全问题 如果NP里每一个问题都可以多项式时间规约到S，则S称为NP难（严谨的定义）。S不比NP里面任一问题容易 如果问题S既是NP难，又是NP里的问题，则称为NP完全问题 NP完全的属性 非确定性算法多项式时间可解 完全：解决一个就解决了所有NP完全问题 若找到一个NP完全问题的确定性解法，就证明了NP=P 若找到一个NP难优化问题的多项式时间解，就证明了NP=P NP完全的意义：若能证明一个问题为NP完全问题，则无需再寻找精确解，找到启发性的近似解即可 常见NP完全问题 3-SAT 整数分割 顶点覆盖 汉密尔顿回路 可规约至旅行商问题 完全子图 图的着色 旅行商 整数规划属于NP难问题，但不是NP问题，因此不是NP完全问题 第十五章 无解与近似 NP完全只是NP里最难的问题，目前没有找到多项式解法 难解问题不存在多项式解法 不可决定问题：是无解的，即使是指数级也无济于事。但又潜在证人 对于NP完全和难解问题，可以尝试找出次优解 智能穷举 能找的最优解 两种剪枝策略：回溯法、分支限界 如八皇后问题 近似算法 能找到近似的解 如聚类问题、启发式搜索、模拟退火、遗传算法 本地搜索 一种贪婪策略 不断向更优的可行解移动，可能仅能找到局部最优解","tags":"misc","url":"pages/2014/08/suan-fa-zhi-dao-jing-hua.html","loc":"pages/2014/08/suan-fa-zhi-dao-jing-hua.html"},{"title":"20140809《算法之道》精华 难解问题部分","text":"《算法之道》精华 难解问题部分 本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书 这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考 本文包括难解问题部分 第十三章 易解与难解 易解指的是多项式问题，难解指的是指数级问题 决策问题 需要输出答案是/否 若回答为是，通常需要一个证人来证明。对一个潜在证人，证明之后即为真证人 优化问题和决策问题之间可以相互转化 P类问题 确定性多项式时间可解 对于一个决策问题，输入的大小为n，能在n的多项式时间内解决，正确输出是/否 NP类问题 非确定性多项式时间可解 对于一个决策问题，大小为n的潜在证人，能在n的多项式时间内解决，正确输出此证人是否为真 P类问题指的是能否多项式时间给出答案，NP类问题指的是能否在多项式时间内判断一个潜在答案是否正确 （确定性）图灵机 图灵机为一个状态机，根据当前状态、下一个输入字符确定输出、磁头移动方向、下一个状态 任一个问题、算法都能表述为一个字符串，因此图灵机可以解决很多问题 非确定性图灵机 与确定性图灵机相比，给定状态与输入可以有多种选择 能够同时进入所有状态路径，且能做出最好的选择以达到接受状态 非确定性算法：在非确定性图灵机上运行的算法 NP问题的另一个定义：使用非确定性算法，在多项式时间内解决 P与NP的关系 所有P类问题都是NP的 所有NP不一定是P，直觉如此，但无法证明 部分NP为P，目前已经找到多项式解法，目前没有找到多项式解法的NP问题称为 NP-hard 第十四章 NP完全问题 如果NP里每一个问题都可以多项式时间规约到S，则S称为NP难（严谨的定义）。S不比NP里面任一问题容易 如果问题S既是NP难，又是NP里的问题，则称为NP完全问题 NP完全的属性 非确定性算法多项式时间可解 完全：解决一个就解决了所有NP完全问题 若找到一个NP完全问题的确定性解法，就证明了NP=P 若找到一个NP难优化问题的多项式时间解，就证明了NP=P NP完全的意义：若能证明一个问题为NP完全问题，则无需再寻找精确解，找到启发性的近似解即可 常见NP完全问题 3-SAT 整数分割 顶点覆盖 汉密尔顿回路 可规约至旅行商问题 完全子图 图的着色 旅行商 整数规划属于NP难问题，但不是NP问题，因此不是NP完全问题 第十五章 无解与近似 NP完全只是NP里最难的问题，目前没有找到多项式解法 难解问题不存在多项式解法 不可决定问题：是无解的，即使是指数级也无济于事。但又潜在证人 对于NP完全和难解问题，可以尝试找出次优解 智能穷举 能找的最优解 两种剪枝策略：回溯法、分支限界 如八皇后问题 近似算法 能找到近似的解 如聚类问题、启发式搜索、模拟退火、遗传算法 本地搜索 一种贪婪策略 不断向更优的可行解移动，可能仅能找到局部最优解 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-nan-jie-wen-ti-bu-fen.html","loc":"pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-nan-jie-wen-ti-bu-fen.html"},{"title":"20140809《算法之道》精华  经典算法部分","text":"《算法之道》精华 经典算法部分 本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书 这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考 本文包括经典算法部分 第十章 排序与次序 插入排序 从无序部分抽取一张插入有序部分 为原地排序，无需占用临时存储空间 最优情况下为O(n)，平均O(n&#94;2) 折半插入排序 插入时使用二分查找 归并排序 分治，从中间分解，分别排序后进行仔细的合并 异地排序，需要占用额外空间 n>=30时性能比插入排序更好。复杂度固定为O(nlog(n)) 快排 分治，复杂的部分在于分解，而归并复杂在于合并 原地排序 最坏情况为O(n&#94;2)，但只要不是每次都是最坏，复杂度就不是n&#94;2，具有韧性 任何基于比较的排序，决策树高度至少为nlog(n) 计数排序 元素值范围必须有限 空间复杂度高 O(n) 基数排序 从最低位到最高位排序，每一位排序都采用稳定排序，如计数排序 一位排序应该选择log(n)个比特，使整体成本最低 桶排序 把n元素按值分到n个桶里，每个桶内部进行插入排序，将各桶首位相连 元素应该是均匀分布 快速次序选择：求第K大的数 使用快排的partition 最差O(n&#94;2)，平均O(n) 线性最差快速次序选择 将元素每5个一组，分别取中值。在n/5个中值里面找到中值，作为partition的pivot 为什么 *不每3个一组？ 保证pivot左边右边至少3n/10个元素 最差O(n) 第十一章 搜索与散列 顺序搜索 在序列里面如果搜索频率从头到尾指数递减，则为O(1) 折半搜索 对于有序序列，为O(logn) 常数搜索：散列搜索 直接散列：非常简单，不会发生碰撞，空间浪费大 除法（模除法）散列 元素对散列表大小m取模得到 m必须为素数，否则造成不均匀散射。比如m包含因子d，而大部分元素对d余数相等 m不能靠近2的幂。如m为2的幂，散列结果将不依赖元素的所有位。靠近也不行， 为什么 ？ 乘法散列 h(k) = (A * k ) % 2&#94;r >> (w - r)，w为计算机字宽，A为2&#94;(w-1)与2&#94;w之间的一个奇数 乘方取中法：乘方n次（常取n=2），取中间r位 开放寻址散列：散列碰撞时纵深扩展，添加一个链表 平均搜索时间为O(1+a)，a为加载因子 封闭寻址散列：散列碰撞时为元素找到另一个位置 找另一个位置的操作称为探寻 线性探寻 h(k,i) = (h'(k) + i) % m ，h'(k)为家位 向单方向寻找未被占用的位置 易出现顶级聚集 非线性探寻 平方探寻 h(k,i) = (h'(k) + c1 * i + c2 * i&#94;2) % m 易出现次级聚集 双重散列探寻 使用两个散列函数h1、h2来构造新散列函数 h(k,i) = (h1(k) + i * h2(k) ) mod m 伪随机探寻 使用伪随机序列 存在次级聚集 不成功搜索的探寻次数期望为 1/(1-a) 成功搜索探寻次数最多为 1 / a * ln( 1/(1-a)) 封闭散列不能删除元素，可以放标记解决。如果插入相比搜索非常稀疏，则可以通过重新散列解决空位问题 随机化散列 找到一组散列函数，每次随机选择一个不同的散列函数 用于避免单个散列函数极端情况下聚集效应严重 全域散列 一组H个散列函数，将任意两个不同的元素映射到同一位置的函数个数为H/m 完美散列 n个元素，构造m=O(n)大小的散列表，使搜索最坏达到O(1) 采用双层散列，第一层大小n，第二层每个表的大小为落到第一层位置i上的元素个数的平方 空间消耗为O(n) 第十二章 最短路径 如果图中有负环，则不存在最短路径 单源多点最短路径 Dijkstra算法 贪婪算法，要求不存在负路径 最优子结构：最短路径里的每一段都是两点之间的最短路径 贪婪选择属性：路径向外延伸的下一个节点就是离源点最近的节点 每次选取离源点最近的节点，更新所有与此节点相邻节点的距离 时间复杂度为O(V&#94;2)，采用堆实现，可以达到O(E log(V))。与Prim算法相同 Bellman-Ford算法 可以应对负权重 进行V-1轮降距，每次更新图中所有边 复杂度为O(VE) BFS 各边权重相等的情况 O(V+E) 多源多点最短路径 Floyd-Warshall算法 动态规划算法 子问题为从i到j，中间结点只属于集合1...k的最短路径长度 c_ijk = min{c_ij(k-1), c_ik(k-1) + ckj(k-1)}|k 复杂度O(n&#94;3) Jonhson算法 等效变换为无负权重的图，使用Dijkstra算法 添加一个节点s，到所有点路径长度为0，运行Bellman-Ford算法，对节点赋值 对每个节点运行Dijkstra算法 复杂度主要是Dijkstra算法运算，为O(VE + V&#94;2 log(V)) 若Bellman-Ford算法报告有负环存在，不能使用此方法 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-jing-dian-suan-fa-bu-fen.html","loc":"pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-jing-dian-suan-fa-bu-fen.html"},{"title":"20140809《算法之道》精华 算法设计部分","text":"《算法之道》精华 算法设计部分 本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书 这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考 本文仅包括算法设计部分，算法分析略去，并没有严格按照章节顺序来记录 附录 算法随想 有人喜欢遍历，希望踏遍千山万水，人生丰富多彩；有人一生贪婪，眼界不宽，及时行乐；有人注定穷搜，辛辛苦苦，收获有限；有人善用时空均衡，用最少的时间办最多的事情，十分精明；有人会分治，再难的问题也能解决；有人动态规划，积少成多 第三章 分治与递归 生活中的例子：天平秤球以辨明次品；乘法运算；世界杯晋级赛；秦国合纵连横 分治策略步骤：1，将问题分为若干小问题；2，递归解决这些子问题；3，合并子问题的解答，得到大问题的解 标准分治策略的定义里面包含递归： T(n) = aT(n/b) + f(n) 递归式复杂度大师解法： T(n) = aT(n/b) + f(n) = a&#94;2T(n/b&#94;2) + af(n/b) + f(n) = a&#94;(log_b(n)) T(1) + a&#94;(log_b(n-1) f(n/b&#94;(log_b(n-1))) +...+a&#94;2f(n/b&#94;2) + af(n/b) + f(n) = O(n&#94;log_b(a)) + sum(a&#94;j f(n/b&#94;j))|(j = 0...log_b(n-1)) 前项为递归树最后一层节点数，后项为递归树各层分治过程分解与合并的代价 f(n) < n&#94;log_b(a)时，T(n) = O(n&#94;log_b(a)) f(n) > n&#94;log_b(a) : T(n) = O(f(n)) 算法题中常见分治例子：乘方运算、矩阵乘法、斐波那契数列的矩阵乘方解法、VLSI布线 第四章 动态规划 动态规划是一种更有针对性的分治，分解得到的小问题很多重复，保存已经计算得到的结果可以免去重复计算 动态规划每一步做出一个最优选择，该最优选择与子问题的最优解组合得到大问题的最优解 具体步骤： 证明问题的解决方案中包括一个选择，选择后剩下一个或多个子问题 设计递归描述方式，得到递归方程 证明对大问题的最优解包括对所有子问题的最优解 证明子问题之间重叠 两个原则：最优子结构，重叠子问题 动态规划的时间复杂度：全部子问题数量x选择成本 算法题中常见动态规划例子：最长公共子序列（最长递增、最长递减子序列，编辑距离）、最优二叉搜索树 第五章 贪婪选择思想 动态规划在做出选择之前，将所有选择的结果做了比较，而如果选择的时候不经过比较，而是直接选择局部最优，就是贪婪 贪婪的目的只是找出一种可行解，在一定情况下找出的是最优解 贪婪与动态规划相同，都是一种分治策略。但与动态规划不同，贪婪将大问题分解为一个，而不是多个子问题 具体步骤： 将原问题表述为一个做出一个选择，然后剩下唯一一个子问题的形式 证明所有的最优选择里面总有一个是贪婪选择 证明贪婪选择加上对剩下子问题的最优解导致大问题的最优解 贪婪的两个原则：最优子结构（大问题的最优解包括小问题的最优解），贪婪选择属性 贪婪选择属性：每个小问题可以贪婪选择获得 算法题中常见贪婪例子： 背包问题：财宝是否可以分割、每件财宝是否可以重复拿四个版本 教室课程规划 最小生成树 Kruskal算法，每次加入一个不形成环的最小的边，复杂度为O(E log(V)) Prime算法：每次加入距离最近的点，并降距，复杂度为O(V&#94;2)，采用堆实现，可以达到O(E log(V)) 霍夫曼编码 第六章 随机化思想 蒙特卡洛算法：大概率输出正确答案，复杂度固定 常见随机化算法例子： 素性测试：根据费马小定理，若p为素数，则 (a&#94;p - a) % p == 0 ；如果测试一百次都成立，则为合数的概率只有2&#94;(-100) 矩阵乘积结果验证：取随机二进制01矢量z，有zAB = z(AB) 线性时间最小生成树算法 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-suan-fa-she-ji-bu-fen.html","loc":"pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-suan-fa-she-ji-bu-fen.html"},{"title":"20140807《程序员面试宝典》精华  底层部分","text":"《程序员面试宝典》精华 底层部分 正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。书里是没有糟粕的，只是指不那么重要，或者比较简单的地方略过而已，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。 本文专注位运算、操作系统、数据库、网络部分，包括第十二章以后的内容 第十二章 位运算与嵌入式编程 12.1 printf的%f说明符可以输出float和double型，float型会被提升为double型。 printf(\"%f\",5);printf(\"%d\",5.01) ，前者会从存放5的位置取double型的8个字节，内存越界，并按bit解释，后者会按照整数来解释5.01的比特，输出为0，一个大整数。 真的是越界 ？ 12.1 struct a{int z:33;}; 报错，因为z为int型，不可能有33位 12.1 dynamic_cast,static_cast,reinterpret_cast的区别，没有讲清楚 12.2 ISR终端服务程序不应该有参数和返回值，且不能使用不可重入的函数 12.2 volatile的意思是易变的，指的是它可能在程序控制的范围之外意外发生变化，防止编译器的优化。volatile变量可以声明为const，表示是只读的 12.2 const的意思是只读的 12.2 malloc(0) 能得到一个合法的指针，而不是空指针，对其调用strlen和sizeof结果为0和4 12.2 对于结构体 struct bit{int b1:5;int :2;int b2:2;}; 赋值后，取b1,b2的值，该如何解析？ 12.3 static的作用包括哪些？ 函数内的static变量中下次调用时保持值不变 源代码文件（模块）内的static全局变量和函数的作用范围限制在模块内 类的static成员变量对所有对象共享，static成员函数只能访问static成员变量 第十六章 操作系统 16.1 进程间如何通信：信号，信号量，消息队列，共享内存 16.1 死锁的必要条件：互斥，请求与保持，不可剥夺，循环等待。后三种条件可以破坏 16.2 进程与线程的区别： 进程是程序的一次执行，线程为进程中执行的一段程序 进程直接是独立的，而同一进程的线程共享内存空间 第十七章 数据库 17.1 事务：作为单个逻辑工作单元执行的一系列操作，不可分割。具有原子性、一致性、独立性、持久性 17.1 聚集索引与非聚集索引的区别： 聚集索引的顺序就是数据的物理存储顺序，而非聚集索引顺序与物理存储顺序无关 每个表只能有一个聚集索引，聚集索引对于范围查询的列非常有效 17.2 表ppp里面num最小的数 不使用min： select top 1 num from ppp order by num 使用min： select * from ppp where num = (select Min(num) from ppp) 17.2 从表中取出第5行到第七行的数据的语句 第十八章 计算机网络 18.1 OSI七层模型及其作用： 物理层 传输原始比特流 数据链路层 网络层 路由选择 传输层 会话层 表示层 应用层 18.2 TCP与UDP的区别 TCP是传输控制协议，提供面向连接、可靠的字节流服务。提供超时重发、数据检验、流量控制等功能 UDP是用户数据报协议，是面向数据报的传输层协议，不提供可靠性。但由于无需建立连接、超时重发，传输速度快 18.3 socket编程流程 服务器端：socket bind accept sned recv close 客户端： socket connect send recv close 18.3 常用端口号：0到1023范围内，21为FTP，25为SMTP，80为HTTP，23为telnet 18.4 TCP的三次握手与四次挥手 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-di-ceng-bu-fen.html","loc":"pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-di-ceng-bu-fen.html"},{"title":"20140807《程序员面试宝典》精华  面向对象部分","text":"《程序员面试宝典》精华 面向对象部分 正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。书里是没有糟粕的，只是指不那么重要，或者比较简单的地方略过而已，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。 文中有少许bug，亦摘录在此。 本文专注面向对象部分，包括第十章到第十一章的内容 第十章 面向对象 10.2 类与结构体的区别：都能继承、拥有析构等成员函数，唯一的区别是struct成员默认为public，而class默认为private。C++是为了兼容C代码才保留struct关键字 10.3 class B{...}; B b(); b.f(); 是错误的，b声明为了一个函数 10.3 静态成员变量必须显式初始化，例如 int A::i 0; 10.3 成员变量初始化顺序与初始化列表顺序无关，与变量声明顺序有关 10.3 常数(cosnt)成员变量必须中构造函数的初始化列表里面初始化，或者声明为 static const 成员 10.4 把成员函数声明为虚函数造成调用开销增大，为什么常常把基类的析构函数声明为虚函数：多态情况下常常把派生类对象的指针赋给基类指针，那么使用虚函数保证delete时能调用派生类对象的析构函数，而不造成内存泄露 10.4 构造函数为什么不能声明为virtual：虚调用是来调用一个只知道接口而不知道其对象类型的成员函数，实例化对象时必须知道对象的准确类型，因此构造函数不能为virtual（存疑，不够clear） 10.4 函数f返回一个对象时，使用 A t = f() ，会调用拷贝构造函数。即函数参数和返回值都是对象时，都会调用一次拷贝构造函数 10.4 含有单个参数的构造函数会定义一个从参数类型到类的隐式类型转换，使用explicit关键字可以避免此转换 10.5 函数参数常声明为const，这是因为const变量不能随意转换为非const，反之则可 10.5 要求类的每个对象有唯一id，需要自定义拷贝构造函数避免重复 10.5 如果类包含动态分配的指针，那么需要定义拷贝构造函数和赋值函数 10.6 什么是多态？ 概念：封装、继承、多态是OO的三大基本概念。多态指的是允许将子类类型赋值给父类指针，而父类指针可以通过统一的接口对所有子类对象进行操作 作用与目的：封装为了隐藏实现细节，以及数据类型和函数的统一，模块化；继承是为了方便扩展已有的代码模块；两者均可实现代码重用，而多态是为了实现接口重用 实现方法：虚函数 10.6 重写与重载，前者override是指子类重新定义父类的虚函数，后者overload是指同时存在多个参数列表不同的同名函数 第十一章 继承与接口 11.1 如果显式调用虚函数，则虚调用机制失效，如 class B::public A{}; B b; b.A::f(); ，类f为虚函数，但此时显式调用A中的f 11.2 三种继承方式的区别 public继承：基类的public和protected成员对基类保持原有状态 基类成员对派生类的可见性：派生类（的成员函数）可以访问基类的public和protected成员 基类成员对派生类对象的可见性：（通过）派生类的对象（指例如 a.f()的方式 ）可以访问基类的public成员 private继承：将基类的public和protected成员当成派生类的private成员，且不能被派生类的子类访问 基类成员对派生类的可见性：派生类（的成员函数）可以访问基类的public和protected成员 基类成员对派生类对象的可见性：（通过）派生类的对象不可以访问基类的任何成员,因此基类的成员无法再向下继承 protected继承：将基类的public和protected成员当成派生类的protected成员，且不能被派生类的子类访问 基类成员对派生类的可见性：派生类（的成员函数）可以访问基类的public和protected成员 基类成员对派生类对象的可见性：（通过）派生类的对象不可以访问基类的任何成员,因此基类的成员无法再向下继承 关键差别在于通过派生类对象可以访问基类的哪些成员，以及派生类的子类能否访问派生类的成员 11.2 三种成员属性的区别：基类的private成员对派生类屏蔽，protected成员使派生类可以访问，基类仅有public成员可以通过基类的对象访问 11.2 虚继承是为了解决多重继承中的菱形继承冲突，派生类中会添加一个指向基类虚函数表的指针 例如，C、B虚继承自A，D继承自B、C，则D中共有1个A 11.4 Java中使用接口替代多重继承，C++可以使用抽象类模拟接口 11.4 C继承自A，B，pC指向C对象，pB把pC转换为指向B的指针，则 pC == pB ，这里发生从C的指针到B的指针的隐式转换，书中说反了，bug 11.5 类的继承默认为private，通常需要加public关键字 11.6 如何防止一个类实例化：使用带有纯虚函数的抽象类，或者把构造函数声明为private 11.7 RTTI的缺点：除了运行开销外，使程序变得不确定，缺乏扩展性 11.7 类型转换运算符重载，无返回值无参数，以目标类型为函数名，如： operator char*() 11.8 dynamic_cast如果转换失败返回0 11.8 typeid返回值为对type_info常量对象的引用 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-mian-xiang-dui-xiang-bu-fen.html","loc":"pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-mian-xiang-dui-xiang-bu-fen.html"},{"title":"《程序员面试宝典》精华","text":"《程序员面试宝典》精华 正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。当然这里的糟粕只是指不那么重要，或者比较简单，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。 文中有少许bug，亦摘录在此。 第五章 语言细节 5.1 y = z = 5 ，等号先计算右边，返回值是赋值后的左边的变量值 5.1 printf函数中的表达式从右向左压栈，应该先计算右方的值 5.4 float型1.0f在内存中表示为：0x3f 80 00 00 5.5 出现int常数的表达式中的变量通常都要提升至int型 5.5 赋值运算符默认从右向左结合，也就是先计算右方的值 5.5 (x&y) + ((x&#94;y)>>1)效果是取二者的平均数 5.6 不用判断和switch语句求a、b中的较大的一个：((a + b) + abs(a - b)) / 2 5.7 extern \"C\" 的用法：函数声明前添加，解决C/C++编译器的名字包装的不同问题 第六章 预处理、const和sizeof 6.1 求结构体中某成员的偏移量： #define FIND(struc, e) (size_t)&(((struc *)0)->e) 6.2 C语言中， const n = 10; char carray[n] 是错误的，因为C编译器不能把const看成编译期的常量。但实验得出是正确的，bug 6.3 C++中给类成员变量添加mutable修饰符，就可以使用const函数修改 6.3 结构体对齐原则：结构体长度一定是最长数据元素整数倍，但如果大于处理器位数，则以处理器位数为对齐单位。CPU数据对齐原则是数据的内存地址必须是该数据长度的整数倍，以提高运行速度 6.3 sizeof(string) == 4 6.3 空类以及（多重）继承的空类大小都为1，但虚继承的类含有虚表指针，大小为4 第七章 指针与引用 7.1 指针与引用的区别 引用总是非空的，指针可能为空，使用时要小心测试 引用不可以指向另一个对象，但指针可以更改 7.1 int *p; *p = 0; 是错误的，指针p并未指向某个实际的地址 7.2 char a[] = \"a\" 数组存放中栈中，函数返回即消失， char *a = \"a\" 数组存放于全局只读数据段 7.2 若类B继承类A，两者皆有成员变量，A中有f方法，则 B b; b.f() 调用的是A中的f，f使用的变量也为A中的变量 7.3 指向const的指针应该是 const int * ，bug 7.3 int ( *(*f)(int, int) )(int) 定义了一个函数指针，接收两个int参数，返回值为一个函数指针 7.4 指向整型数组的指针声明为： int (*p) [] ，指向整型的指针数组声明为： int *p[] ，函数指针的数组的声明： int (*p[10])(int) 7.5 悬浮指针指的是delete之后的指针，应该让指针等于0，使得后续程序使用此悬浮指针出错是可控的。比如第二次delete 7.5 new/delete与malloc/free的区别 前者是运算符，后者是函数 前者除了后者申请与释放动态内存的工作之外，对于非内置类型，还完成类初始化与析构操作 7.6 autoptr中拷贝时会尝试只保留一份指针，因此不适合放在容器中 第九章 STL模板与容器 9.1 如果没有重载拷贝构造函数为深拷贝，而又包含指针，那么调用拷贝构造函数时会复制指针，造成同一个指针 delete多次 第十章 面向对象 10.2 类与结构体的区别：都能继承、拥有析构等成员函数，唯一的区别是struct成员默认为public，而class默认为private。C++是为了兼容C代码才保留struct关键字 10.3 class B{...}; B b(); b.f(); 是错误的，b声明为了一个函数 10.3 静态成员变量必须显式初始化，例如 int A::i 0; 10.3 成员变量初始化顺序与初始化列表顺序无关，与变量声明顺序有关 10.3 常数(cosnt)成员变量必须中构造函数的初始化列表里面初始化，或者声明为 static const 成员 10.4 把成员函数声明为虚函数造成调用开销增大，为什么常常把基类的析构函数声明为虚函数：多态情况下常常把派生类对象的指针赋给基类指针，那么使用虚函数保证delete时能调用派生类对象的析构函数，而不造成内存泄露 10.4 构造函数为什么不能声明为virtual：虚调用是来调用一个只知道接口而不知道其对象类型的成员函数，实例化对象时必须知道对象的准确类型，因此构造函数不能为virtual（存疑，不够clear） 10.4 函数f返回一个对象时，使用 A t = f() ，会调用拷贝构造函数。即函数参数和返回值都是对象时，都会调用一次拷贝构造函数 10.4 含有单个参数的构造函数会定义一个从参数类型到类的隐式类型转换，使用explicit关键字可以避免此转换 10.5 函数参数常声明为const，这是因为const变量不能随意转换为非const，反之则可 10.5 要求类的每个对象有唯一id，需要自定义拷贝构造函数避免重复 10.5 如果类包含动态分配的指针，那么需要定义拷贝构造函数和赋值函数 10.6 什么是多态？ 概念：封装、继承、多态是OO的三大基本概念。多态指的是允许将子类类型赋值给父类指针，而父类指针可以通过统一的接口对所有子类对象进行操作 作用与目的：封装为了隐藏实现细节，以及数据类型和函数的统一，模块化；继承是为了方便扩展已有的代码模块；两者均可实现代码重用，而多态是为了实现接口重用 实现方法：虚函数 10.6 重写与重载，前者override是指子类重新定义父类的虚函数，后者overload是指同时存在多个参数列表不同的同名函数 第十一章 继承与接口 11.1 如果显式调用虚函数，则虚调用机制失效，如 class B::public A{}; B b; b.A::f(); ，类f为虚函数，但此时显式调用A中的f 11.2 三种继承方式的区别 public继承：基类的public和protected成员对基类保持原有状态 基类成员对派生类的可见性：派生类（的成员函数）可以访问基类的public和protected成员 基类成员对派生类对象的可见性：（通过）派生类的对象（指例如 a.f()的方式 ）可以访问基类的public成员 private继承：将基类的public和protected成员当成派生类的private成员，且不能被派生类的子类访问 基类成员对派生类的可见性：派生类（的成员函数）可以访问基类的public和protected成员 基类成员对派生类对象的可见性：（通过）派生类的对象不可以访问基类的任何成员,因此基类的成员无法再向下继承 protected继承：将基类的public和protected成员当成派生类的protected成员，且不能被派生类的子类访问 基类成员对派生类的可见性：派生类（的成员函数）可以访问基类的public和protected成员 基类成员对派生类对象的可见性：（通过）派生类的对象不可以访问基类的任何成员,因此基类的成员无法再向下继承 关键差别在于通过派生类对象可以访问基类的哪些成员，以及派生类的子类能否访问派生类的成员 11.2 三种成员属性的区别：基类的private成员对派生类屏蔽，protected成员使派生类可以访问，基类仅有public成员可以通过基类的对象访问 11.2 虚继承是为了解决多重继承中的菱形继承冲突，派生类中会添加一个指向基类虚函数表的指针 例如，C、B虚继承自A，D继承自B、C，则D中共有1个A 11.4 Java中使用接口替代多重继承，C++可以使用抽象类模拟接口 11.4 C继承自A，B，pC指向C对象，pB把pC转换为指向B的指针，则 pC == pB ，这里发生从C的指针到B的指针的隐式转换，书中说反了，bug 11.5 类的继承默认为private，通常需要加public关键字 11.6 如何防止一个类实例化：使用带有纯虚函数的抽象类，或者把构造函数声明为private 11.7 RTTI的缺点：除了运行开销外，使程序变得不确定，缺乏扩展性 11.7 类型转换运算符重载，无返回值无参数，以目标类型为函数名，如： operator char*() 11.8 dynamic_cast如果转换失败返回0 11.8 typeid返回值为对type_info常量对象的引用 第十二章 位运算与嵌入式编程 12.1 printf的%f说明符可以输出float和double型，float型会被提升为double型。 printf(\"%f\",5);printf(\"%d\",5.01) ，前者会从存放5的位置取double型的8个字节，内存越界，并按bit解释，后者会按照整数来解释5.01的比特，输出为0，一个大整数。 真的是越界 ？ 12.1 struct a{int z:33;}; 报错，因为z为int型，不可能有33位 12.1 dynamic_cast,static_cast,reinterpret_cast的区别，没有讲清楚 12.2 ISR终端服务程序不应该有参数和返回值，且不能使用不可重入的函数 12.2 volatile的意思是易变的，指的是它可能在程序控制的范围之外意外发生变化，防止编译器的优化。volatile变量可以声明为const，表示是只读的 12.2 const的意思是只读的 12.2 malloc(0) 能得到一个合法的指针，而不是空指针，对其调用strlen和sizeof结果为0和4 12.2 对于结构体 struct bit{int b1:5;int :2;int b2:2;}; 赋值后，取b1,b2的值，该如何解析？ 12.3 static的作用包括哪些？ 函数内的static变量中下次调用时保持值不变 源代码文件（模块）内的static全局变量和函数的作用范围限制在模块内 类的static成员变量对所有对象共享，static成员函数只能访问static成员变量 第十六章 操作系统 16.1 进程间如何通信：信号，信号量，消息队列，共享内存 16.1 死锁的必要条件：互斥，请求与保持，不可剥夺，循环等待。后三种条件可以破坏 16.2 进程与线程的区别： 进程是程序的一次执行，线程为进程中执行的一段程序 进程直接是独立的，而同一进程的线程共享内存空间 第十七章 数据库 17.1 事务：作为单个逻辑工作单元执行的一系列操作，不可分割。具有原子性、一致性、独立性、持久性 17.1 聚集索引与非聚集索引的区别： 聚集索引的顺序就是数据的物理存储顺序，而非聚集索引顺序与物理存储顺序无关 每个表只能有一个聚集索引，聚集索引对于范围查询的列非常有效 17.2 表ppp里面num最小的数 不使用min： select top 1 num from ppp order by num 使用min： select * from ppp where num = (select Min(num) from ppp) 17.2 从表中取出第5行到第七行的数据的语句 第十八章 计算机网络 18.1 OSI七层模型及其作用： 物理层 传输原始比特流 数据链路层 网络层 路由选择 传输层 会话层 表示层 应用层 18.2 TCP与UDP的区别 TCP是传输控制协议，提供面向连接、可靠的字节流服务。提供超时重发、数据检验、流量控制等功能 UDP是用户数据报协议，是面向数据报的传输层协议，不提供可靠性。但由于无需建立连接、超时重发，传输速度快 18.3 socket编程流程 服务器端：socket bind accept sned recv close 客户端： socket connect send recv close 18.3 常用端口号：0到1023范围内，21为FTP，25为SMTP，80为HTTP，23为telnet 18.4 TCP的三次握手与四次挥手","tags":"misc","url":"pages/2014/08/cheng-xu-yuan-mian-shi-bao-dian-jing-hua.html","loc":"pages/2014/08/cheng-xu-yuan-mian-shi-bao-dian-jing-hua.html"},{"title":"20140806《程序员面试宝典》精华 语言部分","text":"《程序员面试宝典》精华 编程语言部分 正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。当然这里的糟粕只是指不那么重要，或者比较简单，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。 文中有少许bug，亦摘录在此。 本文专注编程语言部分，包括第五章到第九章的内容 第五章 语言细节 5.1 y = z = 5 ，等号先计算右边，返回值是赋值后的左边的变量值 5.1 printf函数中的表达式从右向左压栈，应该先计算右方的值 5.4 float型1.0f在内存中表示为：0x3f 80 00 00 5.5 出现int常数的表达式中的变量通常都要提升至int型 5.5 赋值运算符默认从右向左结合，也就是先计算右方的值 5.5 (x&y) + ((x&#94;y)>>1)效果是取二者的平均数 5.6 不用判断和switch语句求a、b中的较大的一个：((a + b) + abs(a - b)) / 2 5.7 extern \"C\" 的用法：函数声明前添加，解决C/C++编译器的名字包装的不同问题 第六章 预处理、const和sizeof 6.1 求结构体中某成员的偏移量： #define FIND(struc, e) (size_t)&(((struc *)0)->e) 6.2 C语言中， const n = 10; char carray[n] 是错误的，因为C编译器不能把const看成编译期的常量。但实验得出是正确的，bug 6.3 C++中给类成员变量添加mutable修饰符，就可以使用const函数修改 6.3 结构体对齐原则：结构体长度一定是最长数据元素整数倍，但如果大于处理器位数，则以处理器位数为对齐单位。CPU数据对齐原则是数据的内存地址必须是该数据长度的整数倍，以提高运行速度 6.3 sizeof(string) == 4 6.3 空类以及（多重）继承的空类大小都为1，但虚继承的类含有虚表指针，大小为4 第七章 指针与引用 7.1 指针与引用的区别 引用总是非空的，指针可能为空，使用时要小心测试 引用不可以指向另一个对象，但指针可以更改 7.1 int *p; *p = 0; 是错误的，指针p并未指向某个实际的地址 7.2 char a[] = \"a\" 数组存放中栈中，函数返回即消失， char *a = \"a\" 数组存放于全局只读数据段 7.2 若类B继承类A，两者皆有成员变量，A中有f方法，则 B b; b.f() 调用的是A中的f，f使用的变量也为A中的变量 7.3 指向const的指针应该是 const int * ，bug 7.3 int ( *(*f)(int, int) )(int) 定义了一个函数指针，接收两个int参数，返回值为一个函数指针 7.4 指向整型数组的指针声明为： int (*p) [] ，指向整型的指针数组声明为： int *p[] ，函数指针的数组的声明： int (*p[10])(int) 7.5 悬浮指针指的是delete之后的指针，应该让指针等于0，使得后续程序使用此悬浮指针出错是可控的。比如第二次delete 7.5 new/delete与malloc/free的区别 前者是运算符，后者是函数 前者除了后者申请与释放动态内存的工作之外，对于非内置类型，还完成类初始化与析构操作 7.6 autoptr中拷贝时会尝试只保留一份指针，因此不适合放在容器中 第九章 STL模板与容器 9.1 如果没有重载拷贝构造函数为深拷贝，而又包含指针，那么调用拷贝构造函数时会复制指针，造成同一个指针 delete多次 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140806cheng-xu-yuan-mian-shi-bao-dian-jing-hua-yu-yan-bu-fen.html","loc":"pages/2014/08/20140806cheng-xu-yuan-mian-shi-bao-dian-jing-hua-yu-yan-bu-fen.html"},{"title":"20140805NeutrinoRDP源码分析 utils库","text":"NeutrinoRDP源码分析 一 utils库 首先分析utils库，代码位于/libfreerdp-utils下，包括api, bitmap, dsp, event, file, list, memory, mutex, rail, semaphore, signal, sleep, stopwatch, stream, string, thread等文件 以下分文件进行解析 api 头文件中定义了FREERDP_API，在linux下为 __attribute__((visibility(\"default\"))) ，作用 是什么 ？ bitmap 这段源码为位图格式文件工具 定义结构体： bmpfile_magic 文件的魔数 bmpfile_header 数据起始位置以及文件大小 BITMAPINFOHEADER 文件头，包括位图相对位置与尺寸， freerdp_bitmap_write函数：把位图数据与尺寸写入指定的文件中，以'w+b'的方式 dsp 数字音频处理工具 event file 文件操作工具 对win/linux/mac环境变量名称、动态链接库后缀名、路径上的 / , \\\\ 做了封装 包含freerdp_mkdir, freerdp_get_home_path, freerdp_get_config_path, freerdp_check_file_exists, freerdp_get_current_path, freerdp_construct_path等命名简单易懂的函数 freerdp_get_config_path等返回路径名称的函数，频繁使用使用sprintf把字符串组合起来得到路径名称 上述函数使用自定义的xmalloc/xstrdup等函数 freerdp_append_shared_library_suffix 如果函数参数文件路径名称后缀不同于动态链接库后缀名，返回添加后缀名后的路径。使用了xstrdup， 返回的字符串指针要记得free freerdp_get_parent_path 参数给出待求的父文件夹阶数，返回向上返回depth次的路径 freerdp_path_contains_separator 判断给定路径是否含有路径分隔符，使用strchr查找 freerdp_detect_development_mode 检测代码文件夹是否使用git进行版本控制。设置当前文件夹到向上两级文件夹是否含有 .git 文件夹，以及含有 .git 文件夹 的路径 freerdp_detect_paths 设置家目录的路径，配置文件路径，版本控制顶层文件夹路径 list 双向链表，提供了队列模式接口 //头文件全部补上 list_item_new 新建节点，data为数据指针 list_item_find 线性查找，找到指向指定数据指针的链表节点 以上两个函数使用static修饰，作用域限制于源文件内 list_new 新建链表 list_free 释放链表：如果头指针不为空，持续调用list_dequeue，逐个节点释放 list_enqueue 把数据指针添加到链表尾部新建的节点中，同时节点数量 list_dequeue 把链表头部首个节点释放，更新节点数量。对于空链表不做处理 list_peek 返回链表当前头节点的数据指针，可能为NULL list_next 返回链表中存放 给定数据指针的节点的下一个节点指向的数据指针 list_remove 移除存放给定数据指针的节点 list_size 返回链表中节点数量 memory 内存管理工具 定义shm_info_t xmalloc 对malloc函数的简单封装，申请一块内存 xzalloc 对calloc的简单封装，申请一块内存，并没有注释所说的全部填充0的功能 xrealloc 对realloc的简单封装，调整内存大小 xfree 对free的简单封装 xstrdup 对strdup/_strdup（windows下）的简单封装，strdup会在内部调用malloc，容易忘记free，应该使用strcpy代替 create_shm_info 生成指定大小的shm_info_t（信号量），兼容win/linux delete_shm_info 释放shm_info_t指针，兼容win/linux xnew定义在头文件中，为一个调用xzalloc的宏 mutex 锁 win/linux差别较大，几乎所有文件都使用ifdef来兼容两种操作系统 freerdp_mutex_t win定义为 HANDLE，linux定义为pthread_mutex_t freerdp_mutex_new 创建一个锁，linux下使用pthread_mutex_init初始化 freerdp_mutex_free 去除锁，linux使用pthread_mutex_destroy freerdp_mutex_lock freerdp_mutex_unlock 加锁，linux下为pthread_mutex_lock, pthread_mutex_unlock的简单封装 rail RAIL：Remote Applications Integrated Locally rail_unicode_string_alloc 为一个UNICODE_STRING结构体指针初始化结构体内存空间 signal 对信号的处理 静态函数fatal_handler freerdp_handle_signals sleep freerdp_sleep 睡眠n 秒，调用sleep函数实现 freerdp_usleep 睡眠n 微秒，调用usleep函数 freerdp_get_mstime 使用gettimeofday得当时间，换算为ms返回 stopwatch 秒表 头文件中定义STOPWATCH struct _STOPWATCH { clock_t start; clock_t end; double elapsed; clock_t count; }; 定义stopwatch_create、stopwatch_free、stopwatch_start、stopwatch_stop、stopwatch_reset、stopwatch_get_elapsed_time_in_seconds、stopwatch_get_elapsed_time_in_useconds函数 stream 流 STREAM 为结构体，包含size，两个uint8的指针 p和data，头文件中定义类很多宏，如下： stream_attach 使用给定的数组及其大小初始化stream，位置指针p指向data的开始位置 stream_detach 使用memset将stream置0 stream_clear 使用memset将stream成员数组data置0 stream_check_size 如果p之后的剩余空间不到n，调用stream_extend扩展n空间。此处使用while的 作用是什么 ？ stream_get_pos stream_set_pos set、get位置指针p stream_seek p向后移动指定偏移量 stream_rewind p向前移动指定偏移量 stream_seal 根据p重设size stream_get_mark stream_set_mark 用外部指针mark set、get位置指针p stream_get_ + head、tail、length、data、size、left 分别得到当前有效数据的开头、末尾、长度， 数据数组指针data、size、剩余空间 stream_read_ + uint8、uint16、sint16、uint32、uint64 从流中读取指定大小的数据，并更新p 均使用类while， 为什么 ？ stream_read 使用memcpy向指定地址拷贝指定大小的数据，更新p stram_write_ + uint8、uint16、uint32、uint64, stream_write 等函数与上述read函数类似 stream_write_zero 写入 \\0 stream_set_byte 使用memset向stream写入指定长度的指定值，更新p stream_peek_ + uint8....uint64 取得指定大小的值，只读，不更新p stream_seek_ + uint8...uint64 移动相应大小 stream_ + read/write + _ + uint16/uint32 + _be 使用big endian读写相应大小，更新p stream_copy 从源stream读取n个字节，写入到目标stream，使用memcpy 以下为包含的函数 stream_new 使用给定的size创建一个STREAM stream_free 回收stream占用的内存 stream_extend 扩展stream的data数组增加指定大小，至少扩展到当前数组大小的两倍以避免频繁调用xrealloc，实现精巧 宏中大量使用 do{...}while(0) 包括多行代码，应该是为了封装宏为单个语句，易于使用 string 字符串工具 头文件中定义了rdp_string，之后 typedef struct rdp_string rdpString; ，这么多应该是为了修改定义时方便，很精巧 rdpString包含length和两个char指针：ascii和unicode freerdp_string_length32 从流中读取uint32的值作为rdpString的长度，之后从流中读取此长度的数据写入unicode指向的数组，并转换为ascii编码写入asscii指向的数组 freerdp_string_free 回收string中两个指针指向的空间 thread 线程 头文件中定义结构体freerdp_thread，成员有mutex, wait_obj管道数组signals[5] 源代码中定义函数如下： freerdp_thread_new 创建freerdp_thread, signals数组初始化两个，也即初始化时一个线程有1个mutex和2个管道 freerdp_thread_start 调用pthread_create 使用给定函数和参数创建线程，并使用pthread_detach分离线程避免僵死 freerdp_thread_stop 对signals数组中第一个wait_obj调用wait_obj_set 什么用 ？，如果freerdp_thread的status不为0，至少休眠 freerdp_thread_free 释放freerdp_thread 头文件中定义宏如下： freerdp_thread_wait 对freerdp_thread的signals数组调用wait_obj_select，返回select结果 freerdp_thread_wait_timeout select最多阻塞timeout时间返回 freerdp_thread_is_stopped 通过调用wait_obj_is_set检测signals[0]读取端是否可读 freerdp_thread_is_running 如果status为1，表示正在运行 freerdp_thread_quit status标记为-1，调用wait_obj_clear清空管道signal[0] freerdp_thread_signal 对signals[0]调用wait_obj_set freerdp_thread_reset 调用wait_obj_clear清空管道signal[1] freerdp_thread_lock/freerdp_thread_unlock 解锁/加锁 wait_obj Virtual channel manager 源文件中定义结构体wait_obj，windows下成员为HANDLE，linux下成员为 int pipe_fd[2] 。两操作系统均定义了int类型成员变量attached wait_obj_new linux下对数组pipe_fd调用pipe函数建立管道，两个数组元素分别是读取写入文件描述符 wait_obj_new_with_fd 使用给定的描述符初始化一个管道的读取端 wait_obj_free 关闭wait_obj的读取写入fd，并回收其内存 wait_obj_is_set 新建一个fd_set，将wait_obj管道读取端加入fd_set,使用select检测是否可以读数据，timeout = 0， maxfdp应为所有fd最大值加1 wait_obj_set 如果管道不可读，则写入\"sig\" wait_obj_clear 从管道中读取所有可读数据 wait_obj_select 对一列wait_obj做select，返回select结果 wait_obj_get_fds 将wait_obj管道读取描述符加入fds数组","tags":"misc","url":"pages/2014/08/20140805neutrinordpyuan-ma-fen-xi-utilsku.html","loc":"pages/2014/08/20140805neutrinordpyuan-ma-fen-xi-utilsku.html"},{"title":"20140803软硬件接口第0周作业","text":"软硬件接口第0周作业 内存寻址 无论是4字节机器字还是8字节机器字，地址都按照实际地址来取，即每个机器字的数个字节每个均有单独的地址 指针使用一个机器字存储 X86架构使用小头字节序，低字节在前，internet使用大头字节序。对于char数组，在两种字节序下兼容 整数的表示 有符号整数用补码形式表示，可以把减法转换为加法： a - b = a + (-b) 补码表示的负数的最高位表示 -2&#94;(N-1) ，其他位与整数相同，表示 2&#94;(N-2), ... 2&#94;1, 2&#94;0 如下图： 例如：1111表示 -8 + 4 + 2 + 1 = -1 要得到负数-x的补码表示，有如下关系： ~x + 1 = -x ，即绝对值的反码加1 最大值参考 /usr/include/limits.h ，与平台有关 C语言中的常数默认为int，使用 0U 前缀可以强制为unsigned int类型 int与unsigned之间的类型转换为按位解释。隐式转换可以在gcc中使用 -­‐Wsign-­‐conversion ，但 -Wall 选项没用 int类型移位 逻辑右移：左方填0 算术右移：左方填充符号位，保持符号不变。如果移动位数不在 [0, 32) 之间，行为未定义 C语言中默认为算术右移 C语言的右移向下取整，和除法不同，比如 -3 / 2 = -1, -3 % 2 = -1, -3 >> 1 = -2 。而python中 -3 / 2 = -2, -3 % 2 = 1 ，除法和右移一致。 gcc命令行参数 -Wall 显示所有类型的警告 -g 生成带有调试符号表的可执行文件 -std=gnu99 使用C99标准，允许在for循环内声明变量 -o filename 指定编译得到的程序的文件名 valgrind valgrind程序可以非常方便的完成内存泄露分析 valgrind ./arrays 可以检查arrays程序是否存在内存泄露 valgrind --leak-check=full ./arrays 可以显示详细的内存泄露位置信息","tags":"misc","url":"pages/2014/08/20140803ruan-ying-jian-jie-kou-di-0zhou-zuo-ye.html","loc":"pages/2014/08/20140803ruan-ying-jian-jie-kou-di-0zhou-zuo-ye.html"},{"title":"20140802排序算法分析及实现","text":"排序算法分析及实现 算法稳定性 不稳定的排序算法共有四种，快排，选择排序，希尔排序，堆排序。首字母为qssh，简记为\"去死\" 不稳定算法 快速排序 选择排序 希尔排序 堆排序","tags":"misc","url":"pages/2014/08/20140802pai-xu-suan-fa-fen-xi-ji-shi-xian.html","loc":"pages/2014/08/20140802pai-xu-suan-fa-fen-xi-ji-shi-xian.html"},{"title":"20140802如何统计代码行数","text":"如何统计代码行数 linux下提供了很多实用工具，甚至在安卓上，都有移植的busybox包含这些工具。 根据KISS理念，这些工具的功能很单一。但这些工具组合起来，就可以很方面的统计代码量了。 统计代码行数 流程为：首先使用find命令找到所有后缀名符合规则的源代码文件，之后使用wc命令统计行数。文件数可能过多，为防止出错使用xargs命令分割参数列表，最后得到的结果可以使用sort排序 统计所有c源代码行数的命令： find -name *.c | xargs wc -l |sort -r 。结果按照反序排列 find -name *.c | xargs wc -l |sort -k2 结果按照文件名排列 如需统计c++代码，将 *.c 更改为 *.cc 即可。如果c++使用cpp后缀名，改为 *.cpp 用到的命令详解 find命令 find命令递归搜索目录，若任一文件使表达式为真则放入结果 使用方法 find [path...] [expression] path指定需要寻找的目录范围，默认为当前目录 expression通常为测试条件，返回true或false -name pattern 文件名符合shell正则式 -path pattern 文件路径名符合shell正则式 -exec order {} 执行命令，若返回值为0则真 例子： find -name *.c 搜索后缀名为c的文件 例子： find . -exec sleep {1} 每隔1s显示一个文件 wc命令 wc为wordcount的缩写，用于统计文件 使用方法 wc [-lwc] filename l、w、c分别表示统计行数、单词数、字符数。默认为统计全部三者 例子： wc -l file1 file2 统计两文件的行数 xargs命令 xargs的功能是捕获管道中前一个命令的输出，建立分段参数表并执行另一个命令 find命令如果产生的参数列太长，可以使用xargs命令每次只传递一部分参数，防止在部分系统上出现溢出错误 xargs通常以空格或者换行符分割参数， -0 选项可以保证参数列中含有空格、换行符等时分割正确 例子： find /tmp -name core | xargs -0 /bin/rm -f 。把 /tmp 文件夹下所有名称为core的文件传递给rm命令，强制删除。 -0 选项可以保证正确处理文件名中含有换行或空格的情况。 sort命令 sort用于对不同的文本进行排序，以行为单位 默认排序方式为升序， -r 选项可以修改为降序排列 -n 选项按照字符表示的数字的值来排序，如 1 2 10 20 没有开启此选项排序结果为 1 10 2 20 -f 忽略大小写 -t 设置列之间的分隔符， -k 指定按照第几列排序 例子： sort -n -f -k 2 test.txt 。将test.txt中的各行按照第二列排序，忽略大小写 重定向 行数统计结果可以存入文本文件中，命令行最后加上 > count.txt 即可 标准输入、输出、错误输出分别用0，1，2表示 输入重定向使用输入重定向运算符 < ，可以把文件中的内容作为程序的输入。例如测试代码时使用： ./a.out < test.in ，test.in文件里面是程序的测试输入 输出重定向可以将程序的输出写入到文件中，使用输出重定向运算符 > 。 例子： ls 1>/dev/null 2>/dev/null 不显示输出和错误输出。1、2与>之间不能有空格 例子： ls 2> &1> t.txt 将错误输出重定向到标准输出，而此时标准输出还未重定向，因此标准输出内容将写入t.txt，而错误输出仍留在屏幕上 例子： ls 1> t.txt 2> &1 将标准输出和错误输出都写入t.txt 管道 管道使用 | 表示 功能为前一个命令的标准输出定向为第二个命令的标准输入 第二个命令必须能从标准输入中读取才行，如 ls 命令就不符合要求 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140802ru-he-tong-ji-dai-ma-xing-shu.html","loc":"pages/2014/08/20140802ru-he-tong-ji-dai-ma-xing-shu.html"},{"title":"20140801socket套接字socket套接字TCP API","text":"socket套接字TCP API socket概念 socket又称\"套接字\"，是计算机网络中进程间通信数据通道的一个端点，或称之为句柄。IP地址+端口号就可以唯一确定一个socket。 TCP/IP协议族包括传输层（TCP/UDP），网络层（ICMP/IP/IGMP），链路层（ARP/RARP）。应用层通常使用socket地址，即IP地址+端口号来确定通信的对端。而socket正是TCP/IP协议族与应用层之间的接口层，可以说对上层提供了TCP/IP协议族的一种封装，无需关心更底层的实现。 应用上通常使用一些更高层的协议库来编程，socket更多归类于底层驱动编程。不过熟悉socket总归是有好处的。 套接字地址结构 IP地址+端口号可以唯一确定一个socket套接字地址，命名为 sockaddr_in ，位于 netinet/in.h 头文件中，定义如下。 struct in_addr{ in_addr_t s_addr; }; struct sockaddr_in{ uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero(0); }; in_addr_t in_port_t 位于 netinet/in.h in_addr_t 一般定义为 uint32_t ， in_port_t 一般定义为 uint16_t sa_family_t 位于 sys/socket.h uint8_t 等位于 sys/types.h 中 sin_addr sin_port 即为以网络字节序存储的32位ip地址与端口号 套接字地址有很多种，为了能够统一以指针的形式使用socket API，使用时需要转换为通用套接字地址 sockaddr ，一般进行强制类型转换即可。 socket基本TCP API 相关函数定义于 sys/socket.h 中 socket函数 socket函数用以创建一个socket。 int socket(int family, int type, int protocal); family通常设置为 AF_INET``AF_INET6 ，分别表示IPv4/6协议。 type通常设置为 SOCK_STREAM SOCK_DGRAM SOCK_RAW ，分别表示字节流（TCP），数据报（UDP），原始套接字。 protocal表示协议族， IPPROTO_TCP' IPPROTO_UDP`通常设置为0也可。 返回值表示非负套接字描述符 connect函数 用于建立连接 int connect(int sockfd, const struct sockaddr *servaddr, int addrlen); TCP客户端用connect函数与服务器端建立连接 此函数将激发TCP的三次握手连接过程，直到链接建立成功或出错才返回 每个socket只能调用一次connect，出错后必须close当前socket再次重新依次调用socket、connect 函数参数为socket描述符，通用socket地址指针及其结构体大小。 bind函数 bind将IP地址和端口绑定到套接字描述符 int bind(int sockfd, const struct sockadddr *myaddr, int addrlen); 如果sin_addr.s_addr设置为INADDR_ANY，且主机有多个网络接口，则可以在多个网络接口接受用户connect listen函数 listem将一个未调用connect函数的socket转换为一个被动监听套接字 int listen(int sockfd, int backlog); backlog规定了挂起连接的最大数量 accept函数 内核为任一个监听套接字维护一个正在处于握手连接阶段的未完成连接队列，以及已完成连接队列 accept每次接受一个监听套接字描述符，返回一个已连接队列中的已连接套接字描述符 已连接套接字的套接字地址与地址长度存放于cliaddr与addrlen指向的内存中。如果使用两个0来调用，则无法得到客户端已连接套接字表示的地址与端口等信息。 对于每个处理完毕的连接，应该close，否则可能耗尽套接字描述符 int accept(int sockfd, struct sockaddr *cliaddr, int *addrlen) close函数 close一个TCP套接字默认行为是把socket标记为关闭后返回。但触发了四次挥手过程 int close(int sockfd); 传送数据 通常需要一个缓冲区，之后使用recv、send函数接收发送 read、write在*nix系统上也可以 int recv(int sockfd, void *buf, size_t len, int flags); int send(int sockfd, const void *buf, size_t len, int flags); TCP通信客户端与服务器端 客户端流程 使用connect连接服务器之后就可以开始传输数据 服务器端流程 需要首先绑定网络接口（bind），之后进入监听状态（listen），最后从队列中取出一个已经连接的套接字，即获得新连接（accept），之后可以开始传输数据 源代码如下： 服务器端 # include < sys / types . h > # include < sys / socket . h > # include < netinet / in . h > # include < stdio . h > int main () { struct sockaddr_in local ; int s ; int sl ; int rc ; char buf [ 1000 ]; local . sin_family = AF_INET ; local . sin_port = htons ( 7500 ); local . sin_addr . s_addr = htonl ( INADDR_ANY ); s = socket ( AF_INET , SOCK_STREAM , 0 ); if ( s < 0 ) { perror ( \"socket call failed\" ); exit ( 1 ); } rc = bind ( s , ( struct sockaddr * ) & local , sizeof ( local )); if ( rc < 0 ) { perror ( \"bind call failed\" ); exit ( 1 ); } rc = listen ( s , 5 ); if ( rc < 0 ) { perror ( \"listen call failed\" ); exit ( 1 ); } sl = accept ( s , NULL , NULL ); if ( sl < 0 ) { perror ( \"accept call failed\" ); exit ( 1 ); } rc = recv ( sl , buf , 10 , 0 ); if ( rc < 0 ) { perror ( \"recv call failed\" ); exit ( 1 ); } printf ( \"%s\\n\" , buf ); rc = send ( sl , \"good\" , 10 , 0 ); if ( rc < 0 ) { perror ( \"send call failed\" ); exit ( 1 ); } exit ( 0 ); } 客户端 # include < sys / types . h > # include < sys / socket . h > # include < netinet / in . h > # include < arpa / inet . h > # include < stdio . h > int main () { struct sockaddr_in peer ; int s ; int rc ; char buf [ 100 ]; peer . sin_family = AF_INET ; peer . sin_port = htons ( 7500 ); peer . sin_addr . s_addr = inet_addr ( \"127.0.0.1\" ); s = socket ( AF_INET , SOCK_STREAM , 0 ); if ( s < 0 ) { perror ( \"socket call failed\" ); exit ( 1 ); } rc = connect ( s , ( struct sockaddr * ) & peer , sizeof ( peer )); if ( rc ) { perror ( \"connect call failed\" ); exit ( 1 ); } rc = send ( s , \"hello\" , 10 , 0 ); if ( rc <= 0 ) { perror ( \"send call failed\" ); exit ( 1 ); } rc = recv ( s , buf , 10 , 0 ); if ( rc <= 0 ) { perror ( \"recv call failed\" ); } else printf ( \"%s\\n\" , buf ); exit ( 0 ); } 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/08/20140801sockettao-jie-zi-sockettao-jie-zi-tcp-api.html","loc":"pages/2014/08/20140801sockettao-jie-zi-sockettao-jie-zi-tcp-api.html"},{"title":"20140801使用Markdown写简历","text":"","tags":"misc","url":"pages/2014/08/20140801shi-yong-markdownxie-jian-li.html","loc":"pages/2014/08/20140801shi-yong-markdownxie-jian-li.html"},{"title":"20170731剑指offer思路笔记","text":"","tags":"misc","url":"pages/2014/07/20170731jian-zhi-offersi-lu-bi-ji.html","loc":"pages/2014/07/20170731jian-zhi-offersi-lu-bi-ji.html"},{"title":"20140728Matlab并行编程","text":"Matlab的parfor并行编程 通常消耗最多计算资源的程序往往是循环。把循环并行化，或者优化循环体中的代码是最常用的加快程序运行速度的思路。 Matlab提供了parfor关键字，可以很方便的在多核机器或集群上实现并行计算。 parfor关键字的使用 由for关键字引导的循环通常为串行运行，如果改为parfor则可以由多个worker以并行方式执行。 parfor可以将n次循环分解为独立不相关的m部分，然后将各部分分别交给一个worker执行。 循环执行的结果应该与n次循环执行的顺序无关。 parfor中的变量类型 简约变量 一般parfor中各次循环对应的运算应该相互独立，但简约操作可以在多次循环内同时对一个变量操作。这种变量称为简约变量。例如下方代码中a就是简约变量。 a = 0; for i = 1:1000 a = a+i; end 简约操作包括 + - * .* & | [,] [;] {,} {;} min max union intersect 。 同一个parfor循环对简约变量的操作必须一致，即必须是同一种简约操作符。而且与操作符的相对位置也必须一致。 简约变量赋值表达式应该满足结合律和交换律。 * [] {} 底层有特殊处理保证结果的正确性。 切片变量 parfor中可能需要读取或写入parfor之外的矩阵，读取写入位置与循环变量相关。这样就需要向worker传输大量的数据。 矩阵如果被Matlab识别为切片变量，则数据可以分段传输到各worker，提高传输效率。 切片变量矩阵的大小是不可在parfor中改变的，且为了保证Matlab识别正确，每次循环中只能读取由同一个索引值索引的切片，如 a[i] a[i+1] 同时出现则a不被识别为切片变量。 循环变量 如上例中的i，表示当前循环的id。 广播变量 在parfor之前赋值，在parfor内只进行读取操作。 临时变量 作用域局限于parfor内，parfor结束后不存在。不影响parfor之前声明的同名变量。 各种变量区分的例子 下例中，parfor中的tmp是临时变量，parfor结束后tmp的值依然是5，不受临时变量的影响。 broadcast是广播变量，每次循环中的值不变。 redued是简约变量，Matlab对其的值将分段由各worker计算后送回主进程处理。 sliced为切片变量，数据传输有优化提升。 i为循环变量。 tmp = 5; broadcast = 1; reduced = 0; sliced = ones(1, 10); parfor i = 1:10 tmp = i; reduced = reduced + i + broadcast; sliced(i) = sliced(i) * i; end worker配置 在运行程序之前，需要配置worker。否则如前文所说，parfor循环将以普通for循环的形式运行，无法并行。 单机配置 使用matlabpool命令可以开启关闭本机的并行计算池。 matlabpool n 命令可以打开n个worker。 matlabpool open configname 按照指定配置打开，默认配置为 local 。 程序运行结束后，应该使用 matlabpool close 关闭worker。 配置项的修改可以通过 Parallel -> Manage Cluster Profile 完成。 n的选择：如果有c个cpu核心，通常可以设置为c。如果是远程服务器，为防止服务器响应卡顿，可以设置为 c-1 。对于计算密集型程序，超线程带来的性能提升几乎为0，可以设置为核心数，而不是线程数。 注意事项 循环次数n最好能整除以worker个数m，否则部分worker会分配较多的循环，造成一部分worker闲置一段时间，降低了并行性。 并行运行时各个worker之间会进行通信，要注意大量数据传输带来的性能下降。尤其对于广播变量，如果较大可尝试变为切片变量。 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点我","tags":"misc","url":"pages/2014/07/20140728matlabbing-xing-bian-cheng.html","loc":"pages/2014/07/20140728matlabbing-xing-bian-cheng.html"},{"title":"20150724多普勒失真信号重采样的Matlab仿真分析","text":"多普勒失真信号重采样的Matlab仿真分析 应用场景 水声通信指的是使用声信号在水中传输数据。相对而言，电磁信号在水中吸收严重衰减过快，光信号受水中悬浮颗粒的影响，也无法完成远距离传输。这两种信号的传播距离约为数百米，而声信号在水中传播距离达到数十千米，成为水下通信的首选方式。 水声通信的一个重大挑战就是运动带来的多普勒。多普勒造成信号的频率漂移，影响系统性能，因此非常有必要消除多普勒带来的影响。而多普勒在时域的表现为信号的长度压缩和扩展，即'y(t) = x((1+a) * t)'，其中 a 为多普勒因子。而如果估计出多普勒因子，之后采用重采样技术就可以恢复得到原始信号 x(t) = y( t/(a+a) ) 。 重采样的意义就是插值，从一个信号插值得到多普勒影响前后的信号。而 1+a 一般为小数，虽然采用多相滤波可以达到很好的插值效果，但复杂度太高。相比之下，线性插值、样条插值等方式运算量小，在做数字系统的时候更加合适 Matlab一维插值 MATLAB中的插值函数为 interp1() ,其调用格式为 yi=interp1(x,y,xi, 'method') 。其中x,y为观测数据点,xi为插值(自变量)向量,yi为xi的插值结果(函数值)。 'method' 表示采用的插值方法。取值'nearest'为最邻近插值，'linear'是线性插值，'spline'是三次样条插值，'cubic'为分段三次Hermite插值。默认情况为线性插值，三次样条效果最平滑，三次效果多项式介于两者之间。 线性插值：通过所在位置相邻两点的值来插值。已知f(a)和f(c)，b在a,c中间，求f(b)的公式为： f(b) = f(a) + (b-a)/(c-a) *[f(c) - f(a)] 。 分段三次Hermite插值：分段让邻近两点的导数相同，曲线更平滑。 样条插值：样条插值通常比多项式插值好用。用低阶的样条插值能产生和高阶的多项式插值类似的效果，并且可以避免龙格现象。 线性插值的误差 插值不免会造成信号失真，定义原始信号功率与噪声功率的比值为信干比，计算公式为： SDR = 10 * log10( power(x(t)) / power(x(t) - x'(t) ) 。 x'(t) 为插值后得到的信号。 而对于线性插值，SDR与信号采样频率 fs 和信号频率 f 的比值有近似如下关系： SDR(dB) = 40 * log10( fs/f /2 ) 。 仿真对比 代码如下。 - 首先设置多普勒因子 dop ，插值方法，采样率与信号频率的比例ns。最小值取2，对应奈奎斯特频率。 - 之后对于每个ns值，生成相应的初始信号 a ，之后插值以对信号添加多普勒。因 spline 方法造成的误差最小，选择作为添加多普勒的方法。 - 采用不同的插值方法去除多普勒。因为插值造成信号长度变化，每次都只略去尾部6000个数据点。 - 之后画图，每个ns对应一张图，并注明实测SDR以及线性插值的理论SDR值以作对比。 dop = 0.05 ; intermethod = ' nearest ' ; % nearest linear cubic spline %n : fs / fc ns = 2 : 7 ; figure ; for n = ns a = sin ( 2 * pi * ( 1 + rand () : 1 : 50000 ) / n ); b = interp1 ([ 0 : length ( a ) - 1 ], a ,[ 1 - 1 : length ( a ) - 6000 - 1 ] * ( 1 + dop ), ' spline ' ); c = interp1 ([ 1 - 1 : length ( b ) - 1 ], b ,[ 1 - 1 : length ( b ) - 6000 - 1 ] / ( 1 + dop ), intermethod ); subplot ( 3 , ceil ( length ( ns ) / 3 ), n - 1 ); plot ( a ( 29901 : 30000 )); hold on ; plot ( c ( 29901 : 30000 ), 'r' ); error = sum ( abs ( a ( 1 : 30000 ) - c ( 1 : 30000 )) . &#94; 2 ) / sum ( abs ( a ( 1 : 30000 )) . &#94; 2 ); title ([ ' fs / fc = ' , num2str ( n ), ' SDR = ' , num2str ( 10 * log10 ( 1 / error )), ' dB VS ' , num2str ( 40 * log10 ( n / 2 )), ' dB ' ]) end 仿真结果分析 临近点插值仿真结果：性能极差，无法使用。 线性插值仿真结果：可见与理论值符合的较好。 分段三次Hermite插值插值仿真结果：大约提高5dB，但带来的是大量的计算。 三次样条插值仿真结果：性能非常好，但最复杂。因为添加多普勒时也采用了样条插值，仿真结果加上3dB才应该是理论结果。 结论 如果采用重采样来去除多普勒带来的影响，并且采用较为实用的线性插值法，若要达到约19dB的通信信噪比要求，需要提高采样率至少为6倍信号频率。 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点我","tags":"misc","url":"pages/2014/07/20150724duo-pu-le-shi-zhen-xin-hao-zhong-cai-yang-de-matlabfang-zhen-fen-xi.html","loc":"pages/2014/07/20150724duo-pu-le-shi-zhen-xin-hao-zhong-cai-yang-de-matlabfang-zhen-fen-xi.html"},{"title":"20140723coursera_dl","text":"Coursera下载工具源码解析 入口 coursera-dl脚本中调用了coursera/coursera_dl.py中的coursera_dl.main() coursera_dl中加载的库 BeautifulSoup与html5lib argparse用以解析参数 json解析json数据 subprocess子进程管理 requests six logging 参数args解析","tags":"misc","url":"pages/2014/07/20140723coursera_dl.html","loc":"pages/2014/07/20140723coursera_dl.html"},{"title":"20140722《剑指offer》解题笔记","text":"《剑指offer》解题笔记 《剑指offer》共50题，这两周使用C++花时间做了一遍，谨在此把一些很巧妙的方法、写代码遇到的难点、易犯错的细节等做一个简单的标注，但不会太过详细，具体算法还是请参考书本。 做的比较急，代码还有很多不完善的地方，如有错误，欢迎改正，地址为： github:sword_of_offer 。可以使用 git clone https://github.com/heLomaN/sword_of_offer.git 命令获取代码。 其中，少数无法验证正确与否的题目没有写代码，部分二叉树的题目写了代码，但由于生成二叉树太过麻烦没有验证。 解题笔记 Q3 声明并初始化二维数组的语句如何写？ cin如何判断输入结束？ Q4 字符数组的末尾位置计算差了1，忘了加上\\0，要小心 Q5 递归的方法更简洁 Q6 stl的find算法 vector传值性能差，应该用引用 截取一段时要根据左右子树的长度来截，再次find是错误的 Q7 stack的pop返回值是void，而top方法才返回顶部值 Q8 这个二分相当的难。尤其是非递归的写法 边界值处理要仔细想 不能忽略如1 0 1的特殊情况 Q9 应该用long long类型 Q10 求数的二进制表示种1的个数应记住：减1再&自身总会消去一个1 Q11 除以2用>>，模2用&，效率更高 应该加上错误检测 Q12 遇到数字有关的题，首先考虑是不是大数问题 Q13 把下一个节点的值拷贝到当前节点即可，之后删除下一个节点 Q14 9du oj要求奇数或偶数的顺序不变，现在的代码没有符合这个要求 Q15 node *p,q 只把p声明为指针，小心 参考 https://github.com/julycoding/The-Art-Of-Programming-By-July ， * 应该靠近类型名 Q16 画图以帮助理解 Q18 !p判断指针为空是可以的 代码未测试 Q22 方法很难想起来，要仔细分析其中规律 Q25 代码未测试 Q26 方法很难想起来 第三步分离链表操作不够简洁 Q27 使用了一个辅助vector，书上的方法不能仔细的写出来 Q28 这种解法无法处理多个字符重复的情况，会造成重复 递归的时候修改全局数组，但递归调用后要把全局数组修改回来，和之前递归调用前后出入栈的方法有异曲同工之妙 8皇后问题也可以用这个方法解决 Q29 求数组中任意第K大的数字有成熟的O(n)的算法 Q30 C++中throw new excetion(\"error\")是不正确的，不能用字符串初始化excetion set和multiset是基于红黑树实现的 Q31 第一种解法和DP解法原理是一样的 Q32 1到n个9之间出现1的次数是n*10&#94;(n-1) 代码未测试 Q33 itoa不是标准库函数，只是linux下的库函数，可以用printf代替 string可以直接+、>、<运算 Q34 关键是如何保证已经找到的丑数数组是有序的 Q35 memset函数是在cstring头文件中 Q35 关键是merge两个数组时的细节处理 归并排序相当于O(n)的空间换来了时间复杂度提升到O(nlogn) Q37 代码未测试 Q38 关键是改变二分查找的循环判断条件 Q39 题目2的算法不易想起 代码未测试 Q40 方法很巧妙 C++中auto& e : v遍历容器注意v指向元素的引用才可以改变容器中的值 Q41 书中未给出算法证明，亟待解决 Q43 方法巧妙，解法很难想起来 Q45 方法巧妙，解法很难想起来 Q50 如果有指向父节点的指针，那么找到这两个点到根节点的链表，求第一个公共节点 如果没有，那么dfs遍历得到这两个点的链表，求第一个公共节点 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/07/20140722jian-zhi-offer-jie-ti-bi-ji.html","loc":"pages/2014/07/20140722jian-zhi-offer-jie-ti-bi-ji.html"},{"title":"20140716hard_soft_interface","text":"《软硬件接口》课程大纲 Coursera课程 The Hardware/Software Interface 是华盛顿大学提供的一门课程，其中汇编语言、进程结构、Java实现等章节内容我认为对于学编程的同学来说非常有用。教学环境是Fedora，顺带介绍了一些常用工具的使用。 课程大纲 这门课程将会让学生知道当软件运行时到底发生了什么，并说明这个问题可以通过硬件架构层、汇编层、C语言层和Java层等数层抽象解答。- 这门课程的核心是关于C、汇编、以及底层数据表示的，但同时与更高层（Java语言实现机理）、更底层（处理器通用架构）、操作系统（无关操作系统的实现）相关。 对于那些想要专注于高层抽象的计算机专业学生来说，这门课可能是他们学习到的关于C语言及以更下层的唯一课程。不过，他们大多能够同时学到一些系统编程、硬件设计与实现、操作系统、编译器等知识。 对于对硬件、嵌入式系统、计算机工程、计算机架构等感兴趣的学生来说，这门课程是一门入门课程，后续课程会在特定领域更加深入，并且会关注更下层的硬件实现、电路设计等。 课程主题 本课程主要有三个主题。 1. 表示：不同的数据类型，如整数和结构体数组，在内存中如何存在？指令如何编码？如何生成内存地址并用于创建复杂的数据结构？ 2. 翻译：高层的语言，如C和Java如何转换成硬件处理器的基本指令？ 3. 控制流：计算机如何阻止计算的顺序，如何跟踪大型程序当前的运行轨迹，多个进程如何并行执行？ 课程目标 课程结束后，学生应该能够 1. 理解高层次的程序转换成可以被处理器执行的指令流的过程 2. 知道指针是什么，以及如何使用指针操纵复杂的数据结构 3. 能够使用X86汇编语言写简短的程序，并理解汇编语言和高层次语言如何映射 4. 理解分级存储器的基本组织和参数，理解它对于系统性能的重要性 5. 能够解释清楚操作系统的功能 6. 知道Java和C的本质区别 7. 理解并行机制以及它在系统级的重要性 8. 成为更高效的程序员，更有效的debug，对系统性能更敏感 课程专题 大约每周一个专题，包括 - 数字的表示 - 汇编语言 - C语言基础 - 内存管理 - 操作系统的进程模型 - 高层次机器架构 - 分级存储器 - 高层次语言的实现 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点我","tags":"misc","url":"pages/2014/07/20140716hard_soft_interface.html","loc":"pages/2014/07/20140716hard_soft_interface.html"},{"title":"20140715substring","text":"字符串查找算法 字符串查找常用于电子监控，网络数据提取，文本编辑器。 字符串查找要求在一段长度为N的文本text中找到长度为N的pattern字符串的起始位置。常用算法如下。 暴力搜索 遍历text，以text中每个字符开始与pattern做比较。 算法复杂度为MN，比如在AAAAAAAAB中查找AAB 算法需要回退，如果发现一次不匹配，需要回退text的指针。可以通过缓冲M个字符解决 算法实现 public static int search(String pat, String txt) { int i, N = txt.length(); int j, M = pat.length(); for(i = 0, j = 0; i < N && j < M; i++) { if (txt.charAt(i) == pat.charAt(j)) j++; else {i -= j; j = 0; } } if (j == M) return i - M; else return N; } 暴力算法不够好，复杂度不够低，需要回退 KMP算法 相比暴力搜索算法，根据当前一次不匹配的已知信息跳过以后的数次匹配 DFA算法 本质是DFA（deterministic finite state automaton 有限状态机）。已经匹配的字符数作为状态，下一个输入字符为输入条件。 算法实现 public int search ( String txt ) { int i , j , N = txt . length (); for ( i = 0 , j = 0 ; i < N && j < M ; i ++ ) j = dfa [ txt.charAt(i)[[j ] ; if ( j == M ) return i - M ; else return N ; } 与暴力算法的异同 需要根据pattern计算dfa矩阵 指针永不回退，可以使用输入字符流 dfa矩阵的计算 对于符合pattern的状态跳转，拥有从0到M的一条顺序路径 不符合pattern的，将要跳转到的状态等于pattern去除第一个字符情况下要跳转到的状态。可以使用X来跟踪去除第一个字符后腰跳转到的状态。如上图，X应是BABAC的状态跳转 算法实现：对于每个状态j，对于匹配的情况，设 dfa[pat.charAt[(j)][j] = j+1 ,对于不匹配的情况，设 dfa[][X] = dfa[][j] 。复杂度为RM public KMP ( String pat ) { this . pat = pat ; M = pat . length ; dfa = new int [ R ][ M ] ; dfa [ pat.charAt(0) ][ 0 ] = 1 ; for ( int X = 0 , j = 1 ; j < M ; j ++ ) { for ( int c = 0 ; c < R ; c ++ ) dfa [ c ][ j ] = dfa [ c ][ X ] ; // mismatch cases dfa [ pat.charAt[(j) ][ j ] = j + 1 ; // match case X = dfa [ pat.charAt(j) ][ X ] ; // update X } 对字符的读取最多不超过N+M次，而dfa矩阵的构建的时间空间复杂度为RM 如果字符为unicode等R比较大的字符集，应该采用改进的KMP版本。 KMP算法 对于一次匹配，如果匹配到pattern的当前字符位置j+1不再匹配，之前的pattern[1，j]都匹配，那么下一个可能匹配的位置设为pattern[k]，必然有 pattern[1,j-k+1] == pattern[k,j] 。如果有多个k，那么应该取最小的一个，防止遗漏。也即： 在pattern不匹配的字符位置之前的那个字串 pattern[1，j] 中，找到最大的一个字串p，使得它同时是pattern[1，j]的真前缀和真后缀，这个字串p的长度为k 。 对于每一个pattern中的j+1，如果能找到k，那么就能直接得到下一个可能匹配的位置，尽量多的跳过数次匹配。这就是算法的原理。 如何计算k？暴力计算当然是可以的，复杂度M&#94;2。有一种简化的方法 分析j+1与j+2之间的关系，如果 pattern[1,j-k+1] 的后一个字符 pattern[j-k+2] == pattern[j+1] ，则pattern[1，j+1]前后缀相等关系依然保持， k'= k+1 。 如果两者不等","tags":"misc","url":"pages/2014/07/20140715substring.html","loc":"pages/2014/07/20140715substring.html"},{"title":"20140702Python的特性","text":"Python的特性 Python于1991年发布，创始人现在在Google 特性 动态类型 变量在运行时绑定，获得一个数据类型之后还可以更改，数据类型在赋值后确定 变量皆为对象的引用 修改不可变类型时会创建新的对象，而可变类型（list,dict）则是直接修改对象 特别注意在函数传递时，传递的都是引用，如有对对象的修改要当心 强类型 1+\"2\"会报错，不能自动进行类型转换 自动内存管理 整数与短字符串对象会被缓存重用 每个对象都保存有引用计数 使用引用计数完成GC 解释型交互语言 自省 为什么选择python 支持OO中的多重继承 C++支持，但Java不支持，但可以使用接口实现相同的功能 开源 免费 真正的易于移植 强大的库 易于与其他语言混合 易学易用 语法 空格缩进对齐，换行表示一行代码的结束 赋值操作的是reference，x=y使x指向y指向的对象 执行方式： python -i a.py命令可以使命令运行之后持续交互 exec('a.py') import a 变量x需要a.x使用 字符串的截取：s[i:j:k]每间隔k个取一个 array相比list做运算很快，默认的操作是对每一个元素操作 拷贝 copy.copy() 浅拷贝，只拷贝对象 copy.deepcopy() 深拷贝，同时拷贝对象和子对象 list comprehension很常用： [exp for var in list if condition] 并行赋值：可以一次赋值多个变量 异常处理： try except finally ， raise Django MTV架构，M/T/V分别相当于MVC中的M/V/C","tags":"misc","url":"pages/2014/07/20140702pythonde-te-xing.html","loc":"pages/2014/07/20140702pythonde-te-xing.html"},{"title":"20140604c traps and pitfalls","text":"看完《C陷阱与缺陷》，忍不住要重新翻一下，记录一下与自己的惯性思维不符合的地方。记录的是知识的增量，是这几天的流量，而不是存量。 这本书是在ASCI C/C89订制之前写的，有些地方有疏漏。 第一章 词法陷阱 1.3 C语言中解析符号时使用贪心策略，如 x+++++y 将被解析为 x++ ++ +y ，并编译出错。 1.5 单引号引起的一个字符代表一个对应的整数，对于采用ASCII字符集的编译器而言，'a'与0141、97含义一致。 练习1.1 嵌套注释（如 /*/**/*/ ）只在某些C编译器中允许，如gcc4.8.2编译时是不支持的。 第二章 语法陷阱 2.6 else始终与同一个括号内最近的未匹配的if结合 第三章 语义陷阱 3.1 int a[12][31] 表示的是一个长度12的数组，每个元素是一个长度31的数组。 3.1 在需要指针的地方如果使用数组名来替换，那么数组名就被视为其下标为0的元素的指针， p = &a 的写法是非法的（gcc4.8.2只是警告）。 3.2 如何连接两个给出的字符串s、t？细节很重要，书中给出的答案如下： char * r , * malloc () // 原文称不能直接声明一个 s 、 t长度之和的数组 ，但 c99可以声明变长数组 ，已经可以了 // 记得要把长度加 1 r = malloc ( strlen ( s ) + strlen ( t ) + 1 ); // 必须判断内存是否分配成功 if ( ! r ) { complain (); exit ( 1 ); } strcpy ( r , s ); strcat ( r , t ); ...... // 完成之后一定要释放 r free ( r ); 3.6 如何正确计算数组的边界？原则一，考虑最简单情况下的特例；原则二，仔细计算边界。 3.6 以下一段代码为何引起死循环？这是因为在内存地址递减时，a[10]就是i。 int i , a [ 10 ] ; for ( i = 1 ; i <= 10 ; i ++ ) a [ i ] = 0 ; 3.6 边界的编程技巧：用第一个入界点和第一个出界点表示数值范围，即[low,high)。这样的效果是 取值范围的大小为两者之差。 若取值范围为空，则上界等于下界。 3.6 --n 一般比 n-- 执行速度更快。 3.7 运算符&&和||保证两个操作数从左至右求值，其他运算符的操作数求值顺序未定义。比如 y[i] = x[i++] 结果是未定义的。 3.9 如何检测a+b是否溢出？ if(a+b < 0) 是不正确的，因为溢出时的行为是未定义的。正确的方法是将两者转换为unsigned型与INT_MAX比较 更巧妙的方法： if(a > INT_MAX - b) 第四章 连接 4.2 int a 若出现在所有函数体之外，则完成了声明与定义（分配存储空间）。而 extern int a; 只是声明，说明a的存储空间是在其他地方分配的，不是定义；因此必须在别的某个地方定义，同一个或不同的源文件均可。 4.3 static修饰符可以将一个函数或变量的作用域限制在一个源文件之内，不会与其他文件中的同名量发生冲突 4.5 声明与定义必须严格相同，而数组和指针是不同的。 4.6 如何避免声明与定义不符？遵守\"每个外部对象只在一个地方声明\"的规则即可。一般放在头文件中，所有用到此外部对象的源文件都要包括此头文件，定义此对象的文件也应该包括此头文件。 第五章 库函数 5.1 getchar()返回整数，不能把返回值赋值给char型变量再与EOF比较，因为EOF定义为-1，应该赋值给int型变量。 5.2 如果要对文件进行连续的read和write操作，则中间必须插入fseek函数调用。 5.3 setbuf(stdout, buf); 可以强制将buf指向的char数组设为缓冲区，改变输出缓存大小。 5.3 书中使用缓冲区把stdin的内容复制到stdout的程序是错误的，因为缓冲区内容的写出直到缓冲区满或调用fflush才开始完成。可以把buf声明为静态的或者malloc在堆中，防止main函数结束后buf清空。 5..1 一个程序异常终止时，程序输出的最后一部分常常丢失，可以使用setbuf指向一个空指针作为缓冲区 5..2 putchar/getchar在stdio.h中使用宏实现，如果没有包括stdio.h，很大可能仍能运行，但是使用相应的函数代替，速度降低。 第六章 预处理器 6 宏只是对文本处理，是一个表达式，不是函数或语句 6.1 宏定义最好把每个参数和整个表达式使用括号括起来防止出错。 6.2 如果一个操作数在两个地方用到，将被求值两次。解决方案：操作数应该没有副作用；将宏实现为函数。 6.2 宏可能产生非常庞大的表达式。 6.3 宏的分号的使用很麻烦，assert的一种正确实现： #define assert(e) ((void)((e)||_assert_error(__FILE__,__LINE__))) 6.4 typedef struct foo FOOTYPE 是类型定义语句，定义了一个新的类型。 第七章 可移植性缺陷 7.4 编译器实现可能将字符当作有符号或无符号的。char转换为int时结果未定义，可以使用unsigned char避免。 7.4 将字符变量转换为无符号整数时应该使用 (unsigned char)c 而不是 (unsigned)c ，后者将c转换为int再转换为unsigned int。 7.5 除法运算速度大大慢于移位。 7.7 整数除法运算时，仅规定 商 x 除数 + 余数 == 被除数 ，大多数实现在负数的除法时，只保证余数与被除数正负号相同，商与被除数的符号无关。应尽量使n为无符号数。 7.9 toupper/tolower函数均采用int型参数，实现时要检查输入是否符合要求，采用置位实现非常快速。 7.11 要求一个按位输出long型数字。需要考虑：不能对-n求值，可能溢出（边界条件），应该把n转换为负的再处理；余数的符号未知，应做归一化处理。 7..2 atoi函数把字符串转换为long型整数，应该按照负数来处理以避免溢出。 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/06/20140604c-traps-and-pitfalls.html","loc":"pages/2014/06/20140604c-traps-and-pitfalls.html"},{"title":"20140630Python源码剖析","text":"","tags":"misc","url":"pages/2014/06/20140630pythonyuan-ma-pou-xi.html","loc":"pages/2014/06/20140630pythonyuan-ma-pou-xi.html"},{"title":"20140625程序员的自我修养","text":"第十章 10.1 程序的内存布局 linux下从0xc0000000开始到0xffffffff的1GB空间映射给内核，剩余3GB为用户空间 0x08048000开始为代码区和数据区，即可执行文件。之前为系统保留区，约128MB 可执行文件被映射到计算机内存中，包括只读的.text、.rodata，以及可读写的.data、.bss数据段。其中bss段由于保存的是未初始化的全局变量，在可执行文件中占用空间极少，并在加载程序时初始化为0 动态链接库映射区从0x40000000开始，2.6内核之后已经挪到0xbfxxxxxx附近 堆在可读写区之后，栈在内核空间之前，自高向下增长。堆和栈都可以动态增长 10.2.1 \"烫\"\"屯\"出现的原因 VC调试程序时，未初始化的变量或内存值通常是烫，这是因为debug模式下所有分配的栈空间字节初始化为0xCC，而0xCCCC就是汉字中的\"烫\"。而未初始化的堆内存则全部是0xCD，0xCDCD对应的汉字为\"屯\"。 这些是为了方便调试时判断一个变量是否初始化。 10.2.2 函数调用规范 调用惯例规定了函数的参数传递顺序与方式、栈的维护方、名字修饰策略 C语言默认惯例是cdecl，参数从右至左入栈，函数调用方维护栈，名字修饰为函数名前加一个下划线 初次之外还有stdcall、fastcall、pascal、naked call等惯例 10.2.3 函数返回值 一般使用不超过8字节的数据使用eax与edx寄存器 超过8字节一般在调用方开辟临时空间，被调函数把待返回数据复制到临时空间，再复制到待赋值的变量 对应于C语言中的两次复制，C++返回一个对象时调用两次拷贝构造函数，但ROV可以对此优化 10.3.2 linux进程的堆管理 系统调用开销大，因此对堆空间的管理由运行库申请一大块堆空间后管理分配 linux下brk与mmap系统调用都可以分配堆空间 brk设置进程数据段的结束位置，数据段空间增量就可以用作堆空间，最常用 mmap函数是将内存映射到文件，若不映射文件则称为匿名空间，可作为堆空间，只能是系统页大小（4KB）的整数倍 glibc中的malloc函数以128kB为界，小于此大小在现有堆空间分配，否则使用mmap分配一块内存空间，再在此匿名空间内分配空间 使用mmap实现malloc函数 void *malloc(size_t nbytes) { void * ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0,0); if(ret == MAP_FAILED) return 0; return ret; } 10.3.3 Windows进程的堆管理 win的进程地址空间是很破碎的，每个进程有一个默认1MB的栈 VirtualAlloc与mmap类似可以用于申请堆空间。但堆管理器已经提供了一套API malloc申请的内存在进程结束后不会存在。进程结束后，所有相关资源包括地址空间、物理内存、io都被回收 10.3.4 堆分配算法 获得内存后，需要按需分配给程序，并回收。这就是堆分配算法 空闲链表 将堆中各个空闲块以链表串起，每个空闲块头部的header结构体记录上一个与下一个空闲块地址，并在每个块中保存空间大小 分配时查找到一个满足请求大小的空闲块，分配后将剩余部分添加回链表 优缺点：实现简单，但访问越界时易于被破坏 位图bitmap Memcached的内存管理思想类似 将堆分配为大量大小相同的块，只分配整数个块给用户。使用整数数组来记录块的使用状态，只需要2bit，称为位图 优点：速度快（位图数组连续cache易名字），稳定（备份位图可防止破坏），位图易于管理 缺点：易产生碎片浪费，位图较大时效率低（使用多级位图改善） 对象池 被分配对象大小固定时把堆分为对象大小的块，可使用链表或位图管理，速度快 glibc对于小于128KB的申请按照大小采用不同的分配算法","tags":"misc","url":"pages/2014/06/20140625cheng-xu-yuan-de-zi-wo-xiu-yang.html","loc":"pages/2014/06/20140625cheng-xu-yuan-de-zi-wo-xiu-yang.html"},{"title":"20140624codeforces解初体验","text":"Codeforces印象 这两天抽时间去codeforces体验了一把。 首先，果然有众多大牛存在，很多名人一直参加每周一次的比赛，积分2000+，并参与出题。 另外，上面题目很多，估计至少一千题。比赛结束后，题目将转为练习题，可以持续尝试。每道题目都有标签，如greedy， math， matrices等等，可以点击相应的标签只做相关的题目。可惜我做了好几道之后才发现。 这次解决的题目 首次尝试，这次做的几个都是选的完成人数最多的，比较简单，但还是有些东西是从中新学习到的。以后最好分类练习。 1A Theatre Square 用a x a的砖块去铺满面积m x n的广场，不准破坏砖块，允许超出广场，求砖块数目 分别计算长宽至少多少块即可 小技巧：(m-1)/a+1来计算长度方向的砖块数目 #include <iostream> #include <limits> using namespace std ; int main (){ long long m , n , a ; //cout << numeric_limits<long>::max() << endl; cin >> m >> n >> a ; cout << (( m - 1 ) / a + 1 ) * (( n - 1 ) / a + 1 ) << endl ; return 0 ; } 4A Watermelon 太过简单 158A Next Round 太过简单 71A Way Too Long Words 给定一个单词，如果长度超过10，改成缩写形式：首字母+中间的字母个数+尾字母 直接输出结果即可 118A String Task 给定一个单词，删掉所有元音字母，其余字母转换为小写并每个字母前加.符号 使用ostringstream和tolower函数 #include <iostream> #include <sstream> using namespace std ; int main (){ string str ; cin >> str ; ostringstream ostr ; for ( auto i : str ){ char t = tolower ( i ); if ( t == 'a' || t == 'o' || t == 'y' || t == 'e' || t == 'u' || t == 'i' ) ; else ostr << '.' << t ; } cout << ostr . str () << endl ; return 0 ; } 158B Taxi n个小组，每组不超过4人，出租车每车不能超过4人，同组人不能分开，求最少要多少辆车 贪心，尽量坐满每一辆车，剩下的进行组合 #include <iostream> #include <vector> using namespace std ; int main (){ int n ; cin >> n ; // can't initialize a vector with its element; //vector<int> test(1,2,3,4); vector < int > stat ( 4 , 0 ); for ( int i = 0 ; i < n ; i ++ ){ int tmp ; cin >> tmp ; stat [ tmp - 1 ] += 1 ; } int num_taxi = 0 ; num_taxi += stat [ 3 ]; if ( stat [ 2 ] >= stat [ 0 ]){ num_taxi += stat [ 2 ]; num_taxi += ( stat [ 1 ] + 1 ) / 2 ; } else { num_taxi += stat [ 2 ]; stat [ 0 ] -= stat [ 2 ]; num_taxi += ( stat [ 0 ] + stat [ 1 ] * 2 - 1 ) / 4 + 1 ; } cout << num_taxi << endl ; return 0 ; } 50A Domino piling mxn的广场用2x1的砖块铺满，至少多少块？ 分析m,n在为奇偶的情况下的铺法即可 231A Team 太过简单 116A Tram 太多简单 131A cAPS lOCK 根据特定条件更改字符串中的字母大小写 关键是如何遍历字符串中的字符并更改大小写 for(char &c:s) 可以方便的遍历字符串 cctype头文件中包含了islower,tolower,isupper,toupper等char字符处理函数 #include <iostream> #include <cctype> using namespace std ; bool meet_rule ( string s ) { for ( char & c : s . substr ( 1 )) { if ( islower ( c )) return false ; } return true ; } int main () { string s ; cin >> s ; if ( meet_rule ( s )) { for ( char & c : s ) { if ( true ) { if ( islower ( c )) c = toupper ( c ); else c = tolower ( c ); } } } cout << s << endl ; return 0 ; } 282A Bit++ 太过简单 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点我","tags":"misc","url":"pages/2014/06/20140624codeforcesjie-chu-ti-yan.html","loc":"pages/2014/06/20140624codeforcesjie-chu-ti-yan.html"},{"title":"20140603Memcached","text":"Memcached Memcached是一套分布式的内存对象缓存系统，使用C语言编写，作为数据库的前端cache，缓存数据库查询结果可以减轻数据库负载。 类似一张巨大的hash表，缓存的对象以key-value对的形式存在。 工作流程 检查客户端请求的数据是否在Memcached中存在，若存在直接返回结果 若不存在，查询数据库，返回结果并把结果缓存 每次修改数据库时要同时更新Memcached数据 内存空间用完之后使用LRU算法替换缓存 特点 基于文本行的协议，可以直接通过telnet管理 基于libevent，异步io，高性能。libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能 封装成统一的接口。 对被缓存的数据没有备份，重启后对数据库产生较大的压力 memcached不互相通信的分布式，分布式由客户端完成 工作原理 服务守护进程运行后，客户端连接到服务进程进行操作。目前支持python,c,php等多种客户端。服务进程基于事件的单进程单线程实现。 - 内存管理 内存使用slab分配器分配，这种方案可以减少内存碎片和内存分配释放次数，加快处理速度。服务进程把分配的内存分割成各种固定尺寸的块，根据待缓存数据的大小选择一个最合适大小的块存入。分配的内存不会释放，而是重复利用。 数据大小和块的大小不匹配时会造成内存利用率低下。默认情况下不同大小的块的尺寸以2的增长因子扩大，可以使用'-f'选项调整增长因子。 - 分布式 分布式由客户端实现，客户端根据key来选择不同的memcached服务器。 一般使用hash值mod服务器台数来选择。这样当服务器台数发生变化时会造成大量key对应的服务器改变，短时间内数据库服务器负载非常大。一致性hash可以解决这个问题。 - 一致性hash使用普通的hash将每个key映射到圆环上的一个点，而每个服务器节点也映射到圆环上的一个点。根据key对应的圆环上的点顺时针行进找到的第一个节点即为应保存的位置。 - 对服务器节点hash时很难做到服务器节点在圆环上的均匀分布，可以采用虚拟节点的思想，为每个服务器在圆环上分配100~200个点，做到更均匀的hash。 - 当移除或增加一个服务器节点时，只有此节点对应的key的缓存受到影响。 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点我","tags":"misc","url":"pages/2014/06/20140603memcached.html","loc":"pages/2014/06/20140603memcached.html"},{"title":"20140521git","text":"使用Git完成版本控制 我经常同时保存一个程序或一个文档的不同版本，采取的方式就是文件名上面加上日期。 版本控制在团队开发大型项目中是必须的","tags":"misc","url":"pages/2014/05/20140521git.html","loc":"pages/2014/05/20140521git.html"},{"title":"20140520Ruby on Rails开发Web应用的基本概念","text":"Web应用架构 C/S架构 Web应用从最初就采用C/S架构。Server负责监听客户端请求，提供资源，Client向server发起请求并渲染页面。两者通过TCP/IP协议栈之上的HTTP协议通信。 多层架构 在Web 2.0时代，随着交互性的要求，这个架构变得更为复杂。Server需要提供更复杂的服务，Client也要完成更多的交互任务，涌现出很多新的提供更快更好服务的技术。相应的，C/S架构需要以一种更复杂的方式来组织，即多层架构。 多层架构中的每一层负责提供一个特定的功能，与其他层通过良好的接口进行交互，易于升级维护。原始的C/S架构可以视作Server、Client两层。 3层架构 典型的3层架构为表示层，逻辑层，数据层 - 表示层由浏览器负责渲染 - 逻辑层由服务器端操纵数据，并发往表示层 - 数据层负责存储数据。 6层架构 如果进一步分割，就得到6层架构，如下图 表示层分为Client层和表示逻辑层 Client层负责渲染展示页面 表示逻辑层为Server根据脚本生成网页 逻辑层分为商业逻辑层和数据访问层 事务逻辑层表征事务逻辑和流程 数据访问层负责存取数据，发往事务逻辑层 服务端通常有网络层负责网络 Ruby on Rails Ruby on Rails是一个基于Ruby开发的构建Web应用的开源框架或者开源库，Twitter、Hulu、Github、Iteye等公司都采用了rails 框架。 组件 Ruby on Rails包含一系列组件 - Rake：类似于make，可以用来修改、迁移数据库 - WEBrick:一个Rails内置的HTTP服务器，可以使用rails server命令启动，速度较慢，适合完成开发阶段的测试 - SQLite：最简单的数据库，同样只适合开发阶段的测试 - Rack Middleware：中间件，用于服务器软件和应用之间的交互 缺点 不适合海量服务，Twitter已经由ROR转向Scala 它是一个框架，隐藏了太多细节 MVC架构 Model表示数据，View使用数据渲染页面，而Controller是媒介。View和Model的严格分离保留了重用性。 使用Rails创建应用时会自动按照MVC架构生成相关代码，包括： - 表示Model的一个类，数据库中会建立相应的表 - 一个Controller，相应的URL解析和数据库中的操作会一一对应好 - View包括一系列html文件用来渲染页面 Active Record Active Record机制使object-relational mapping (ORM)变得可行。在Ruby中以ActiveRecord模块的形式出现。ORM映射机制为： - class - table - object - record（表的一行） - attribute - record value（表的一列） ActiveRecord模块提供以下功能： - 与数据库建立连接 - 表的创建 - ORM映射 - 使用object完成CRUD操作(Create、Read、Update、Delete) 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/05/20140520ruby-on-railskai-fa-webying-yong-de-ji-ben-gai-nian.html","loc":"pages/2014/05/20140520ruby-on-railskai-fa-webying-yong-de-ji-ben-gai-nian.html"},{"title":"20140518C++11新特性","text":"C++11新特性 C++11已经推出三年了（2011），编译器GCC4.7、Clang3.1在2012年已经逐渐完善，VS2013也已经支持相关特性，GCC4.8.1支持全部特性。不过新特性似乎在工业界并未得到太多应用，可能出于兼容性和稳定性的考虑吧。 推出的新特性还是相当的丰富，看下面这张图就知道了。我仅仅在这里提一下相对比较容易应用的部分，包括语法上的一些扩展以及改进，lambda表达式以及正则式等比较复杂，暂且不提。 统一初始化 以往的C++可以使用很多种方法完成初始化，而且传统的构造函数类似于函数声明，不是非常直观。而新标准把数组的初始化方法推广为统一的初始化方法: int i{0}; float f{2.0}; ClassA a{a,'c',\"foo\"}; int i{2.0};//error 这种方法不会造成narrowing，编程风格更为统一。 类型推导 引入auto和decltype关键字。auto可以根据表达式或函数返回值在编译阶段得到正确的类型。而decltype可以在编译时确定一个表达式的类型。 vector < int > v ; // vector < int > :: const_iterator i = v . begin (); auto i = v . begin () decltype ( i ) t = i ; 可以看到可以减少代码工作量。 另外，用于模版编程可以很好的用于模版编程： template<class T1, class T2> auto f(T1 a, T2 b){ return a + b; } 基于范围的for循环 结合auto使用，可以很方便的对数组或各种容器完成遍历： for(auto & i:array) { i*=2; } 成员变量默认初始化 在定义类的时候完成成员变量的默认初始化，如： class A{ int c = 10; } 智能指针shared_ptr 可以自动完成指针的托管，离开作用域时自动delete。使用方法如下： # include < memory > int * p1 ; shared_ptr < int > ptr ( p1 ); 注意：对同一个指针只能用来初始化至多一个shared_ptr，否则在离开作用域时会造成delete指针多次报错。 nullptr nullptr表示空指针，其\"==\"是经过重载的，主要是为了消除\"NULL\"的歧义性。两个不同类型的指针不能判断是否相等，即使他们都是nullptr。 int * p = NULL; float * np = nullptr; np == NULL;//true; np == p;//false 右值引用 右值引用可以有效的减少深拷贝的次数。右值一般指无法取地址的表达式，实质为在表达式结束后就不存在的临时对象，使用右值引用时要注意这一点，因为这个右值可能被更改。 比如：a++是右值，而++a为左值。 某需要深拷贝的类型右值赋值给一个变量或作为函数返回值时通常会调用复制构造函数，RVO（返回值优化）在避免复制构造上面并不够好。 但我们可以给此类型定义move构造函数和move赋值函数，这样显示的使用move函数把一个变量转变为右值后，就可以调用move构造/赋值函数减少开销。 int && i = 1 ; // 定义了一个右值引用 class A { public : A ( A && a ); // move构造函数 A & operator = ( A && a ); // move赋值函数 }； A a , b ; a = move ( b ); // 调用 move赋值函数 A c ( move ( b )); // 调用 move构造函数 // 但是 b已经作为右值被使用了 ，可能已经被改变，错误的用法！ 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/05/20140518c11xin-te-xing.html","loc":"pages/2014/05/20140518c11xin-te-xing.html"},{"title":"20140429主定理","text":"主定理 主定理最早出现在《算法导论》中，提供了分治方法带来的递归表达式的渐近复杂度分析。 规模为n的问题通过分治，得到a个规模为n/b的问题，每次递归带来的额外计算为c(n&#94;d) T(n) <= aT(n/b)+c(n&#94;d) 那么就可以得到问题的复杂度为： T(n) = O(n&#94;d log(n)), if a = b&#94;d T(n) = O(n&#94;d ), if a < b&#94;d T(n) = O(n&#94;logb(a))), if a > b&#94;d 证明方法 本来使用主定理是可以免去画递归树的，但为了证明主定理，还是需要画树。 可见，每次递归把问题分为a个规模为n/b的子问题。从根节点开始，共有logb(n)+1层，叶子节点数为a&#94;(logb(n))。 那么，第j层共有a&#94;j个子问题，每个问题规模为n/b&#94;j，每个子问题运算量为c*(n/b&#94;j)&#94;d需要完成的计算量为： 求和得到整个问题的运算量： 那么，根据a与b&#94;d的关系，很容易得到主定理。 应用 二分搜索 每次问题规模减半，a=1，b=2，d=0 复杂度为n&#94;0 log(n) = log(n)。 快速排序 随机选择待排序序列中的一个数字作为划分字问题的标准，划分是否平均影响算法复杂度 每次问题规模减半，a=2，b=2，d=1 复杂度为n&#94;2 log(n) 最差情况下，复杂度为O(n&#94;2) 归并排序 数据列均分为两部分，分别排序，之后以O(n)的复杂度进行合并，空间复杂度O(n) 每次问题规模减半，a=2，b=2，d=1 复杂度为n log(n) 基数排序(Radix sort) 对于待排序的整数序列，从最低位到最高位每次按照相应的位排序一次 每次递归问题规模变为原来的1/10，但需要求解10个子问题，额外运算为O(n)的，a=10，b=10，d=1 复杂度为n&#94;1 log(n) = n log(n)，近似为O(kN)，k为整数的位数 快速傅里叶变换：FFT 每次问题规模减半，a=2，b=2，d=1 复杂度为n log(n) Karatsuba快速乘法 正常两个n位数乘法为n&#94;2 算法把两个乘数各分为高低位两部分，如X*Y = (a+b) * (c+d) = ac+bd + (bc+ad) = ac+bd+(ac+bd - (a-b)(c-d)) 只需要ac,bd,(a-b)(c-d)三次乘法 每次问题规模减半，但需要解3个子问题，加法是O(n)的，a=3，b=2，d=1 复杂度为n&#94;log2(3) 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk ，原文链接为点击打开","tags":"misc","url":"pages/2014/04/20140429zhu-ding-li.html","loc":"pages/2014/04/20140429zhu-ding-li.html"},{"title":"20140422Map_reduce","text":"Map-Reduce Map-Reduce是由Google在2004年提出的大数据并行编程架构，分为Map（映射）和Reduce（化简）两个步骤，因此得名。它隐藏并行化、容错、数据分布、负载均衡等细节，可以搭建在普通PC上，程序员可以很方便完成大数据并行编程。 并行运算的效率 假如使用1个处理器花费T1时长可以完成任务，而使用了p个处理器需要Tp时长。那么加速比为：S(Speeup) = T1/Tp，效率为：E = S/p = T1 / (p Tp) 一般效率都小于1，而且p越大效率越低，但是在数据集增大时，效率会相应的有所提高。 传统的并行处理架构 数据并行架构：共享内存-分割任务 内存（数据）是共享的，把任务分为p个部分，分别由p个处理器完成。为防止冲突，每个处理器都要在开始工作时对使用的数据段加锁，以阻塞其他任务使用这一数据段。任务完成之后，才会解锁。 很显然，如果p个处理器同时对不同的数据段进行处理，效率是很高的。但如果有冲突，就会带来额外的通信开销，降低效率。 消息传递架构：消息传递-分割数据 如MPI和PVM。 消息传递机制把数据分为p个数据段，p个CPU分别使用一个数据段完成同样的任务。 这种方式的问题是，一个CPU的运算需要使用另一个CPU的运算结果以完成下一步的任务，这样，它们之间就需要交换数据。 这个问题使得消息传递架构比数据并行架构更复杂。但消息传递架构更具有可扩展性，比如在数千个CPU的情况下，减少冲突是很难做到的。 除了上述两种方式外，共享内存-分割数据和消息传递-分割任务也是可以的。 Map-Reduce架构 Map-Reduce是一种抽象的消息传递，及数据并行化的架构。 如图所示，左方为代处理数据集，右方为处理结果数据集。图中圆角矩形代表map和reduce节点，每个对应一台电脑。 Map函数把输入数据中的一个key/value对（k1,v1）映射为一组临时key/value对（k2,v2）。每个key/value对都是被独立操作的，而且没有修改原始数据，因此Map操作是可以高度并行的，如图示map1、map2……mapM。 Reduce函数接收键为特定的k2的一组临时key/value对，并合并这些结果得到最终结果（k2,v3），这里键值k2是不变的。如图示reduce1，reduce2……reduceR。相对来说实现并行要难一些。 除了这两个函数之外，还需要做一些额外工作。 每个Reduce节点只接收键固定的临时key/value对，平台要根据临时key/value对的键把key/value对送至相应的Reduce节点。 临时key/value对的读写工作量也相当大。 Word counting Word counting指的是给出一系列文档，统计所有单词的词频。Word counting就是Map-Reduce的Hello word!。 输入数据：（k1,v1），k1是文档id，v1是文档内容，即图中的(d1,\"w1w2w4\")，d1代表文档id，w1代表一个单词 Map函数：从文档中每读入一个单词，就产生一个临时key/value对，即图中左边一列灰色宽箭头 临时元素：（k2,v2），k2是单词，v2是单词出现次数，即图中的第二列(w1,2) Reduce函数：接收所有具有同一个k2的临时key/value对，对v2求和得到v3，即图中右边一列灰色宽箭头 输出结果：（k2,v3），v3是所有文档中单词k2的词频数 转载请注明作者：Focustc，博客地址为 http://blog.csdn.net/caozhk","tags":"misc","url":"pages/2014/04/20140422map_reduce.html","loc":"pages/2014/04/20140422map_reduce.html"},{"title":"django开发视频网站项目记录","text":"20131108启动 下载了Owntube，尝试运行。官方文档给出的运行方式是virtualenv，一个虚拟的python环境。我索性直接在系统环境内安装了相关的软件。django版本真的比较低。 在settings.py中很多变量需要配置，根据官方给出的 文档 ： 使用django.contrib.staticfiles应用，默认配置包含的 AppDirectoriesFinder 会搜索所有已经安装的应用的 static/ 子目录。 并且对于一些不适合放进相关app的文件， STATICFILES_DIRS 是默认的搜索路径。不过这些只适用本地开发，并且要安装FileSystemFinder应用。 这些文件会以 STATIC_URL 提供。 这个服务只在DEBUG为True时，即本地开发时有效。发布网站时，要使用 ./manage.py collectstatic 命令来搜集所有STATICFILES_DIRS路径以及app下的静态文件到STATIC_ROOT文件夹下面。 os.path.dirname(__file__) 可以输出当前路径。 当前配置为： STATIC_ROOT = '/home/czk/djangoproject/OwnTube/colect_staitic/' STATIC_URL = '/static/' import os PROJECT_PATH = os.path.abspath(os.path.dirname( file )) STATICFILES_DIRS = ( PROJECT_PATH + '/static', ) 下一步开发计划： 完成一个最简单的视频播放模板，从html文件开始，然后再做模板。 20131109 初步搞定 之前的 projekktor 并没有用上。 现在的方案是： 文件上传根目录 MEDIA_ROOT = '/home/czk/djangoproject/uvideo/media/' static目录下为css等文件，并包括上传的视频，这样就能够用目录+file_path的方式获得视频链接 STATICFILES_DIRS = ( '/home/czk/djangoproject/uvideo/static/', '/home/czk/djangoproject/uvideo/media/', ) 完成了在管理界面整套试卷的视频上传，以及播放。 下一步计划 部署到学校服务器上面，加入flash播放器。 部署到Apache+wsgi服务器上面要做的改变 安装好apache2和libapache2-mod-wsgi之后 首先settings.py里面，DATABASES的NAME要改成绝对路径 修改/etc/apache2/httpd.conf LoadModule wsgi_module modules/mod_wsgi.so WSGIScriptAlias / \"/home/czk/djangoproject/uvideo/django.wsgi\" Alias /static /home/czk/djangoproject/uvideo/colect_static/ Order Deny,Allow Allow from all 目录下建立django.wsgi，写入内容： #!/usr/bin/env python import os import sys sys.path.append('/home/czk/djangoproject/uvideo') os.environ['DJANGO_SETTINGS_MODULE'] = 'uvideo.settings' import django.core.handlers.wsgi application = django.core.handlers.wsgi.WSGIHandler() deploy过程中碰到python-lib目录权限的问题，更改了所有相应文件的权限才解决。 碰到admin应用无法读取数据库文件的问题，把整个项目文件权限更改为777得到解决。 这次是把所有的文件搜集到了colect_static下面，应该把STATIC_ROOT设置为和MEDIA_ROOT相同。 本来在local开发模式下面，视频是无法快进的，但没想到deploy之后就可以了。 目前视频的播放还是存在问题的，opera无法播放，可能还是需要加入一个flash播放器。 在admin界面下上传文件会显示ascii编码错误，这个需要更改 /etc/apache2/envvars 中的 LANG 设置。具体情况见 博客1 和 博客2 . 不过，这个问题另一个解决办法可能是更改上传的文件名为英文，见 博文 。","tags":"App","url":"pages/2013/11/djangokai-fa-shi-pin-wang-zhan-xiang-mu-ji-lu.html","loc":"pages/2013/11/djangokai-fa-shi-pin-wang-zhan-xiang-mu-ji-lu.html"},{"title":"Ubuntu系统安装Matlab2012a","text":"下载安装 下载matlab的安装镜像，注意一定是unix版本到。 挂载iso文件： sudo mount -o loop Mathworks.Matlab.R2012a.UNIX.iso /mnt/tmp 到tmp目录下面执行 sudo ./install ，安装并激活 启动程序 运行matlab的方式为： sudo /usr/local/MATLAB/R2012a/bin/matlab 运行的时候的警告信息， /usr/local/MATLAB/R2012a/bin/util/oscheck.sh: /lib/libc.so.6: not found 。需要创建一个链接解决: sudo ln -s /lib/i386-linux-gnu/libc.so.6 /lib/libc.so.6 64位系统需要改动。 在软件中心安装matlab-support，添加matlab的安装目录为/usr/local/MATLAB/R2012a，这样可以在面板里面直接运行程序。 11.如果要创建快捷方式，可以在 启动运行程序 中添加 gksudo '/usr/local/MATLAB/R2012a/bin/matlab -desktop' ，然后拖动到文件夹。 设置启动目录 可以使用命令： sudo gedit /usr/local/MATLAB/R2012a/toolbox/local/matlabrc.m ，最后加上: cd ‘default path' %default path 换成你默认目录即可。 解决中文乱码问题 参考 http://wmyming01.blog.163.com/blog/static/12964879120121120102253573/ 关于中文乱码的问题：如果系统已经安装中文字体，则打开Matlab后去File->Preferences>Fonts里设置Desktop code font 和Desktop text font为支持中文的字体，如WenQuanYi Micro Hei Mono，立即生效。如果系统没中文字体就安装。此时Matlab界面仍是英文，添加自定义工具箱目录时遇到中文乱码问题，可以使用ln -s 源目录 目标目录 命令创建软链接，暂时解决。 此时m文件中的中文注释可能乱码，暂时没找到解决方案，因为中文注释是在windows下用写的，编码有差别。以后注释尽量用英文，在中文编码上时间消耗太多了。 解决运行时java错误 改变.matlab目录所有者即可： chown -R user:user ./.matlab","tags":"App","url":"pages/2013/09/ubuntuxi-tong-an-zhuang-matlab2012a.html","loc":"pages/2013/09/ubuntuxi-tong-an-zhuang-matlab2012a.html"},{"title":"Project Euler 001-006 解法总结","text":"Problem 1 Find the sum of all the multiples of 3 or 5 below 1000. 题目要求找出所有1000以下的3或者5的倍数之和。 最简便的方法是，计算出1000以下总共有多少个3、5、15的倍数，然后用等差数列求三种数分别之和，最后3、5的倍数和减去15的倍数和就得到了结果。 NOte：这是因为15的倍数多算了一遍，所以要减去。 Problem 2 Find the sum of all the even-valued terms in the Fibonacci sequence which do not exceed four million. 题目要求找出斐波那契数列中偶数之和。 我的方法是，斐波那契数列每三个连续的数中有一个为偶数，计算斐波那契数时用一个长度为3的数据完成缓存，每次循环完成三个数的更新，即计算三次斐波那契数，取偶数位相加即可。 最简便的方法是，既然没三个连续数就有一个为偶数，那个可以推出连续的三个偶数斐波那契数之间的关系，这样就可以用长度为2的数据完成计算，而且计算量减少很多。 Problem 3 Find the largest prime factor of a composite number 题目要求找出一个数的最大质因子。 我的方法是，首先除以所有为2的质因子，然后从3到sqrt(n)依次找出质因子。排序得到最大的，应该用遍历法得到。过程中参考了CSDN的一篇剪枝的方法（回退法除以所有同一个质因子）。 Problem 4 Find the largest palindrome made from the product of two 3-digit numbers. 题目要求找出能分解为两个三位数相乘的最大回文数。 我的方法是，判断是否为回文数把每一位都提取出来，看前后是否相等。然后按照因此从999到100遍历啊和b的乘积判断是否为回文数，避免重复。找到第一个回文数后，计算出还有可能的a、b是多少，然后再次遍历。最后对遍历的结果取最大值。 最简便的方法是，在上述方法的基础上，经过分析知道这个回文数一定是11的倍数，因为11是质数，则a或b必须为质数。在遍历时，可以判断出a不是11的倍数时b的可能值范围变成原来的1/11，运算量大大减少。 Problem 5 What is the smallest number divisible by each of the numbers 1 to 20? 题目要求找出1~20的最小公倍数。 我的方法是首先用费马方法实现最大公因子gcd的计算。然后从大到小依次计算前者最小公倍数与下一个数的最小公因子，然后得到所有数的最小公倍数。 最简单的方法是，对这个公倍数进行分析，必然是小于k的一系列质数的乘积。如果知道质数表，那么对于每一个小于k的质数为底计算floor(log)，然后把所有这些质数的幂相乘就得到了最小公倍数。可以优化的一点是，对于大于sqrt(k)的质数，已经不可能为1次以上的幂了，直接设幂指数为1即可。 Problem 6 What is the di erence between the sum of the squares and the square of the sums? 题目要求算出和的平方与平方和的差。 我的方法就是直接算，因为没有想到一种方法可以减少运算量。 最简便的方式，是把求和用高斯的方法计算，即n*(n+1)/2，同样的，最好能得到平方和的计算公式。其实计算方法也很简单，假设为三次多项式，用前四个值（含0）来解出系数。也可以参考百度百科平方和的排列组合法。","tags":"Competition","url":"pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html","loc":"pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html"},{"title":"国外大学生谈经验：如何在Github参与开源（Open Source on Github: Your First Contribution）","text":"原作者：spencerpmoran 转载自 http://spencermoran.me/2013/08/13/open-source-on-github-your-first-contribution/ 我是一个即将毕业的计算机大四学生，我经常听人谈论对github上的开源项目做出贡献是多么有意义的事情。许多职位要求里面都写明这种经历是一个很重要的基本条件或加分项，而且这种事情经常在各种seminar课程和活动中提到。做出贡献确实挺起来很酷，我也应该做啊。可唯一的问题是，我是一个大菜鸟。我的计算机课程学的很好，而且我做过几个被家人同学称赞的项目。可是，我确信我不可能对一个真正有用户的项目做出任何有意义的贡献，对吧？这种想法是正确的吗？ 大错特错！即使你是一名新手，也可以以很多方式对github上面的项目做出实质的贡献。如果想要做一些真正有意义的影响用户的贡献，你大可不必读懂所有项目代码或者知道如何解决类似于bootstrap里的动态窗格问题。对于每个人都有合适的做出贡献的方法。 最近，我的第一个实质性的贡献在一个开源项目上完成了。尽管贡献很小，我获得了全新的成就感，因为你知道有人在用你参与完成的东西。你必须从非常小的项目开始并持续前进。下面是我对想要对github上开源项目做出贡献但感觉困难而不敢尝试的同学的建议： 你要做的第一步就是找到一个有pull request的仓库（项目）。有很多种方式可以找到。最简单直接的办法是读仓库的readme文件，里面经常明确的写明仓库所有者希望有人来完成pull request。如果readme文件没有提到这一点，你可以看看问题然后把代码下载下来。检查一下pull request的日期，看看哪些pull request已经关闭，你就能判断仓库所有者有多大的可能还在更新它。如果你能找到一个你真正喜欢并符合上述要求的项目，你就喜出望外吧。举个我自己的例子，我找到了一个用于创建新工程的rails模版项目，它的readme文件用黑体标出了欢迎pull request。太棒了！ 现在，是时候fork并克隆仓库开工了。如果你还不知道具体怎么操作，下面是一个很好的入门教程。 按照readme里面说明，你要先确保你在你的电脑上可以正确的配置运行这个项目。如果你碰到了任何没有在readme里面提到的错误或问题，这将成为你的第一个贡献！你可要编辑readme文件把这个问题向其他开发者说清楚。最好的开始贡献的方式之一是使它们更方便运行。你可以整理readme，编辑文档里面的错误或把错误标出来。一头扎进别人的代码库立刻开始改写代码是有点太不礼貌了。不过你可以以温和的方式开始你的开源生涯。我愿意参与改进的代码库都是文档完整简洁的。 如果你仍然没有找到一种做贡献的方式，就通读这个项目的所有issues吧。Issue是关于增加功能或修改的建议，有时候已经有人给出了伪代码甚至已经有人开始码代码，只是时间紧无法完成而已。你也许能找到这种已经开始的、不需要大量改变的任务。 如果你感觉无法完成任何一处错误的纠正，仓库所有者也许已经在readme文件中写明了下一步要完成的部分，或者你自己有新的想法。我本身而言已经厌倦了到处浏览检查仓库，甚至是我自己的仓库也不愿意。DS_Store目录被使用Mac的人提交到了github上，这是毫无道理的。我可以把它加到rails模版项目的.gitignore文件里面，这样就保证没人会再干出这种事情。哈哈，我已经有贡献了！你看我只是做了很简单的事情而已。你要确认你遵循了项目已有的约定。查看readme和其他的pull request，找出别人的编程习惯，然后要保证你使用了大家约定的commit说明。我按照上述的教程提交了一个pull request，代码如下： # DS_Store gets added to project if viewedin OSX Finder run\"echo '.DS_Store' >> .gitignore\" 一个小时之后，我的pull request已经被合并到了这个几百人同时关注的项目中了。我感到了一种全新的工作的目标和动力。他们在用我参与完成的东西啊！ 在我作为一个计算机专业本科生的生活里，始终缺乏一种实实在在的成就感，或者说，我希望证明我真的在做事情。我学过算法、数据结构、很多种编程语言，我无休止的编程。我清楚的知道我自己。但是不过我从来没有过一种我的成果影响了其他人的感觉。我总是一个人想，谁做了这件事情？这件事情影响了谁？今天晚上，我想知道我的工作对一些人很重要。 对github上的开源项目做贡献尽管可能显得不礼貌，而且有一个很陡峭的学习曲线，然而它确实是一种很有意义的获得成就感的途径。","tags":"Coding","url":"pages/2013/08/guo-wai-da-xue-sheng-tan-jing-yan-ru-he-zai-githubcan-yu-kai-yuan-open-source-on-github-your-first-contribution.html","loc":"pages/2013/08/guo-wai-da-xue-sheng-tan-jing-yan-ru-he-zai-githubcan-yu-kai-yuan-open-source-on-github-your-first-contribution.html"},{"title":"My first git blog","text":"How to build you blog on github name.github.io Github offer everyone a site:name.github.io, where you can publish you blogs. Use git to publish A very good startup: frantic1048's startup Improve:google anylytics,sitemap,disqus Lizherui's blog How to use images and robots.txt Very nice: linuxzen's blog About mine I edited the makefile, the order make publish will use pelicanconf.py. Every time i run pelican, all in the output folder are copyed to git folder. I used a free domain name http://caozhk.tk ,everyone can imply one. Enjoy How to make a social link with imag Seems the plugin determine it by the url you typein ,not the sitename. But for rss, this works: SOCIAL = (('Rss', 'feeds/all.rss.xml'),) Still puzzled by how to add a weibo icon, and a favicon. How to add weibo icon and a favicon, modifed 2013-08-27 Thanks to Lizherui. You just put favicon.png in the output folder using FILES_TO_COPY . Edit /usr/local/lib/python2.7/site-packages/pelican/themes/tuxlite_tbs/static/local.css by insert .social a[href*='weibo.com']:before {content: url('./images/icons/weibo.png'); margin-right: 2px; vertical-align: -3px;} , and put weibo.png in the img folder. How to use Markdown Wikipedia: http://zh.wikipedia.org/wiki/Markdown Hum,this is my pelican.conf. Feel free to share. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals AUTHOR = u 'heLomaN' SITENAME = u 'Focus' SITEURL = 'http://heloman.github.io' RELATIVE_URLS = True DELETE_OUTPUT_DIRECTORY = True TIMEZONE = 'Asia/Shanghai' DEFAULT_LANG = u 'zh' DEFAULT_DATE_FORMAT = '%Y-%m- %d ' # Blogroll LINKS = (( 'Pelican' , 'http://getpelican.com/' ), ( 'Python.org' , 'http://python.org/' ),) # Social widget SOCIAL = (( 'Weibo' , 'http://weibo.com/focustc' ), ( 'Github' , 'https://github.com/heloman' ), ( 'CSDN Blog' , 'http://blog.csdn.net/caozhk' ), ( 'Rss' , 'feeds/all.rss.xml' ),) DEFAULT_PAGINATION = 10 ## 主题 disqus帐号和google anylytics帐号 THEME = 'tuxlite_tbs' DISQUS_SITENAME = 'focustc' GOOGLE_ANALYTICS = 'UA-43314222-1' ##URL test GITHUB_URL = 'https://github.com/heloman' ARCHIVES_URL = 'archives.html' ARTICLE_URL = 'pages/{date:%Y}/{date:%m}/ {slug} .html' ARTICLE_SAVE_AS = 'pages/{date:%Y}/{date:%m}/ {slug} .html' ## 配置RSS robots.txt IMG文件夹 FEED_RSS = 'feeds/all.rss.xml' CATEGORY_FEED_RSS = 'feeds/ %s .rss.xml' FILES_TO_COPY = ( ( \"extra/robots.txt\" , \"robots.txt\" ), ( 'extra/favicon.ico' , 'favicon.ico' ),) STATIC_PATHS = [ u \"img\" ] ## 配置sitemap 插件 PLUGIN_PATH = u \"pelican-plugins\" PLUGINS = [ \"sitemap\" ] SITEMAP = { \"format\" : \"xml\" , \"priorities\" : { \"articles\" : 0.7 , \"indexes\" : 0.5 , \"pages\" : 0.3 , }, \"changefreqs\" : { \"articles\" : \"monthly\" , \"indexes\" : \"daily\" , \"pages\" : \"monthly\" , } }","tags":"Web","url":"pages/2013/08/my-first-git-blog.html","loc":"pages/2013/08/my-first-git-blog.html"}]};