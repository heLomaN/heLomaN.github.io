<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Focus</title><link>http://heloman.github.io/</link><description></description><atom:link href="http://heloman.github.io/feeds/algorithm.rss.xml" rel="self"></atom:link><lastBuildDate>Tue, 29 Apr 2014 00:00:00 +0800</lastBuildDate><item><title>主定理的证明及应用举例</title><link>http://heloman.github.io/pages/2014/04/zhu-ding-li-de-zheng-ming-ji-ying-yong-ju-li.html</link><description>&lt;h2&gt;主定理&lt;/h2&gt;
&lt;p&gt;主定理最早出现在《算法导论》中，提供了分治方法带来的递归表达式的渐近复杂度分析。&lt;br /&gt;
规模为n的问题通过分治，得到a个规模为n/b的问题，每次递归带来的额外计算为c(n^d)&lt;br /&gt;
&lt;strong&gt;T(n) &amp;lt;= aT(n/b)+c(n^d)&lt;/strong&gt;&lt;br /&gt;
那么就可以得到问题的复杂度为：&lt;br /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^d log(n)), if a = b^d&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^d ), if a &amp;lt; b^d&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^logb(a))), if a &amp;gt; b^d&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;证明方法&lt;/h2&gt;
&lt;p&gt;本来使用主定理是可以免去画递归树的，但为了证明主定理，还是需要画树。&lt;br /&gt;
&lt;img alt="" src="img/20140429主定理.png" /&gt;&lt;br /&gt;
可见，每次递归把问题分为a个规模为n/b的子问题。从根节点开始，共有logb(n)+1层，叶子节点数为a^(logb(n))。
那么，第j层共有a^j个子问题，每个问题规模为n/b^j，每个子问题运算量为c*(n/b^j)^d需要完成的计算量为：&lt;br /&gt;
&lt;img alt="" src="img/20140429主定理每层.png" /&gt;&lt;br /&gt;
求和得到整个问题的运算量：&lt;br /&gt;
&lt;img alt="" src="img/20140429主定理所有层.png" /&gt;&lt;br /&gt;
那么，根据a与b^d的关系，很容易得到主定理。&lt;/p&gt;
&lt;h2&gt;应用&lt;/h2&gt;
&lt;h3&gt;二分搜索&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每次问题规模减半，a=1，b=2，d=0&lt;/li&gt;
&lt;li&gt;复杂度为n^0 log(n) = log(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;快速排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随机选择待排序序列中的一个数字作为划分字问题的标准，划分是否平均影响算法复杂度&lt;/li&gt;
&lt;li&gt;每次问题规模减半，a=2，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n^2 log(n)&lt;/li&gt;
&lt;li&gt;最差情况下，复杂度为O(n^2)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;归并排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据列均分为两部分，分别排序，之后以O(n)的复杂度进行合并，空间复杂度O(n)&lt;/li&gt;
&lt;li&gt;每次问题规模减半，a=2，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n log(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基数排序(Radix sort)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于待排序的整数序列，从最低位到最高位每次按照相应的位排序一次&lt;/li&gt;
&lt;li&gt;每次递归问题规模变为原来的1/10，但需要求解10个子问题，额外运算为O(n)的，a=10，b=10，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n^1 log(n) = n log(n)，近似为O(kN)，k为整数的位数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;快速傅里叶变换：FFT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每次问题规模减半，a=2，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n log(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Karatsuba快速乘法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正常两个n位数乘法为n^2&lt;/li&gt;
&lt;li&gt;算法把两个乘数各分为高低位两部分，如X*Y = (a+b) * (c+d) = ac+bd + (bc+ad) = ac+bd+(ac+bd - (a-b)(c-d)) &lt;/li&gt;
&lt;li&gt;只需要ac,bd,(a-b)(c-d)三次乘法&lt;/li&gt;
&lt;li&gt;每次问题规模减半，但需要解3个子问题，加法是O(n)的，a=3，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n^log2(3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;转载请注明作者：Focustc，博客地址为&lt;a href="http://blog.csdn.net/caozhk"&gt;http://blog.csdn.net/caozhk&lt;/a&gt;，原文链接为点击打开&lt;/center&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 29 Apr 2014 00:00:00 +0800</pubDate><guid>tag:heloman.github.io,2014-04-29:pages/2014/04/zhu-ding-li-de-zheng-ming-ji-ying-yong-ju-li.html</guid><category>Master Theory</category><category>分治</category></item></channel></rss>