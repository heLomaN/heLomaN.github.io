<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Focus</title><link href="http://heloman.github.io/" rel="alternate"></link><link href="http://heloman.github.io/feeds/all.atom.xml" rel="self"></link><id>http://heloman.github.io/</id><updated>2014-06-03T00:00:00+08:00</updated><entry><title>Memcached概述</title><link href="http://heloman.github.io/pages/2014/06/memcachedgai-shu.html" rel="alternate"></link><updated>2014-06-03T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2014-06-03:pages/2014/06/memcachedgai-shu.html</id><summary type="html">&lt;h1&gt;Memcached&lt;/h1&gt;
&lt;p&gt;Memcached是一套分布式的内存对象缓存系统，使用C语言编写，作为数据库的前端cache，缓存数据库查询结果可以减轻数据库负载。
类似一张巨大的hash表，缓存的对象以key-value对的形式存在。&lt;/p&gt;
&lt;h2&gt;工作流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;检查客户端请求的数据是否在Memcached中存在，若存在直接返回结果&lt;/li&gt;
&lt;li&gt;若不存在，查询数据库，返回结果并把结果缓存&lt;/li&gt;
&lt;li&gt;每次修改数据库时要同时更新Memcached数据&lt;/li&gt;
&lt;li&gt;内存空间用完之后使用LRU算法替换缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基于文本行的协议，可以直接通过telnet管理&lt;/li&gt;
&lt;li&gt;基于libevent，异步io，高性能。libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能 封装成统一的接口。&lt;/li&gt;
&lt;li&gt;对被缓存的数据没有备份，重启后对数据库产生较大的压力&lt;/li&gt;
&lt;li&gt;memcached不互相通信的分布式，分布式由客户端完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;工作原理&lt;/h2&gt;
&lt;p&gt;服务守护进程运行后，客户端连接到服务进程进行操作。目前支持python,c,php等多种客户端。服务进程基于事件的单进程单线程实现。&lt;br /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理&lt;br /&gt;
内存使用slab分配器分配，这种方案可以减少内存碎片和内存分配释放次数，加快处理速度。服务进程把分配的内存分割成各种固定尺寸的块，根据待缓存数据的大小选择一个最合适大小的块存入。分配的内存不会释放，而是重复利用。
数据大小和块的大小不匹配时会造成内存利用率低下。默认情况下不同大小的块的尺寸以2的增长因子扩大，可以使用'-f'选项调整增长因子。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;分布式
分布式由客户端实现，客户端根据key来选择不同的memcached服务器。
一般使用hash值mod服务器台数来选择。这样当服务器台数发生变化时会造成大量key对应的服务器改变，短时间内数据库服务器负载非常大。一致性hash可以解决这个问题。&lt;ul&gt;
&lt;li&gt;一致性hash使用普通的hash将每个key映射到圆环上的一个点，而每个服务器节点也映射到圆环上的一个点。根据key对应的圆环上的点顺时针行进找到的第一个节点即为应保存的位置。&lt;/li&gt;
&lt;li&gt;对服务器节点hash时很难做到服务器节点在圆环上的均匀分布，可以采用虚拟节点的思想，为每个服务器在圆环上分配100~200个点，做到更均匀的hash。&lt;/li&gt;
&lt;li&gt;当移除或增加一个服务器节点时，只有此节点对应的key的缓存受到影响。
　
　&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="memcached"></category><category term="server"></category><category term="数据库"></category></entry><entry><title>Ruby on Rails开发Web应用的基本概念</title><link href="http://heloman.github.io/pages/2014/05/ruby-on-railskai-fa-webying-yong-de-ji-ben-gai-nian.html" rel="alternate"></link><updated>2014-05-20T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2014-05-20:pages/2014/05/ruby-on-railskai-fa-webying-yong-de-ji-ben-gai-nian.html</id><summary type="html">&lt;h2&gt;Web应用架构&lt;/h2&gt;
&lt;h3&gt;C/S架构&lt;/h3&gt;
&lt;p&gt;Web应用从最初就采用C/S架构。Server负责监听客户端请求，提供资源，Client向server发起请求并渲染页面。两者通过TCP/IP协议栈之上的HTTP协议通信。&lt;/p&gt;
&lt;h3&gt;多层架构&lt;/h3&gt;
&lt;p&gt;在Web 2.0时代，随着交互性的要求，这个架构变得更为复杂。Server需要提供更复杂的服务，Client也要完成更多的交互任务，涌现出很多新的提供更快更好服务的技术。相应的，C/S架构需要以一种更复杂的方式来组织，即多层架构。
多层架构中的每一层负责提供一个特定的功能，与其他层通过良好的接口进行交互，易于升级维护。原始的C/S架构可以视作Server、Client两层。&lt;/p&gt;
&lt;h4&gt;3层架构&lt;/h4&gt;
&lt;p&gt;典型的3层架构为表示层，逻辑层，数据层
- 表示层由浏览器负责渲染
- 逻辑层由服务器端操纵数据，并发往表示层
- 数据层负责存储数据。&lt;/p&gt;
&lt;h4&gt;6层架构&lt;/h4&gt;
&lt;p&gt;如果进一步分割，就得到6层架构，如下图&lt;br /&gt;
&lt;img alt="" src="img/20140520architechure.JPG" /&gt;&lt;br /&gt;
- 表示层分为Client层和表示逻辑层
  - Client层负责渲染展示页面
  - 表示逻辑层为Server根据脚本生成网页
- 逻辑层分为商业逻辑层和数据访问层
  - 事务逻辑层表征事务逻辑和流程
  - 数据访问层负责存取数据，发往事务逻辑层 
- 服务端通常有网络层负责网络&lt;/p&gt;
&lt;h2&gt;Ruby on Rails&lt;/h2&gt;
&lt;p&gt;Ruby on Rails是一个基于Ruby开发的构建Web应用的开源框架或者开源库，Twitter、Hulu、Github、Iteye等公司都采用了rails
框架。&lt;/p&gt;
&lt;h3&gt;组件&lt;/h3&gt;
&lt;p&gt;Ruby on Rails包含一系列组件
- Rake：类似于make，可以用来修改、迁移数据库
- WEBrick:一个Rails内置的HTTP服务器，可以使用rails server命令启动，速度较慢，适合完成开发阶段的测试
- SQLite：最简单的数据库，同样只适合开发阶段的测试
- Rack Middleware：中间件，用于服务器软件和应用之间的交互&lt;/p&gt;
&lt;h3&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不适合海量服务，Twitter已经由ROR转向Scala&lt;/li&gt;
&lt;li&gt;它是一个框架，隐藏了太多细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MVC架构&lt;/h3&gt;
&lt;p&gt;Model表示数据，View使用数据渲染页面，而Controller是媒介。View和Model的严格分离保留了重用性。&lt;br /&gt;
&lt;img alt="" src="img/20140520mvc-diagram.jpg" /&gt; 
使用Rails创建应用时会自动按照MVC架构生成相关代码，包括：
- 表示Model的一个类，数据库中会建立相应的表
- 一个Controller，相应的URL解析和数据库中的操作会一一对应好
- View包括一系列html文件用来渲染页面&lt;/p&gt;
&lt;h3&gt;Active Record&lt;/h3&gt;
&lt;p&gt;Active Record机制使object-relational mapping (ORM)变得可行。在Ruby中以ActiveRecord模块的形式出现。ORM映射机制为：
- class - table
- object - record（表的一行）
- attribute - record value（表的一列）&lt;/p&gt;
&lt;p&gt;ActiveRecord模块提供以下功能：
- 与数据库建立连接
- 表的创建
- ORM映射
- 使用object完成CRUD操作(Create、Read、Update、Delete)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;转载请注明作者：Focustc，博客地址为&lt;a href="http://blog.csdn.net/caozhk"&gt;http://blog.csdn.net/caozhk&lt;/a&gt;，原文链接为点击打开&lt;/center&gt;&lt;/p&gt;</summary><category term="Ruby"></category><category term="Rails"></category><category term="HTTP"></category><category term="C/S"></category></entry><entry><title>C++11新特性</title><link href="http://heloman.github.io/pages/2014/05/c11xin-te-xing.html" rel="alternate"></link><updated>2014-05-18T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2014-05-18:pages/2014/05/c11xin-te-xing.html</id><summary type="html">&lt;h1&gt;C++11新特性&lt;/h1&gt;
&lt;p&gt;C++11已经推出三年了（2011），编译器GCC4.7、Clang3.1在2012年已经逐渐完善，VS2013也已经支持相关特性，GCC4.8.1支持全部特性。不过新特性似乎在工业界并未得到太多应用，可能出于兼容性和稳定性的考虑吧。
推出的新特性还是相当的丰富，看下面这张图就知道了。我仅仅在这里提一下相对比较容易应用的部分，包括语法上的一些扩展以及改进，lambda表达式以及正则式等比较复杂，暂且不提。&lt;br /&gt;
&lt;img alt="" src="img/20140518c++11.png" /&gt; &lt;/p&gt;
&lt;h2&gt;统一初始化&lt;/h2&gt;
&lt;p&gt;以往的C++可以使用很多种方法完成初始化，而且传统的构造函数类似于函数声明，不是非常直观。而新标准把数组的初始化方法推广为统一的初始化方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;ClassA&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="c1"&gt;//error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方法不会造成narrowing，编程风格更为统一。&lt;/p&gt;
&lt;h2&gt;类型推导&lt;/h2&gt;
&lt;p&gt;引入auto和decltype关键字。auto可以根据表达式或函数返回值在编译阶段得到正确的类型。而decltype可以在编译时确定一个表达式的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//vector&amp;lt;int&amp;gt;::const_iterator i = v.begin();&lt;/span&gt;
&lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;v.begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nx"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到可以减少代码工作量。
另外，用于模版编程可以很好的用于模版编程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T2&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;基于范围的for循环&lt;/h2&gt;
&lt;p&gt;结合auto使用，可以很方便的对数组或各种容器完成遍历：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;成员变量默认初始化&lt;/h2&gt;
&lt;p&gt;在定义类的时候完成成员变量的默认初始化，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;智能指针shared_ptr&lt;/h2&gt;
&lt;p&gt;可以自动完成指针的托管，离开作用域时自动delete。使用方法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：对同一个指针只能用来初始化至多一个shared_ptr，否则在离开作用域时会造成delete指针多次报错。&lt;/p&gt;
&lt;h2&gt;nullptr&lt;/h2&gt;
&lt;p&gt;nullptr表示空指针，其“==”是经过重载的，主要是为了消除“NULL”的歧义性。两个不同类型的指针不能判断是否相等，即使他们都是nullptr。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;np&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//true;&lt;/span&gt;
&lt;span class="n"&gt;np&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//false &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;右值引用&lt;/h2&gt;
&lt;p&gt;右值引用可以有效的减少深拷贝的次数。右值一般指无法取地址的表达式，实质为在表达式结束后就不存在的临时对象，使用右值引用时要注意这一点，因为这个右值可能被更改。
比如：a++是右值，而++a为左值。
某需要深拷贝的类型右值赋值给一个变量或作为函数返回值时通常会调用复制构造函数，RVO（返回值优化）在避免复制构造上面并不够好。
但我们可以给此类型定义move构造函数和move赋值函数，这样显示的使用move函数把一个变量转变为右值后，就可以调用move构造/赋值函数减少开销。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//定义了一个右值引用&lt;/span&gt;

&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//move构造函数&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//move赋值函数&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;；&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//调用move赋值函数&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="nf"&gt;c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="c1"&gt;//调用move构造函数 &lt;/span&gt;
&lt;span class="c1"&gt;//但是b已经作为右值被使用了，可能已经被改变，错误的用法！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;转载请注明作者：Focustc，博客地址为&lt;a href="http://blog.csdn.net/caozhk"&gt;http://blog.csdn.net/caozhk&lt;/a&gt;，原文链接为点击打开&lt;/center&gt;&lt;/p&gt;</summary><category term="C++11"></category><category term="autoptr"></category></entry><entry><title>主定理的证明及应用举例</title><link href="http://heloman.github.io/pages/2014/04/zhu-ding-li-de-zheng-ming-ji-ying-yong-ju-li.html" rel="alternate"></link><updated>2014-04-29T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2014-04-29:pages/2014/04/zhu-ding-li-de-zheng-ming-ji-ying-yong-ju-li.html</id><summary type="html">&lt;h2&gt;主定理&lt;/h2&gt;
&lt;p&gt;主定理最早出现在《算法导论》中，提供了分治方法带来的递归表达式的渐近复杂度分析。&lt;br /&gt;
规模为n的问题通过分治，得到a个规模为n/b的问题，每次递归带来的额外计算为c(n^d)&lt;br /&gt;
&lt;strong&gt;T(n) &amp;lt;= aT(n/b)+c(n^d)&lt;/strong&gt;&lt;br /&gt;
那么就可以得到问题的复杂度为：&lt;br /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^d log(n)), if a = b^d&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^d ), if a &amp;lt; b^d&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^logb(a))), if a &amp;gt; b^d&lt;/strong&gt;&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;证明方法&lt;/h2&gt;
&lt;p&gt;本来使用主定理是可以免去画递归树的，但为了证明主定理，还是需要画树。&lt;br /&gt;
&lt;img alt="" src="img/20140429主定理.png" /&gt;&lt;br /&gt;
可见，每次递归把问题分为a个规模为n/b的子问题。从根节点开始，共有logb(n)+1层，叶子节点数为a^(logb(n))。
那么，第j层共有a^j个子问题，每个问题规模为n/b^j，每个子问题运算量为c*(n/b^j)^d需要完成的计算量为：&lt;br /&gt;
&lt;img alt="" src="img/20140429主定理每层.png" /&gt;&lt;br /&gt;
求和得到整个问题的运算量：&lt;br /&gt;
&lt;img alt="" src="img/20140429主定理所有层.png" /&gt;&lt;br /&gt;
那么，根据a与b^d的关系，很容易得到主定理。&lt;/p&gt;
&lt;h2&gt;应用&lt;/h2&gt;
&lt;h3&gt;二分搜索&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每次问题规模减半，a=1，b=2，d=0&lt;/li&gt;
&lt;li&gt;复杂度为n^0 log(n) = log(n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;快速排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随机选择待排序序列中的一个数字作为划分字问题的标准，划分是否平均影响算法复杂度&lt;/li&gt;
&lt;li&gt;每次问题规模减半，a=2，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n^2 log(n)&lt;/li&gt;
&lt;li&gt;最差情况下，复杂度为O(n^2)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;归并排序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据列均分为两部分，分别排序，之后以O(n)的复杂度进行合并，空间复杂度O(n)&lt;/li&gt;
&lt;li&gt;每次问题规模减半，a=2，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n log(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基数排序(Radix sort)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于待排序的整数序列，从最低位到最高位每次按照相应的位排序一次&lt;/li&gt;
&lt;li&gt;每次递归问题规模变为原来的1/10，但需要求解10个子问题，额外运算为O(n)的，a=10，b=10，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n^1 log(n) = n log(n)，近似为O(kN)，k为整数的位数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;快速傅里叶变换：FFT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每次问题规模减半，a=2，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n log(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Karatsuba快速乘法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正常两个n位数乘法为n^2&lt;/li&gt;
&lt;li&gt;算法把两个乘数各分为高低位两部分，如X*Y = (a+b) * (c+d) = ac+bd + (bc+ad) = ac+bd+(ac+bd - (a-b)(c-d)) &lt;/li&gt;
&lt;li&gt;只需要ac,bd,(a-b)(c-d)三次乘法&lt;/li&gt;
&lt;li&gt;每次问题规模减半，但需要解3个子问题，加法是O(n)的，a=3，b=2，d=1&lt;/li&gt;
&lt;li&gt;复杂度为n^log2(3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;转载请注明作者：Focustc，博客地址为&lt;a href="http://blog.csdn.net/caozhk"&gt;http://blog.csdn.net/caozhk&lt;/a&gt;，原文链接为点击打开&lt;/center&gt;&lt;/p&gt;</summary><category term="Master Theory"></category><category term="分治"></category></entry><entry><title>Map-Reduce原理</title><link href="http://heloman.github.io/pages/2014/04/map-reduceyuan-li.html" rel="alternate"></link><updated>2014-04-22T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2014-04-22:pages/2014/04/map-reduceyuan-li.html</id><summary type="html">&lt;h1&gt;Map-Reduce&lt;/h1&gt;
&lt;p&gt;Map-Reduce是由Google在2004年提出的大数据并行编程架构，分为Map（映射）和Reduce（化简）两个步骤，因此得名。它隐藏并行化、容错、数据分布、负载均衡等细节，可以搭建在普通PC上，程序员可以很方便完成大数据并行编程。&lt;/p&gt;
&lt;h2&gt;并行运算的效率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;假如使用1个处理器花费T1时长可以完成任务，而使用了p个处理器需要Tp时长。那么加速比为：S(Speeup) = T1/Tp，效率为：E = S/p = T1 / (p Tp) &lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;一般效率都小于1，而且p越大效率越低，但是在数据集增大时，效率会相应的有所提高。&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;传统的并行处理架构&lt;/h2&gt;
&lt;h3&gt;数据并行架构：共享内存-分割任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;内存（数据）是共享的，把任务分为p个部分，分别由p个处理器完成。为防止冲突，每个处理器都要在开始工作时对使用的数据段加锁，以阻塞其他任务使用这一数据段。任务完成之后，才会解锁。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;很显然，如果p个处理器同时对不同的数据段进行处理，效率是很高的。但如果有冲突，就会带来额外的通信开销，降低效率。&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;消息传递架构：消息传递-分割数据&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如MPI和PVM。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;消息传递机制把数据分为p个数据段，p个CPU分别使用一个数据段完成同样的任务。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;这种方式的问题是，一个CPU的运算需要使用另一个CPU的运算结果以完成下一步的任务，这样，它们之间就需要交换数据。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;这个问题使得消息传递架构比数据并行架构更复杂。但消息传递架构更具有可扩展性，比如在数千个CPU的情况下，减少冲突是很难做到的。&lt;br /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;除了上述两种方式外，共享内存-分割数据和消息传递-分割任务也是可以的。&lt;br /&gt;
&lt;/p&gt;
&lt;h2&gt;Map-Reduce架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Map-Reduce是一种抽象的消息传递，及数据并行化的架构。&lt;br /&gt;
&lt;img alt="" src="img/20140422map_reduce.png" /&gt;&lt;/li&gt;
&lt;li&gt;如图所示，左方为代处理数据集，右方为处理结果数据集。图中圆角矩形代表map和reduce节点，每个对应一台电脑。  &lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;Map函数把输入数据中的一个key/value对（k1,v1）映射为一组临时key/value对（k2,v2）。每个key/value对都是被独立操作的，而且没有修改原始数据，因此Map操作是可以高度并行的，如图示map1、map2……mapM。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;Reduce函数接收键为特定的k2的一组临时key/value对，并合并这些结果得到最终结果（k2,v3），这里键值k2是不变的。如图示reduce1，reduce2……reduceR。相对来说实现并行要难一些。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;除了这两个函数之外，还需要做一些额外工作。&lt;ul&gt;
&lt;li&gt;每个Reduce节点只接收键固定的临时key/value对，平台要根据临时key/value对的键把key/value对送至相应的Reduce节点。&lt;/li&gt;
&lt;li&gt;临时key/value对的读写工作量也相当大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Word counting&lt;/h2&gt;
&lt;p&gt;Word counting指的是给出一系列文档，统计所有单词的词频。Word counting就是Map-Reduce的Hello word!。&lt;br /&gt;
&lt;img alt="" src="img/20140422map_reduce_word_count.png" /&gt;&lt;br /&gt;
- 输入数据：（k1,v1），k1是文档id，v1是文档内容，即图中的(d1,"w1w2w4")，d1代表文档id，w1代表一个单词&lt;br /&gt;
- Map函数：从文档中每读入一个单词，就产生一个临时key/value对，即图中左边一列灰色宽箭头&lt;br /&gt;
- 临时元素：（k2,v2），k2是单词，v2是单词出现次数，即图中的第二列(w1,2)&lt;br /&gt;
- Reduce函数：接收所有具有同一个k2的临时key/value对，对v2求和得到v3，即图中右边一列灰色宽箭头
- 输出结果：（k2,v3），v3是所有文档中单词k2的词频数&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;center&gt;转载请注明作者：Focustc，博客地址为&lt;a href="http://blog.csdn.net/caozhk"&gt;http://blog.csdn.net/caozhk&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;</summary><category term="big data"></category></entry><entry><title>django开发视频网站项目记录</title><link href="http://heloman.github.io/pages/2013/11/djangokai-fa-shi-pin-wang-zhan-xiang-mu-ji-lu.html" rel="alternate"></link><updated>2013-11-08T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2013-11-08:pages/2013/11/djangokai-fa-shi-pin-wang-zhan-xiang-mu-ji-lu.html</id><summary type="html">&lt;h3&gt;20131108启动&lt;/h3&gt;
&lt;p&gt;下载了Owntube，尝试运行。官方文档给出的运行方式是virtualenv，一个虚拟的python环境。我索性直接在系统环境内安装了相关的软件。django版本真的比较低。&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;在settings.py中很多变量需要配置，根据官方给出的&lt;a href="https://docs.djangoproject.com/en/1.3/howto/static-files/"&gt;文档&lt;/a&gt;：&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;使用django.contrib.staticfiles应用，默认配置包含的 AppDirectoriesFinder 会搜索所有已经安装的应用的 &lt;code&gt;static/&lt;/code&gt; 子目录。 &lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;并且对于一些不适合放进相关app的文件， &lt;code&gt;STATICFILES_DIRS&lt;/code&gt;是默认的搜索路径。不过这些只适用本地开发，并且要安装FileSystemFinder应用。&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;这些文件会以 &lt;code&gt;STATIC_URL&lt;/code&gt; 提供。&lt;/p&gt;
&lt;p&gt;这个服务只在DEBUG为True时，即本地开发时有效。发布网站时，要使用 &lt;code&gt;./manage.py collectstatic&lt;/code&gt; 命令来搜集所有STATICFILES_DIRS路径以及app下的静态文件到STATIC_ROOT文件夹下面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;os.path.dirname(__file__)&lt;/code&gt; 可以输出当前路径。&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;当前配置为：&lt;br /&gt;
    STATIC_ROOT = '/home/czk/djangoproject/OwnTube/colect_staitic/'
    STATIC_URL = '/static/'
    import os
    PROJECT_PATH = os.path.abspath(os.path.dirname(&lt;strong&gt;file&lt;/strong&gt;))
    STATICFILES_DIRS = (
        PROJECT_PATH + '/static',
    )&lt;/p&gt;
&lt;h4&gt;下一步开发计划：&lt;/h4&gt;
&lt;p&gt;完成一个最简单的视频播放模板，从html文件开始，然后再做模板。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;20131109 初步搞定&lt;/h3&gt;
&lt;p&gt;之前的&lt;a href="http://www.projekktor.com/"&gt;projekktor&lt;/a&gt;并没有用上。&lt;br /&gt;
现在的方案是： &lt;br /&gt;
    文件上传根目录
    MEDIA_ROOT = '/home/czk/djangoproject/uvideo/media/'
    static目录下为css等文件，并包括上传的视频，这样就能够用目录+file_path的方式获得视频链接
    STATICFILES_DIRS = (
        '/home/czk/djangoproject/uvideo/static/',
        '/home/czk/djangoproject/uvideo/media/',
    )&lt;/p&gt;
&lt;p&gt;完成了在管理界面整套试卷的视频上传，以及播放。&lt;/p&gt;
&lt;h4&gt;下一步计划&lt;/h4&gt;
&lt;p&gt;部署到学校服务器上面，加入flash播放器。&lt;br /&gt;
&lt;/p&gt;
&lt;h4&gt;部署到Apache+wsgi服务器上面要做的改变&lt;/h4&gt;
&lt;p&gt;安装好apache2和libapache2-mod-wsgi之后&lt;br /&gt;
首先settings.py里面，DATABASES的NAME要改成绝对路径&lt;br /&gt;
修改/etc/apache2/httpd.conf&lt;br /&gt;
    LoadModule wsgi_module modules/mod_wsgi.so
    WSGIScriptAlias / "/home/czk/djangoproject/uvideo/django.wsgi"
    Alias /static /home/czk/djangoproject/uvideo/colect_static/
    &lt;Directory "/home/czk/djangoproject/uvideo/"&gt;
        Order Deny,Allow
        Allow from all
    &lt;/Directory&gt;&lt;/p&gt;
&lt;p&gt;目录下建立django.wsgi，写入内容：
    #!/usr/bin/env python
    import os
    import sys
    sys.path.append('/home/czk/djangoproject/uvideo')
    os.environ['DJANGO_SETTINGS_MODULE'] = 'uvideo.settings'
    import django.core.handlers.wsgi
    application = django.core.handlers.wsgi.WSGIHandler()&lt;/p&gt;
&lt;p&gt;deploy过程中碰到python-lib目录权限的问题，更改了所有相应文件的权限才解决。&lt;br /&gt;
碰到admin应用无法读取数据库文件的问题，把整个项目文件权限更改为777得到解决。&lt;br /&gt;
这次是把所有的文件搜集到了colect_static下面，应该把STATIC_ROOT设置为和MEDIA_ROOT相同。&lt;br /&gt;
本来在local开发模式下面，视频是无法快进的，但没想到deploy之后就可以了。&lt;br /&gt;
目前视频的播放还是存在问题的，opera无法播放，可能还是需要加入一个flash播放器。&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;在admin界面下上传文件会显示ascii编码错误，这个需要更改 /etc/apache2/envvars 中的 LANG 设置。具体情况见&lt;a href="http://www.hiaward.com:10004/wiki/dev/ApacheConfigure/"&gt;博客1&lt;/a&gt;和&lt;a href="http://hi.baidu.com/justin_jia/item/cda58f5f866ef2464eff20a3"&gt;博客2&lt;/a&gt;.&lt;br /&gt;
不过，这个问题另一个解决办法可能是更改上传的文件名为英文，见&lt;a href="http://blog.csdn.net/jianhong1990/article/details/7382873"&gt;博文&lt;/a&gt;。&lt;br /&gt;
&lt;/p&gt;</summary><category term="django"></category></entry><entry><title>Ubuntu系统安装Matlab2012a</title><link href="http://heloman.github.io/pages/2013/09/ubuntuxi-tong-an-zhuang-matlab2012a.html" rel="alternate"></link><updated>2013-09-04T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2013-09-04:pages/2013/09/ubuntuxi-tong-an-zhuang-matlab2012a.html</id><summary type="html">&lt;h3&gt;下载安装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载matlab的安装镜像，注意一定是unix版本到。 &lt;/li&gt;
&lt;li&gt;挂载iso文件： &lt;code&gt;sudo mount -o loop Mathworks.Matlab.R2012a.UNIX.iso /mnt/tmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;到tmp目录下面执行 &lt;code&gt;sudo ./install&lt;/code&gt;，安装并激活&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;启动程序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;运行matlab的方式为：&lt;code&gt;sudo /usr/local/MATLAB/R2012a/bin/matlab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行的时候的警告信息，&lt;code&gt;/usr/local/MATLAB/R2012a/bin/util/oscheck.sh: /lib/libc.so.6: not found&lt;/code&gt;。需要创建一个链接解决:&lt;code&gt;sudo ln -s /lib/i386-linux-gnu/libc.so.6 /lib/libc.so.6&lt;/code&gt;64位系统需要改动。&lt;/li&gt;
&lt;li&gt;在软件中心安装matlab-support，添加matlab的安装目录为/usr/local/MATLAB/R2012a，这样可以在面板里面直接运行程序。
11.如果要创建快捷方式，可以在&lt;code&gt;启动运行程序&lt;/code&gt;中添加 &lt;code&gt;gksudo '/usr/local/MATLAB/R2012a/bin/matlab -desktop'&lt;/code&gt;，然后拖动到文件夹。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;设置启动目录&lt;/h3&gt;
&lt;p&gt;可以使用命令：&lt;code&gt;sudo gedit /usr/local/MATLAB/R2012a/toolbox/local/matlabrc.m&lt;/code&gt;，最后加上:&lt;code&gt;cd ‘default path’ %default path&lt;/code&gt;换成你默认目录即可。&lt;/p&gt;
&lt;h3&gt;解决中文乱码问题&lt;/h3&gt;
&lt;p&gt;参考&lt;a href="http://wmyming01.blog.163.com/blog/static/12964879120121120102253573/"&gt;http://wmyming01.blog.163.com/blog/static/12964879120121120102253573/&lt;/a&gt;
关于中文乱码的问题：如果系统已经安装中文字体，则打开Matlab后去File-&amp;gt;Preferences&amp;gt;Fonts里设置Desktop code font 和Desktop text font为支持中文的字体，如WenQuanYi Micro Hei Mono，立即生效。如果系统没中文字体就安装。此时Matlab界面仍是英文，添加自定义工具箱目录时遇到中文乱码问题，可以使用ln -s  源目录  目标目录  命令创建软链接，暂时解决。
此时m文件中的中文注释可能乱码，暂时没找到解决方案，因为中文注释是在windows下用写的，编码有差别。以后注释尽量用英文，在中文编码上时间消耗太多了。&lt;/p&gt;
&lt;h3&gt;解决运行时java错误&lt;/h3&gt;
&lt;p&gt;改变.matlab目录所有者即可：&lt;code&gt;chown -R user:user ./.matlab&lt;/code&gt;&lt;/p&gt;</summary><category term="ubuntu"></category><category term="matlab"></category></entry><entry><title>Project Euler 001-006 解法总结</title><link href="http://heloman.github.io/pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html" rel="alternate"></link><updated>2013-08-27T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2013-08-27:pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html</id><summary type="html">&lt;h4&gt;Problem 1&lt;/h4&gt;
&lt;p&gt;Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;p&gt;题目要求找出所有1000以下的3或者5的倍数之和。&lt;br /&gt;
最简便的方法是，计算出1000以下总共有多少个3、5、15的倍数，然后用等差数列求三种数分别之和，最后3、5的倍数和减去15的倍数和就得到了结果。&lt;br /&gt;
NOte：这是因为15的倍数多算了一遍，所以要减去。&lt;br /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 2&lt;/h4&gt;
&lt;p&gt;Find the sum of all the even-valued terms in the Fibonacci sequence which do not exceed four million.&lt;/p&gt;
&lt;p&gt;题目要求找出斐波那契数列中偶数之和。&lt;br /&gt;
我的方法是，斐波那契数列每三个连续的数中有一个为偶数，计算斐波那契数时用一个长度为3的数据完成缓存，每次循环完成三个数的更新，即计算三次斐波那契数，取偶数位相加即可。&lt;br /&gt;
最简便的方法是，既然没三个连续数就有一个为偶数，那个可以推出连续的三个偶数斐波那契数之间的关系，这样就可以用长度为2的数据完成计算，而且计算量减少很多。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 3&lt;/h4&gt;
&lt;p&gt;Find the largest prime factor of a composite number&lt;/p&gt;
&lt;p&gt;题目要求找出一个数的最大质因子。&lt;br /&gt;
我的方法是，首先除以所有为2的质因子，然后从3到sqrt(n)依次找出质因子。排序得到最大的，应该用遍历法得到。过程中参考了CSDN的一篇剪枝的方法（回退法除以所有同一个质因子）。&lt;br /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 4&lt;/h4&gt;
&lt;p&gt;Find the largest palindrome made from the product of two 3-digit numbers.&lt;/p&gt;
&lt;p&gt;题目要求找出能分解为两个三位数相乘的最大回文数。&lt;br /&gt;
我的方法是，判断是否为回文数把每一位都提取出来，看前后是否相等。然后按照因此从999到100遍历啊和b的乘积判断是否为回文数，避免重复。找到第一个回文数后，计算出还有可能的a、b是多少，然后再次遍历。最后对遍历的结果取最大值。&lt;br /&gt;
最简便的方法是，在上述方法的基础上，经过分析知道这个回文数一定是11的倍数，因为11是质数，则a或b必须为质数。在遍历时，可以判断出a不是11的倍数时b的可能值范围变成原来的1/11，运算量大大减少。&lt;br /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 5&lt;/h4&gt;
&lt;p&gt;What is the smallest number divisible by each of the numbers 1 to 20?&lt;/p&gt;
&lt;p&gt;题目要求找出1~20的最小公倍数。&lt;br /&gt;
我的方法是首先用费马方法实现最大公因子gcd的计算。然后从大到小依次计算前者最小公倍数与下一个数的最小公因子，然后得到所有数的最小公倍数。&lt;br /&gt;
最简单的方法是，对这个公倍数进行分析，必然是小于k的一系列质数的乘积。如果知道质数表，那么对于每一个小于k的质数为底计算floor(log)，然后把所有这些质数的幂相乘就得到了最小公倍数。可以优化的一点是，对于大于sqrt(k)的质数，已经不可能为1次以上的幂了，直接设幂指数为1即可。&lt;br /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 6&lt;/h4&gt;
&lt;p&gt;What is the di erence between the sum of the squares and the square of the sums?&lt;/p&gt;
&lt;p&gt;题目要求算出和的平方与平方和的差。&lt;br /&gt;
我的方法就是直接算，因为没有想到一种方法可以减少运算量。&lt;br /&gt;
最简便的方式，是把求和用高斯的方法计算，即n*(n+1)/2，同样的，最好能得到平方和的计算公式。其实计算方法也很简单，假设为三次多项式，用前四个值（含0）来解出系数。也可以参考百度百科平方和的排列组合法。&lt;br /&gt;
&lt;/p&gt;</summary><category term="project euler"></category></entry><entry><title>国外大学生谈经验：如何在Github参与开源（Open Source on Github: Your First Contribution）</title><link href="http://heloman.github.io/pages/2013/08/guo-wai-da-xue-sheng-tan-jing-yan-ru-he-zai-githubcan-yu-kai-yuan-open-source-on-github-your-first-contribution.html" rel="alternate"></link><updated>2013-08-25T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2013-08-25:pages/2013/08/guo-wai-da-xue-sheng-tan-jing-yan-ru-he-zai-githubcan-yu-kai-yuan-open-source-on-github-your-first-contribution.html</id><summary type="html">&lt;p&gt;原作者：spencerpmoran&lt;br /&gt;
转载自&lt;a href="http://spencermoran.me/2013/08/13/open-source-on-github-your-first-contribution/"&gt;http://spencermoran.me/2013/08/13/open-source-on-github-your-first-contribution/&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我是一个即将毕业的计算机大四学生，我经常听人谈论对github上的开源项目做出贡献是多么有意义的事情。许多职位要求里面都写明这种经历是一个很重要的基本条件或加分项，而且这种事情经常在各种seminar课程和活动中提到。做出贡献确实挺起来很酷，我也应该做啊。可唯一的问题是，我是一个大菜鸟。我的计算机课程学的很好，而且我做过几个被家人同学称赞的项目。可是，我确信我不可能对一个真正有用户的项目做出任何有意义的贡献，对吧？这种想法是正确的吗？&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;大错特错！即使你是一名新手，也可以以很多方式对github上面的项目做出实质的贡献。如果想要做一些真正有意义的影响用户的贡献，你大可不必读懂所有项目代码或者知道如何解决类似于bootstrap里的动态窗格问题。对于每个人都有合适的做出贡献的方法。&lt;/p&gt;
&lt;p&gt;最近，我的第一个实质性的贡献在一个开源项目上完成了。尽管贡献很小，我获得了全新的成就感，因为你知道有人在用你参与完成的东西。你必须从非常小的项目开始并持续前进。下面是我对想要对github上开源项目做出贡献但感觉困难而不敢尝试的同学的建议：&lt;/p&gt;
&lt;p&gt;你要做的第一步就是找到一个有pull request的仓库（项目）。有很多种方式可以找到。最简单直接的办法是读仓库的readme文件，里面经常明确的写明仓库所有者希望有人来完成pull request。如果readme文件没有提到这一点，你可以看看问题然后把代码下载下来。检查一下pull request的日期，看看哪些pull request已经关闭，你就能判断仓库所有者有多大的可能还在更新它。如果你能找到一个你真正喜欢并符合上述要求的项目，你就喜出望外吧。举个我自己的例子，我找到了一个用于创建新工程的rails模版项目，它的readme文件用黑体标出了欢迎pull request。太棒了！&lt;/p&gt;
&lt;p&gt;现在，是时候fork并克隆仓库开工了。如果你还不知道具体怎么操作，下面是一个很好的入门教程。&lt;/p&gt;
&lt;p&gt;按照readme里面说明，你要先确保你在你的电脑上可以正确的配置运行这个项目。如果你碰到了任何没有在readme里面提到的错误或问题，这将成为你的第一个贡献！你可要编辑readme文件把这个问题向其他开发者说清楚。最好的开始贡献的方式之一是使它们更方便运行。你可以整理readme，编辑文档里面的错误或把错误标出来。一头扎进别人的代码库立刻开始改写代码是有点太不礼貌了。不过你可以以温和的方式开始你的开源生涯。我愿意参与改进的代码库都是文档完整简洁的。&lt;/p&gt;
&lt;p&gt;如果你仍然没有找到一种做贡献的方式，就通读这个项目的所有issues吧。Issue是关于增加功能或修改的建议，有时候已经有人给出了伪代码甚至已经有人开始码代码，只是时间紧无法完成而已。你也许能找到这种已经开始的、不需要大量改变的任务。&lt;/p&gt;
&lt;p&gt;如果你感觉无法完成任何一处错误的纠正，仓库所有者也许已经在readme文件中写明了下一步要完成的部分，或者你自己有新的想法。我本身而言已经厌倦了到处浏览检查仓库，甚至是我自己的仓库也不愿意。DS_Store目录被使用Mac的人提交到了github上，这是毫无道理的。我可以把它加到rails模版项目的.gitignore文件里面，这样就保证没人会再干出这种事情。哈哈，我已经有贡献了！你看我只是做了很简单的事情而已。你要确认你遵循了项目已有的约定。查看readme和其他的pull request，找出别人的编程习惯，然后要保证你使用了大家约定的commit说明。我按照上述的教程提交了一个pull request，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;DS_Store&lt;/span&gt; &lt;span class="n"&gt;gets&lt;/span&gt; &lt;span class="n"&gt;added&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;viewedin&lt;/span&gt; &lt;span class="n"&gt;OSX&lt;/span&gt; &lt;span class="n"&gt;Finder&lt;/span&gt;
    &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;echo &amp;#39;.DS_Store&amp;#39; &amp;gt;&amp;gt; .gitignore&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个小时之后，我的pull request已经被合并到了这个几百人同时关注的项目中了。我感到了一种全新的工作的目标和动力。他们在用我参与完成的东西啊！&lt;/p&gt;
&lt;p&gt;在我作为一个计算机专业本科生的生活里，始终缺乏一种实实在在的成就感，或者说，我希望证明我真的在做事情。我学过算法、数据结构、很多种编程语言，我无休止的编程。我清楚的知道我自己。但是不过我从来没有过一种我的成果影响了其他人的感觉。我总是一个人想，谁做了这件事情？这件事情影响了谁？今天晚上，我想知道我的工作对一些人很重要。&lt;/p&gt;
&lt;p&gt;对github上的开源项目做贡献尽管可能显得不礼貌，而且有一个很陡峭的学习曲线，然而它确实是一种很有意义的获得成就感的途径。&lt;/p&gt;</summary><category term="github"></category><category term="open source"></category><category term="blog"></category><category term="translation"></category></entry><entry><title>My first git blog</title><link href="http://heloman.github.io/pages/2013/08/my-first-git-blog.html" rel="alternate"></link><updated>2013-08-19T00:00:00+08:00</updated><author><name>heLomaN</name></author><id>tag:heloman.github.io,2013-08-19:pages/2013/08/my-first-git-blog.html</id><summary type="html">&lt;h2&gt;How to build you blog on github&lt;/h2&gt;
&lt;h4&gt;name.github.io&lt;/h4&gt;
&lt;p&gt;Github offer everyone a site:name.github.io, where you can publish you blogs.&lt;/p&gt;
&lt;h3&gt;Use git to publish&lt;/h3&gt;
&lt;p&gt;A very good startup:&lt;a href="http://frantic1048.com/blog/bo-ke-dan-sheng-ji-ji-yu-githubpelicanchuang-jian-bo-ke-de-zheng-ge-guo-cheng.html"&gt;frantic1048's startup&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Improve:google anylytics,sitemap,disqus&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.lizherui.com/pages/2013/08/17/build_blog.htm"&gt;Lizherui's blog&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;How to use images and robots.txt&lt;/h3&gt;
&lt;p&gt;Very nice:&lt;a href="http://www.linuxzen.com/shi-yong-pelicanda-zao-jing-tai-bo-ke.html"&gt;linuxzen's blog&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;About mine&lt;/h3&gt;
&lt;p&gt;I edited the makefile, the order &lt;code&gt;make publish&lt;/code&gt; will use pelicanconf.py.
Every time i run pelican, all in the output folder are copyed to git folder.
I used a free domain name &lt;a href="http://caozhk.tk"&gt;http://caozhk.tk&lt;/a&gt;,everyone can imply one. Enjoy&lt;/p&gt;
&lt;h4&gt;How to make a social link with imag&lt;/h4&gt;
&lt;p&gt;Seems the plugin determine it by the url you typein ,not the sitename.
But for rss, this works:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Rss&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;feeds&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rss&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xml&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Still puzzled by how to add a weibo icon, and a favicon.&lt;/p&gt;
&lt;h4&gt;How to add weibo icon and a favicon, modifed 2013-08-27&lt;/h4&gt;
&lt;p&gt;Thanks to Lizherui.&lt;br /&gt;
You just put favicon.png in the output folder using &lt;code&gt;FILES_TO_COPY&lt;/code&gt;.&lt;br /&gt;
Edit &lt;code&gt;/usr/local/lib/python2.7/site-packages/pelican/themes/tuxlite_tbs/static/local.css&lt;/code&gt; by insert &lt;code&gt;.social a[href*='weibo.com']:before {content: url('./images/icons/weibo.png'); margin-right: 2px; vertical-align: -3px;}&lt;/code&gt;, and put weibo.png in the img folder.&lt;br /&gt;
&lt;/p&gt;
&lt;h3&gt;How to use Markdown&lt;/h3&gt;
&lt;p&gt;Wikipedia:&lt;a href="http://zh.wikipedia.org/wiki/Markdown"&gt;http://zh.wikipedia.org/wiki/Markdown&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Hum,this is my pelican.conf.&lt;/h3&gt;
&lt;p&gt;Feel free to share.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8 -*- #&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;

&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;heLomaN&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;Focus&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://heloman.github.io&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;RELATIVE_URLS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;DELETE_OUTPUT_DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;zh&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE_FORMAT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;# Blogroll&lt;/span&gt;
&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Pelican&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://getpelican.com/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Python.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://python.org/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="c"&gt;# Social widget&lt;/span&gt;
&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Weibo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://weibo.com/focustc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/heloman&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;CSDN Blog&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://blog.csdn.net/caozhk&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Rss&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;

&lt;span class="c"&gt;## 主题 disqus帐号和google anylytics帐号&lt;/span&gt;
&lt;span class="n"&gt;THEME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;tuxlite_tbs&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;focustc&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;UA-43314222-1&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;##URL test&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/heloman&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;ARCHIVES_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;archives.html&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;ARTICLE_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;pages/{date:%Y}/{date:%m}/{slug}.html&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;ARTICLE_SAVE_AS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;pages/{date:%Y}/{date:%m}/{slug}.html&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;## 配置RSS robots.txt IMG文件夹&lt;/span&gt;
&lt;span class="n"&gt;FEED_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;CATEGORY_FEED_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;FILES_TO_COPY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;extra/robots.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;robots.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;extra/favicon.ico&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;favicon.ico&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;
&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;img&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;## 配置sitemap 插件&lt;/span&gt;
&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;pelican-plugins&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sitemap&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;SITEMAP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;format&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;priorities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;changefreqs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;daily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><category term="pelican"></category><category term="blog"></category></entry></feed>