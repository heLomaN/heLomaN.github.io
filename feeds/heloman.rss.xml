<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Focus - heLomaN</title><link>http://heloman.github.io/</link><description></description><lastBuildDate>Sat, 30 Jan 2021 20:08:46 +0800</lastBuildDate><item><title>git0710</title><link>http://heloman.github.io/pages/2021/01/git0710.html</link><description>&lt;h1&gt;使用Git完成版本控制&lt;/h1&gt;
&lt;p&gt;我经常同时保存一个程序或一个文档的不同版本，采取的方式就是文件名上面加上日期。
版本控制在团队开发大型项目中是必须的。版本控制系统，可以给程序员自由的修改，很方便的开发多个分支实验新特性，共享代码也很方便。
Git是Linux Torvalds为Linux Kernel编写的版本控制系统，速度快且高效。
有很多版本控制系统，但是相比他们git有以下优点：
- 本地存储，不需要联网，速度快
- 易于学习使用
- 提供staging(缓冲区)，使
- 有github等适合分享的网站&lt;/p&gt;
&lt;h2&gt;git的常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config --global user.name ""&lt;/code&gt; 或者改为 &lt;code&gt;user.email ""&lt;/code&gt;,之后用&lt;code&gt;git config --globa --list&lt;/code&gt;查看&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt; 在当前目录下的.git文件夹内建立一个空仓库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt; 查看当前分支状态，默认的branch是master&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add .&lt;/code&gt; 添加所有文件到仓库 &lt;code&gt;git add …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 30 Jan 2021 20:08:46 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2021-01-30:/pages/2021/01/git0710.html</guid><category>misc</category></item><item><title>20171127移动端阴影渲染</title><link>http://heloman.github.io/pages/2017/11/20171127yi-dong-duan-yin-ying-xuan-ran.html</link><description>&lt;h2&gt;如何在移动端渲染阴影&lt;/h2&gt;
&lt;h3&gt;为啥&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;手机的性能相比PC非常差劲，如何渲染出视觉效果好的阴影是一个大难题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;现有的方案&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如王者荣耀在低配机型，直接在英雄底部贴一张固定的阴影图&lt;ul&gt;
&lt;li&gt;消耗最少，相当于decal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;而王者荣耀在高配机型上，会使用投影阴影&lt;ul&gt;
&lt;li&gt;需要用stencil处理多重阴影&lt;/li&gt;
&lt;li&gt;难以支持投影到平面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shadow map很少被采用，因为手机端浮点纹理支持不够，性能也比较耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;软阴影的实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实时软阴影需要pcf随机采样&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 27 Nov 2017 02:39:48 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2017-11-27:/pages/2017/11/20171127yi-dong-duan-yin-ying-xuan-ran.html</guid><category>misc</category></item><item><title>设计模式</title><link>http://heloman.github.io/pages/2017/06/she-ji-mo-shi.html</link><description>&lt;h1&gt;设计模式的思考&lt;/h1&gt;
&lt;h4&gt;设计模式六大原则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则&lt;ul&gt;
&lt;li&gt;即一个类只负责一项职责，必要时分解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;里氏替换原则&lt;ul&gt;
&lt;li&gt;子类可以扩展父类的功能，但不能改变父类原有的功能，如有必要，添加一个父类子类共同的基类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依赖倒置原则&lt;ul&gt;
&lt;li&gt;高层不依赖低层，也即是高层（父类）定义好接口，低层（子类）实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;ul&gt;
&lt;li&gt;为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;迪米特法则&lt;ul&gt;
&lt;li&gt;一个对象应该对其他对象保持最少的了解。低耦合，高内聚。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开闭原则&lt;ul&gt;
&lt;li&gt;软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;UML类图中常见几种关系&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;泛化（Generalization）&lt;ul&gt;
&lt;li&gt;即继承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依赖(Dependency)&lt;ul&gt;
&lt;li&gt;A使用B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关联（Association)&lt;ul&gt;
&lt;li&gt;B是A的成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聚合（Aggregation）&lt;ul&gt;
&lt;li&gt;一种强关联，A可以包含一个BB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组合(Composition)&lt;ul&gt;
&lt;li&gt;B是A的成员变量，是A的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;23种设计模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;工厂模式 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 09 Jun 2017 03:00:03 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2017-06-09:/pages/2017/06/she-ji-mo-shi.html</guid><category>misc</category></item><item><title>光照渲染路径</title><link>http://heloman.github.io/pages/2017/02/guang-zhao-xuan-ran-lu-jing.html</link><description>&lt;h2&gt;unity shader入门精要&lt;/h2&gt;
&lt;h3&gt;光照渲染路径&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主要方法有如下三种&lt;ul&gt;
&lt;li&gt;顶点照明渲染路径 Vertex Lit Rendering Path&lt;/li&gt;
&lt;li&gt;前向渲染路径 Forward Rendering Path&lt;/li&gt;
&lt;li&gt;延迟光照渲染路径 Deferred Lighting Rendering Path&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Vertex Lit Rendering Path&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;是Forward Rendering Path的一个子集&lt;/li&gt;
&lt;li&gt;所有的光照都是在顶点层级上计算的，此渲染路径不支持大部分的逐像素渲染效果：如，阴影、法线贴图、灯光遮罩、高精度的高光&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Forward Rendering Path&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;影响物体的最亮的几个光源使用逐像素光照模式。接下来，最多有4个点光源会以逐顶点渲染的方式被计算&lt;/li&gt;
&lt;li&gt;N个物体、M个光源就需要N*M次渲染，光源较多时性能会受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Deferred Lighting Rendering Path&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;延迟渲染复杂度仅与屏幕分辨率有关&lt;/li&gt;
&lt;li&gt;延迟渲染需要两个Pass，一个用于填充G Buffer …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 09 Feb 2017 01:04:18 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2017-02-09:/pages/2017/02/guang-zhao-xuan-ran-lu-jing.html</guid><category>misc</category></item><item><title>20160906android_opengl</title><link>http://heloman.github.io/pages/2016/09/20160906android_opengl.html</link><description>&lt;h1&gt;安卓平台OpenGL ES的调用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;开发游戏如果直接使用OpenGL是比较痛苦的，最好的办法是使用封装好的引擎，但很有必要了解在安卓java代码直接调用OpenGL的渲染方法&lt;/li&gt;
&lt;li&gt;固定渲染管线只可通过配置实现不同的效果，而可编程渲染管线通过一般编程的方式实现，可以实现更加灵活的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;OpenGL ES&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OpenGL从3.0开始，而OpenGL ES从2.0开始，支持可编程管线&lt;/li&gt;
&lt;li&gt;下图中橙色两块儿即为可编程部分，而顶点和片段着色器要相互配合好才能发挥最大性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Programmable Pipeline of OpenGL 2.0" src="./android_opengl_pipeline.jpg"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般通用编程模式为写好两个shader的代码，每次运行程序时即时编译运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码框架&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在manifest中声明OpenGL ES &lt;code&gt;&amp;lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在入口Acitvity中需要使用GLSurfaceView作为主视图&lt;/li&gt;
&lt;li&gt;在GLSurfaceView中可以扩展出一些其他函数，需要创建一个GLSurfaceView.Renderer的派生类对象负责显示&lt;/li&gt;
&lt;li&gt;GLSurfaceView.Renderer需要关注三个函数：&lt;ul&gt;
&lt;li&gt;onSurfaceCreated：仅调用一次&lt;/li&gt;
&lt;li&gt;onDrawFrame：每次显示都调用&lt;/li&gt;
&lt;li&gt;onSurfaceChanged：view大小变化时调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3D坐标变换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安卓同样有对应坐标变换的库&lt;code&gt;Matrix&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MVP变换的实际乘法顺序是PVM&lt;/li&gt;
&lt;li&gt;V可以通过&lt;code&gt;setLookAtM&lt;/code&gt;得到&lt;/li&gt;
&lt;li&gt;P则是 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 06 Sep 2016 17:16:26 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-09-06:/pages/2016/09/20160906android_opengl.html</guid><category>misc</category></item><item><title>20160823安卓逆向工程</title><link>http://heloman.github.io/pages/2016/08/20160823an-zhuo-ni-xiang-gong-cheng.html</link><description>&lt;h1&gt;安卓逆向简介&lt;/h1&gt;
&lt;h2&gt;常用逆向方法&lt;/h2&gt;
&lt;h3&gt;Apk文件格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Apk文件其实是一个zip文件，解压之后可以看到其中的目录结构&lt;/li&gt;
&lt;li&gt;AndroidManifest.xml&lt;ul&gt;
&lt;li&gt;已经过编译，包括activity、权限等配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;classes.dex&lt;ul&gt;
&lt;li&gt;java程序生成的.class文件经过打包生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;resources.arsc&lt;ul&gt;
&lt;li&gt;资源文件索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;res&lt;ul&gt;
&lt;li&gt;此文件夹包括布局文件、图片、strings等文件，可以通过R.java引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lib&lt;ul&gt;
&lt;li&gt;用到的第三方库，包括.so文件。.so文件不易破解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;assets&lt;ul&gt;
&lt;li&gt;不经编译的资源文件，可以通过AssetManager类访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;META-INF&lt;ul&gt;
&lt;li&gt;应用签名文件，用于验证apk中的文件没有被修改过&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用dex2jar和jdgui查看java代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先将apk或者apk中的dex文件拖到&lt;code&gt;d2j-dex2jar.bat&lt;/code&gt;上，会得到一个jar文件&lt;/li&gt;
&lt;li&gt;用jdgui打开此jar文件，即可看到java源码&lt;/li&gt;
&lt;li&gt;注意，部分源码无法正确得到&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用apktool反编译和打包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;反编译命令&lt;code&gt;apktool d *.apk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新打包命令 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 23 Aug 2016 21:20:16 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-08-23:/pages/2016/08/20160823an-zhuo-ni-xiang-gong-cheng.html</guid><category>misc</category></item><item><title>python的几个基本问题</title><link>http://heloman.github.io/pages/2016/07/pythonde-ji-ge-ji-ben-wen-ti.html</link><description>&lt;h1&gt;python的几个基本问题&lt;/h1&gt;
&lt;h2&gt;标识符皆引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;所有标识符皆引用，只是指向了一个分配好的对象&lt;/li&gt;
&lt;li&gt;list中存储的也是对元素的引用，dict等容器也是如此&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;is和==&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;is和is not用来检测两个标识符是否指向同一个对象&lt;/li&gt;
&lt;li&gt;==和!=用来检测两个标识符指向的对象的值是否相等&lt;/li&gt;
&lt;li&gt;通常使用后者，仅当需要测试是否同一个对象时才使用前者&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;除法和余数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;m/n = q ---- r&lt;/li&gt;
&lt;li&gt;必有m = n*q + r&lt;/li&gt;
&lt;li&gt;r与n同号，且abs(r) &amp;lt; abs(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数参数传引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;python函数传参数相当于赋值操作，把实参赋值给形参&lt;/li&gt;
&lt;li&gt;返回值也相当于赋值操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用大量检测来保证函数的输入正确是没有必要的，可能花费的代价更高&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 06 Jul 2016 11:09:58 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-07-06:/pages/2016/07/pythonde-ji-ge-ji-ben-wen-ti.html</guid><category>misc</category></item><item><title>20160616vrui</title><link>http://heloman.github.io/pages/2016/06/20160616vrui.html</link><description>&lt;h1&gt;VR游戏的UI设计&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;除了按钮还可以探索其他交互方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fuse按钮&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用一个焦点来指示视线位置，长时间注视来确认点击&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;按钮摆放&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;按钮要足够大，间隔也要足够大&lt;/li&gt;
&lt;li&gt;暴风VR在播放视频时把按钮放到最底下，很不错&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;倒计时按钮&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注视过程中提供一些反馈，如桶被填满、圆环转一圈等效果&lt;/li&gt;
&lt;li&gt;最好提供直接点击的确认方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;按钮辅助&lt;/h3&gt;
&lt;h3&gt;GearVR触摸板+按钮辅助&lt;/h3&gt;
&lt;h2&gt;不能掉帧&lt;/h2&gt;
&lt;h2&gt;头控要考虑可移动范围&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量减少头部移动&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;血条显示位置&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 16 Jun 2016 09:07:32 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-06-16:/pages/2016/06/20160616vrui.html</guid><category>misc</category></item><item><title>20160612安卓按键键码修改</title><link>http://heloman.github.io/pages/2016/06/20160612an-zhuo-an-jian-jian-ma-xiu-gai.html</link><description>&lt;h1&gt;安卓系统按键映射修改&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;谨记录下靠着自己摸索，安卓平板使用时一个bug的解决方案，及修改按钮功能的方法。这个bug目前搜不到解决方案，能独立解决还是很有成就感的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解决反复打开谷歌语音搜索的bug&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;手里一部驰为hi8，是国产双系统平板，在安卓系统下如果插上耳机会自动暂停和播放音乐，并反复打开谷歌搜索&lt;/li&gt;
&lt;li&gt;这个bug目前网上没有找到答案。自己猜测，应该是耳机接口不匹配，相当于一直按着线控耳机上的播放/暂停按钮出现的情况&lt;/li&gt;
&lt;li&gt;安卓系统基于linux，应该有办法修改按键键码的，谷歌知道，/system/usr/keylayout/qwerty.kl中保存了按键配置信息。但打开后看到注释写明此文件已不再使用，新系统采用的是Generic.kl文件中的配置&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开Generic.kl可以看到其中数据全都是如下格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;key 163 MEDIA_NEXT&lt;/span&gt;
&lt;span class="err"&gt;key 164 MEDIA_PLAY_PAUSE&lt;/span&gt;
&lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;key 172 HOME&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很明显，数字就是键码，而后面的大写字母则是对应的功能。遍历整个文件，只有上述提到的164关联了play和pause两个功能，大胆猜测这就是线控耳机的那个按钮。遂注释掉这一行重启平板，果然反复启动谷歌语音搜索的bug不见了，音乐播放器也不会反复自动打开了，当然，如果有需要使用线控耳机也不能用了~&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;屏蔽Win按钮 …&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sun, 12 Jun 2016 22:44:02 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-06-12:/pages/2016/06/20160612an-zhuo-an-jian-jian-ma-xiu-gai.html</guid><category>misc</category></item><item><title>20160606python定时杀进程</title><link>http://heloman.github.io/pages/2016/06/20160606pythonding-shi-sha-jin-cheng.html</link><description>&lt;h1&gt;python定时杀进程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;之前写了个python脚本用selenium+phantomjs爬新帖子，在循环拉取页面的过程中，phantomjs总是block住，使用WebDriverWait设置最长等待时间无效。用firefox替换phantomjs无改善&lt;/li&gt;
&lt;li&gt;因为这个脚本不会长期使用，因此采取临时办法，新开一个子线程固定周期杀死phantomjs进程，这样selenium就会在block最多不超过此周期后返回。当然在爬虫脚本中做一些微调防止部分url被跳过&lt;/li&gt;
&lt;li&gt;定时执行任务采用sched模块，很多人将其与crontab相提并论&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;杀死特定进程的命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kill -9  pid&lt;/code&gt;命令可以无条件终止对应pid进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;获取名为phantomjs的进程pid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ps命令列出进程信息&lt;/li&gt;
&lt;li&gt;grep过滤得指定名字的进程信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;awk '{print $2}'&lt;/code&gt;提取第二列pid信息&lt;/li&gt;
&lt;li&gt;最终命令为：kill -9 `ps -aux|grep phantomjs|awk '{print $2}'`&lt;/li&gt;
&lt;li&gt;python可以用os.system()执行shell命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用sched模块周期执行任务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sched模块使用heapq保存event队列，其event为namedtuple类型&lt;/li&gt;
&lt;li&gt;sched需要提供两个函数，一个用来获取时间变化，一个用于等待一段时间，可自定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基本API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sched.scheduler(time_func …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 06 Jun 2016 15:43:32 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-06-06:/pages/2016/06/20160606pythonding-shi-sha-jin-cheng.html</guid><category>misc</category></item><item><title>20160506unity_camera</title><link>http://heloman.github.io/pages/2016/05/20160506unity_camera.html</link><description>&lt;h1&gt;Unity的camera组件&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文章介绍的是个大概，其中rendering paths和culling、clear flag还有更详细的用法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;正交和透视&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;unity的camera支持两种投影方式：正交和透视&lt;/li&gt;
&lt;li&gt;人眼看到的物体，近处的比较大、远处的比较小，unity的摄像机支持这种透视效果，称为透视相机&lt;/li&gt;
&lt;li&gt;如果不需要物体大小随到摄像机的距离改变，可以采用正交投影&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;可视区域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一般摄像机仅关注一个范围内的物体，垂直于摄像机z轴有两个平面，分别称为远、近裁剪平面，只有两个平面之间的物体才会投影到摄像机&lt;/li&gt;
&lt;li&gt;对于正交投影，可视区域为一个长方体&lt;/li&gt;
&lt;li&gt;对于透视投影，可视区域为一个锥体的一部分，锥体顶端是摄像机，锥体底面为远裁剪面，并被近裁剪面切割掉顶部&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;背景图和天空盒&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在户外场景，投影到2D平面后部分区域是没有任何投影的，这时可以用背景色填充，但更逼真的方法是使用天空盒&lt;/li&gt;
&lt;li&gt;摄像机转动时会看到天空盒的不同位置，但位置始终在天空盒的正中心&lt;/li&gt;
&lt;li&gt;天空盒是由6张图片拼接成的立方体盒子，显示在所有物体之后&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多摄像头切换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果多个摄像头可用，则深度最大的摄像头会显示在最上方，覆盖其他摄像头。可以设置disable完成多个摄像头之间的切换&lt;/li&gt;
&lt;li&gt;使用第二个摄像机显示小地图&lt;ul&gt;
&lt;li&gt;深度调高，以显示在上方&lt;/li&gt;
&lt;li&gt;设置viewport rect，调整占用2D屏幕的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;摄像头射线投影 …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 31 May 2016 12:02:36 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-05-31:/pages/2016/05/20160506unity_camera.html</guid><category>misc</category></item><item><title>20160526python开发环境管理pip和virtualenv</title><link>http://heloman.github.io/pages/2016/05/20160526pythonkai-fa-huan-jing-guan-li-piphe-virtualenv.html</link><description>&lt;h1&gt;python开发环境管理：pip和virtualenv&lt;/h1&gt;
&lt;p&gt;不同的python软件需要不同的开发环境，互相之间甚至可能有冲突，怎么处理？使用pip、virtualenv和virtualenvwrapper可以迅速的搭建、转移开发环境，并隔离冲突。&lt;/p&gt;
&lt;h2&gt;软件包管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pip是easy_install的替代品，distribute是setuptools的替代品&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pip使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用参考文档为：&lt;a href="https://pip.pypa.io/en/latest/user_guide/"&gt;pip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install test&lt;/code&gt;安装test包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip list&lt;/code&gt;列出已经安装的包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install --upgrade test&lt;/code&gt;升级test包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip uninstall test&lt;/code&gt;卸载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install test==4.4&lt;/code&gt;指定版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install test&amp;gt;=4.4&lt;/code&gt;指定最小版本号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt;到处当前python环境的依赖库要求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 26 May 2016 12:12:24 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-05-26:/pages/2016/05/20160526pythonkai-fa-huan-jing-guan-li-piphe-virtualenv.html</guid><category>misc</category></item><item><title>20160523python_json_csv</title><link>http://heloman.github.io/pages/2016/05/20160523python_json_csv.html</link><description>&lt;h1&gt;使用python开发json、csv数据格式转换工具&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;json和xml是业界常用的数据格式，而游戏行业经常使用csv配表，包括本地化文本和数值。本文介绍csv和json序列化、逆序列化相关的python库，以及开发工具常用的命令行解析库--getopt&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;csv模块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;csv文件格式并不统一，存在多种分隔符，而csv模块可以很方便的读写csv文件&lt;/li&gt;
&lt;li&gt;csv.reader&lt;ul&gt;
&lt;li&gt;返回一个reader迭代器，迭代器每次给出一个字符串列表，对应于csv文件中的一行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;csv.writer&lt;ul&gt;
&lt;li&gt;相应的，返回一个writer，调用&lt;code&gt;writerrow([stra,strb,...strc])&lt;/code&gt;可以将数据写入文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;csv.DictReader&lt;ul&gt;
&lt;li&gt;创建一个DictReader类，对比reader迭代器，每次迭代给出一个字典对应一行，参数Reader.fieldnames给出了字典的key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;csv.DictWriter&lt;ul&gt;
&lt;li&gt;类似writer，但输出的是字典&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;json模块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;dump(obj, fp)将对象序列化后写入文件fp，indent选项可格式化json文件&lt;/li&gt;
&lt;li&gt;dumps(obj)返回obj序列化之后的字符串&lt;/li&gt;
&lt;li&gt;load(fp)从文件对象fp中反序列化 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 26 May 2016 11:55:34 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-05-26:/pages/2016/05/20160523python_json_csv.html</guid><category>misc</category></item><item><title>20160516排队论</title><link>http://heloman.github.io/pages/2016/05/20160516pai-dui-lun.html</link><description>&lt;h1&gt;排队论与提单&lt;/h1&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 23 May 2016 11:23:14 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-05-23:/pages/2016/05/20160516pai-dui-lun.html</guid><category>misc</category></item><item><title>20160516unity编辑器扩展</title><link>http://heloman.github.io/pages/2016/05/20160516unitybian-ji-qi-kuo-zhan.html</link><description>&lt;h1&gt;Unity编辑器扩展之EditorWindow&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;继承这个类的编辑器脚本可以用来创建一个编辑器窗口，类似Inspector窗口&lt;/li&gt;
&lt;li&gt;若要在这个类中添加一些控件，可以使用GUI和GUILayout控件，还可以使用编辑器专用控件EditorGUI/EditorGUILayout&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;脚本创建&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在Assets/Editor文件夹下创建脚本，并继承UnityEditor.EditorWindow&lt;/li&gt;
&lt;li&gt;在OnGUI函数中写控件代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;窗口显示的触发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一般使用MenuItem属性创建一个菜单选项，点击后调用此函数显示窗口，如&lt;code&gt;EditorWindow.GetWindow(typeof(MyWindow))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;为窗口添加控件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;上述提到的EditorGUILayout等类中包含类各种控件，比如&lt;code&gt;IntField, IntPopup, IntSlider, Vector2Field, TextField&lt;/code&gt;等等&lt;/li&gt;
&lt;li&gt;将创建这些控件的代码放在OnGUI函数中，则每一次渲染窗口都会执行一次&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;其他功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Update():对于可见窗口，每秒调用100次&lt;/li&gt;
&lt;li&gt;OnDestroy():关闭窗口时调用&lt;/li&gt;
&lt;li&gt;OnFocus():窗口被选中时调用&lt;/li&gt;
&lt;li&gt;OnLostFocus():窗口不再被选中时调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以下为示例，还可参考Unity官方文档EditorWindow部分&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEditor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 16 May 2016 21:01:24 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-05-16:/pages/2016/05/20160516unitybian-ji-qi-kuo-zhan.html</guid><category>misc</category></item><item><title>20160506Unity中的layer和tag</title><link>http://heloman.github.io/pages/2016/05/20160506unityzhong-de-layerhe-tag.html</link><description>&lt;h1&gt;Unity中的layer和tag&lt;/h1&gt;
&lt;p&gt;layer和tag均用于标识不同类别的gameobject，侧重点不同&lt;/p&gt;
&lt;h2&gt;Layer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Unity中默认已经有8种layer，但可以自行设置layer，上限32种，对应于一个int值的32位&lt;/li&gt;
&lt;li&gt;对于场景中的gameobject，均可以设置其layer。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;用于camera&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;layer和camera配合起来，可以达到尽在camera上渲染特定层gameobject的效果&lt;/li&gt;
&lt;li&gt;相机有culling mask属性，也是对应于一个32位int值，如果对应layer的bit为1，则渲染此layer到此摄像机，在inspector界面可以选择多个layer，也可以在代码中设置多个layer的mask，比如&lt;code&gt;camera.cullingMask = 1&amp;lt;&amp;lt;10 + 1&amp;lt;&amp;lt; 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;camera的clipping planes属性有类似的作用，可限制绘制的物体距离范围，仅在范围内的将会被绘制。比如在房间中，紧贴camera的墙可以隐藏掉&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;用于raycast&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;raycast可检测一条射线与gameobject的碰撞，检测时可以定义layermask参数，从而只和这些layer的物体发生碰撞&lt;/li&gt;
&lt;li&gt;做raycast之前，通常要生成一条射线，相应的api为&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ScreenPointToRay&lt;/code&gt; 从摄像机到屏幕坐标的射线&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewportPointToRay&lt;/code&gt; 从摄像机到视口坐标的射线。视口坐标是相对于相机标准化的坐标，左下角为(0,0)，右上角(1 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 06 May 2016 15:32:26 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-05-06:/pages/2016/05/20160506unityzhong-de-layerhe-tag.html</guid><category>misc</category></item><item><title>python新式类和经典类</title><link>http://heloman.github.io/pages/2016/04/pythonxin-shi-lei-he-jing-dian-lei.html</link><description>&lt;h1&gt;python的new style class和classic class&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;新式类是为了统一type和object引进的，旧式类已在python3中移除&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先看一下以下代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;X&lt;/span&gt;:
    &lt;span class="nb"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;(&lt;span class="n"&gt;object&lt;/span&gt;):
    &lt;span class="nb"&gt;pass&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;(&lt;span class="o"&gt;X&lt;/span&gt;), &lt;span class="nb"&gt;type&lt;/span&gt;(&lt;span class="o"&gt;X&lt;/span&gt;())
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;(&lt;span class="n"&gt;Y&lt;/span&gt;), &lt;span class="nb"&gt;type&lt;/span&gt;(&lt;span class="n"&gt;Y&lt;/span&gt;())

&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;(&lt;span class="n"&gt;object&lt;/span&gt;), &lt;span class="n"&gt;object&lt;/span&gt;.&lt;span class="n"&gt;__class__&lt;/span&gt;, &lt;span class="n"&gt;object&lt;/span&gt;.&lt;span class="n"&gt;__base__&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;(&lt;span class="nb"&gt;type&lt;/span&gt;), &lt;span class="nb"&gt;type&lt;/span&gt;.&lt;span class="n"&gt;__class__&lt;/span&gt;, &lt;span class="nb"&gt;type&lt;/span&gt;.&lt;span class="n"&gt;__base__&lt;/span&gt;

&lt;span class="s"&gt;&amp;lt;type &amp;#39;classobj&amp;#39;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;type &amp;#39;instance&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="s"&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;class &amp;#39;__main__.Y&amp;#39;&amp;gt;&lt;/span&gt;
&lt;span class="s"&gt;&amp;lt;type &amp;#39;type&amp;#39;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;type …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 05 Apr 2016 21:19:58 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-04-05:/pages/2016/04/pythonxin-shi-lei-he-jing-dian-lei.html</guid><category>misc</category></item><item><title>20160331python不要使用mutable类型默认参数</title><link>http://heloman.github.io/pages/2016/03/20160331pythonbu-yao-shi-yong-mutablelei-xing-mo-ren-can-shu.html</link><description>&lt;h1&gt;python勿使用mutable值作为默认参数&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先看以下一段代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]):&lt;/span&gt;
    &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func_defaults&lt;/span&gt;

&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;([],)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么返回结果发生了改变？python函数执行时，默认参数只会在def函数时初始化一次，并不会每次运行时都发生改变，以后每次调用都使用同一个默认参数变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;默认参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数的默认参数存放在&lt;code&gt;func_defaults&lt;/code&gt;，调用函数时若没有传入默认参数，则取出&lt;code&gt;func_defaults&lt;/code&gt;中的值赋给此形参&lt;/li&gt;
&lt;li&gt;如果默认值为mutable类型，则为传引用，多次调用时必然出现类似上述的错误&lt;/li&gt;
&lt;li&gt;默认参数不要使用mutable类型，使用immutable类型，如None，更合适&lt;/li&gt;
&lt;li&gt;上述函数正确的实现方式为&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;container …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 31 Mar 2016 21:34:18 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-03-31:/pages/2016/03/20160331pythonbu-yao-shi-yong-mutablelei-xing-mo-ren-can-shu.html</guid><category>misc</category></item><item><title>20160324查看unity的scene流程</title><link>http://heloman.github.io/pages/2016/03/20160324cha-kan-unityde-sceneliu-cheng.html</link><description>&lt;h1&gt;Unity新项目如何快速理清顶层代码结构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;半路上手新项目时弄懂scene切换流程是有必要的，scene切换可以说是unity最上层的代码资源结构&lt;/li&gt;
&lt;li&gt;要再进一步弄清脚本调用顺序的话，就要选择一个参照标准，时刻停下来，看调用入口&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先我们在入口scene（第一个scene）中添加新的GameObject，绑定脚本，每帧打印当前scene的名字，并防止在scene切换时销毁&lt;/li&gt;
&lt;li&gt;根据打印输出的scene名字，在代码中搜索&lt;code&gt;LoadLevel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;LoadLevel&lt;/code&gt;有一个专门的脚本管理器封装，那么查看被调用位置即得知scene切换入口；如果&lt;code&gt;LoadLevel&lt;/code&gt;分布在脚本中，则被调用位置即为切换入口&lt;/li&gt;
&lt;li&gt;找到切换入口之后，从入口scene开始，分别打开每个scene，并运行。查看运行前后Hierarchy中的GameObject变化，即可知道每个scene初始化时做了什么，再查看scene中脚本的awake和start函数&lt;/li&gt;
&lt;li&gt;这样一来，代码的顶层结构即可得到，可根据需要再继续细查每一个功能模块入口。&lt;/li&gt;
&lt;li&gt;查看功能模块逻辑时，可以搜索相应的单词，比如武器系统搜索&lt;code&gt;weapon&lt;/code&gt;。找到相应的脚本，在init部分加入&lt;code&gt;Debug.Break()&lt;/code&gt;，暂停运行，观察scene中的资源。进而在init部分打印一些log，运行时可以直观的看到调用堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码示例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以下是打印当前scene的名字的脚本&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;public …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 25 Mar 2016 11:31:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-03-25:/pages/2016/03/20160324cha-kan-unityde-sceneliu-cheng.html</guid><category>misc</category></item><item><title>20160323unity切换场景</title><link>http://heloman.github.io/pages/2016/03/20160323unityqie-huan-chang-jing.html</link><description>&lt;h1&gt;Unity中的场景切换&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;与电影类似，一个游戏往往需要多个场景。而如果场景中资源较少，那么可以很快的完成切换，如果较多的话，可能需要十几秒时间。在这段时间内播放加载动画等等，可以减少玩家的不耐烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;同步切换场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Application.LoadLevel()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Application.LoadLevelAdditive()&lt;/code&gt;加载完成后保留旧场景中资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;异步切换场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Application.LoadLevelAsync()&lt;/code&gt;异步加载场景，加载过程中当前场景不会卡死。返回值包含加载进度&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;public class test : MonoBehaviour
    {&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;AsyncOperation&lt;/span&gt; &lt;span class="n"&gt;async&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="k"&gt;Start&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;Time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;StartCoroutine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;Switch&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="k"&gt;Update&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;async&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;progress&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;IEnumerator&lt;/span&gt; &lt;span class="n"&gt;Switch&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;async&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Application&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LoadLevelAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;&amp;quot;LoadingScene&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;yield …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 24 Mar 2016 09:58:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-03-24:/pages/2016/03/20160323unityqie-huan-chang-jing.html</guid><category>misc</category></item><item><title>20160314ugui</title><link>http://heloman.github.io/pages/2016/03/20160314ugui.html</link><description>&lt;h1&gt;ugui&lt;/h1&gt;
&lt;h2&gt;Canvas的三种渲染方式&lt;/h2&gt;
&lt;h3&gt;screen space overlay&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UI永远出现在画面最前端&lt;/li&gt;
&lt;li&gt;无需camera和light&lt;/li&gt;
&lt;li&gt;可以自动适配屏幕&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;screen space camera&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以在UI上层显示特效和模型&lt;/li&gt;
&lt;li&gt;显示效果受到相机透视或者正交的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;world space&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把UI视为3D模型&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 15 Mar 2016 01:36:12 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-03-15:/pages/2016/03/20160314ugui.html</guid><category>misc</category></item><item><title>20160314char_pointer</title><link>http://heloman.github.io/pages/2016/03/20160314char_pointer.html</link><description>&lt;h1&gt;&lt;code&gt;char *&lt;/code&gt;和&lt;code&gt;char*&lt;/code&gt;的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;这两种写法编译上面都没有问题，但是在某些情况下会造成歧义&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code&gt;char* p1, p2&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这样的写法声明了指针p1，字符p2&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code&gt;char *p1, *p2&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这样的写法表示声明了两个指向字符的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code&gt;*&lt;/code&gt;是变量的修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*p&lt;/code&gt;表示p是一个指针，是修饰p的，而不是修饰&lt;code&gt;char&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;因此*和p之间不要有空格，否则就会造成误解，误以为&lt;code&gt;char*&lt;/code&gt;是一种数据类型，继而出现上述错误&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 14 Mar 2016 15:28:54 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-03-14:/pages/2016/03/20160314char_pointer.html</guid><category>misc</category></item><item><title>20160229文本编码</title><link>http://heloman.github.io/pages/2016/03/20160229wen-ben-bian-ma.html</link><description>&lt;h1&gt;文本编码&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文本编码这个问题自三年前就困扰着我，当时是用Python处理多国语言时出现的bug，最后问题解决了，但其中具体逻辑并不懂。后来零零散散接触了不少资料，算是大致弄明白，记录如下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;unicode与ascii等编码方案&lt;/h2&gt;
&lt;h3&gt;ascii&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ascii编码方案一共规定了128个字符对应的二进制表示，只占用了一个字节的后面7bit，最高位为0&lt;/li&gt;
&lt;li&gt;欧洲国家使用128个符号不足以表示所有字母，使用了最高位。因此不同的国家128~255表示不同的符号，并不通用，即为扩展的ascii码，包括ISO-8859-1~15。这些都是单个字节编码。&lt;/li&gt;
&lt;li&gt;ISO-8859-1&lt;ul&gt;
&lt;li&gt;ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，没有被收录在ISO-8859-1当中&lt;/li&gt;
&lt;li&gt;ISO-8859-1编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃&lt;/li&gt;
&lt;li&gt;Latin1是ISO-8859-1的别名，有些环境下写作Latin-1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;gb2312&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一种双字节编码，包含6763个汉字&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;gbk&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对gb2312的扩展，可以表示21003个汉字，兼容gb2312&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;gb18030&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;unicode的一种天朝实现&lt;/li&gt;
&lt;li&gt;采用单、双、四字节编码，兼容gb2312&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;base64&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;base64使用64个可打印字符表示二进制数据 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 01 Mar 2016 00:04:34 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-03-01:/pages/2016/03/20160229wen-ben-bian-ma.html</guid><category>misc</category></item><item><title>pythonChallenge</title><link>http://heloman.github.io/pages/2016/02/pythonchallenge.html</link><description>&lt;h1&gt;pythonChallenge&lt;/h1&gt;
&lt;p&gt;可以将url里的/pc改成/pcc来查看上一题的参考代码&lt;/p&gt;
&lt;h2&gt;0&lt;/h2&gt;
&lt;p&gt;计算2^38即可，替换*.html&lt;/p&gt;
&lt;h2&gt;1&lt;/h2&gt;
&lt;p&gt;观察知为移位加密，需要了解的api有：     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ord()和chr()用于在char和ascii数字之间转换&lt;/li&gt;
&lt;li&gt;推荐使用string.translate()来解密，string.maketrans可以用来生成table&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用同样的算法对url中的map进行解密即可得到下一url&lt;/p&gt;
&lt;h2&gt;2&lt;/h2&gt;
&lt;p&gt;根据提示，查看网页源码，要求统计字符串中的低频字符，得到之后拼接成一个单词即可&lt;/p&gt;
&lt;h2&gt;3&lt;/h2&gt;
&lt;p&gt;要求找到一个小写字母，左右两边均有三个大写字母相邻，使用re模块的findall方法，建议看看参考代码，其中给出了多种使用re的方案&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="na"&gt;.join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;re.findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;^&lt;/span&gt;&lt;span class="no"&gt;A-Z&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="no"&gt;A-Z&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="no"&gt;a-z&lt;/span&gt;&lt;span class="p"&gt;])[&lt;/span&gt;&lt;span class="no"&gt;A-Z&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;^&lt;/span&gt;&lt;span class="no"&gt;A-Z&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;text&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="na"&gt;.join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="no"&gt;for&lt;/span&gt; &lt;span class="no"&gt;x&lt;/span&gt; &lt;span class="no"&gt;in&lt;/span&gt; &lt;span class="no"&gt;re …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 18 Feb 2016 09:17:56 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-02-18:/pages/2016/02/pythonchallenge.html</guid><category>misc</category></item><item><title>Unity调用Native代码</title><link>http://heloman.github.io/pages/2016/01/unitydiao-yong-nativedai-ma.html</link><description>&lt;h1&gt;Unity调用Native代码&lt;/h1&gt;
&lt;h2&gt;iOS&lt;/h2&gt;
&lt;h3&gt;iOS程序入口&lt;/h3&gt;
&lt;h2&gt;安卓&lt;/h2&gt;
&lt;h3&gt;安卓程序入口&lt;/h3&gt;
&lt;h4&gt;生命周期&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;是否可见&lt;/li&gt;
&lt;li&gt;是否可触摸&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 29 Jan 2016 17:06:10 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-01-29:/pages/2016/01/unitydiao-yong-nativedai-ma.html</guid><category>misc</category></item><item><title>Android编程权威指南</title><link>http://heloman.github.io/pages/2016/01/androidbian-cheng-quan-wei-zhi-nan.html</link><description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设备默认使用/res/layout目录下布局资源。水平时将尝试使用res/layout-land下资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设备配置如果发生改变,activity将会销毁后重新创建&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 13 Jan 2016 23:07:54 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2016-01-13:/pages/2016/01/androidbian-cheng-quan-wei-zhi-nan.html</guid><category>misc</category></item><item><title>20151014 命令行字典</title><link>http://heloman.github.io/pages/2015/10/20151014-ming-ling-xing-zi-dian.html</link><description>&lt;h1&gt;命令行字典&lt;/h1&gt;
&lt;p&gt;作为一个有追求的程序员，当然想把一切操作通过键盘来完成，让手指保持在键盘上。那么，如何做到用键盘来查询英文单词呢？突发奇想在命令行里用python脚本来爬取有道词典的查询结果，使用&lt;code&gt;requests + BeautifulSoup&lt;/code&gt;实现，效果还不错。  &lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;代码放在了&lt;a href="https://github.com/heLomaN/NetCrawler/blob/master/cmd_dict.py"&gt;heLomaN@Github&lt;/a&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c1"&gt;# coding=utf-8&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;rq&lt;/span&gt;
&lt;span class="kn"&gt;from …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 14 Oct 2015 02:43:53 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2015-10-14:/pages/2015/10/20151014-ming-ling-xing-zi-dian.html</guid><category>misc</category></item><item><title>20150409C++中的容器</title><link>http://heloman.github.io/pages/2015/04/20150409czhong-de-rong-qi.html</link><description>&lt;h1&gt;C++中的容器&lt;/h1&gt;
&lt;h2&gt;容器与容器适配器&lt;/h2&gt;
&lt;p&gt;容器包括vector, deque, list, map, multimap, set, multiset。容器适配器包括基于deque的stack和queue，基于vector的priority_queue。string也实现了stl的接口。&lt;/p&gt;
&lt;p&gt;因为编写C++程序时经常需要查找容器的函数接口，故作此总结。C++新引入的容器与函数未引入。主要参考自：&lt;a href="http://cs.stmarys.ca/~porter/csc/ref/stl/index_containers.html"&gt;STL Containers and Container Adaptors&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;序列容器&lt;/h3&gt;
&lt;p&gt;包括vector，deque，list&lt;/p&gt;
&lt;h4&gt;共有函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;ContainerType&amp;lt;T&amp;gt; c; &lt;/span&gt;
&lt;span class="err"&gt;ContainerType&amp;lt;T&amp;gt; c(num);    &lt;/span&gt;
&lt;span class="err"&gt;ContainerType&amp;lt;T&amp;gt; c(num, val);   &lt;/span&gt;
&lt;span class="err"&gt;ContainerType&amp;lt;T&amp;gt; c(inIterBegin, inIterEnd);     &lt;/span&gt;
&lt;span class="err"&gt;//复制构造函数&lt;/span&gt;
&lt;span class="err"&gt;ContainerType&amp;lt;T …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 08 Apr 2015 02:36:11 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2015-04-08:/pages/2015/04/20150409czhong-de-rong-qi.html</guid><category>misc</category></item><item><title>20141229 python的类</title><link>http://heloman.github.io/pages/2014/12/20141229-pythonde-lei.html</link><description>&lt;h1&gt;python的类&lt;/h1&gt;
&lt;h2&gt;module的属性与作用域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;属性分为只读的和可写的。可写的属性也可以删除：&lt;code&gt;del a.attr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内置namespace在&lt;code&gt;__builtin__&lt;/code&gt;模块下，程序中的语句在&lt;code&gt;__main__&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;如果一个name生命为global，则所有的引用赋值可以直接找到此name。否则，此name是只读的，任意写操作都会新建一个同名局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__init__&lt;/code&gt;在类实例化时被调用&lt;/li&gt;
&lt;li&gt;python的对象分为类对象、实例对象、方法对象&lt;/li&gt;
&lt;li&gt;将可变类型作为类对象会带来多个其实例对象修改同一个可变类型，最好放入&lt;code&gt;__init__&lt;/code&gt;中作为实例对象&lt;/li&gt;
&lt;li&gt;数据属性可能覆盖同名方法属性&lt;/li&gt;
&lt;li&gt;可以将函数对象赋值给类对象作为成员&lt;/li&gt;
&lt;li&gt;每个对象都有一个类型：&lt;code&gt;object.__class__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;派生和继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;继承：&lt;code&gt;class derived(base):&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;派生类中所有方法都是虚的&lt;/li&gt;
&lt;li&gt;多继承：搜索时从左到右，深度搜索&lt;/li&gt;
&lt;li&gt;name mangling：以两个下划线开始的属性将被替换为&lt;code&gt;_classname__spam&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 31 Dec 2014 10:52:47 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-12-31:/pages/2014/12/20141229-pythonde-lei.html</guid><category>misc</category></item><item><title>20141208 python数据类型</title><link>http://heloman.github.io/pages/2014/12/20141208-pythonshu-ju-lei-xing.html</link><description>&lt;h1&gt;Python中的数据类型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;字符串和数组是immutable的&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;type(var)&lt;/code&gt;可以很方便的确认变量类型&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;id(var)&lt;/code&gt;可以查看每个变量对象的id，id相同表示两个对象在内存中位置相同，节省了开销&lt;/li&gt;
&lt;li&gt;tuple、list、dict分别用&lt;code&gt;() [] {}&lt;/code&gt;表示&lt;/li&gt;
&lt;li&gt;数据类型间转换：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;int() float() complex() str() list() tuple()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;布尔类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt;和&lt;code&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;布尔运算：and or not&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;整数Int&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;超出一个范围后，会自动转换为Long数据类型，也可以使用&lt;code&gt;345L&lt;/code&gt;的方式强制使用long类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;浮点数Float&lt;/h2&gt;
&lt;h2&gt;字符串&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字符串用单引号&lt;code&gt;' '&lt;/code&gt;、双引号&lt;code&gt;" "&lt;/code&gt;、三引号&lt;code&gt;''' '''&lt;/code&gt;，其中三引号内的字符串可以分成多行书写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt;表示转义，而字符串前加入r可以防止转义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;split join&lt;/code&gt;是最常用的方法，用于分词，在list和string之间转换 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 08 Dec 2014 23:11:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-12-08:/pages/2014/12/20141208-pythonshu-ju-lei-xing.html</guid><category>misc</category></item><item><title>面试题集锦</title><link>http://heloman.github.io/pages/2014/09/mian-shi-ti-ji-jin.html</link><description>&lt;h1&gt;面试题集锦&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;谨对一些看过的面试题做一些总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;以下部分来自于纸上谈兵&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;为什么正二十面体的体积面积比比四边形的大？&lt;/li&gt;
&lt;li&gt;正态分布和均匀分布之间是否可以相互转换？&lt;/li&gt;
&lt;li&gt;三门、女孩、三囚犯问题：&lt;a href="http://zhiqiang.org/blog/science/three-doors-related-problems.html"&gt;http://zhiqiang.org/blog/science/three-doors-related-problems.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;找到和为k的子数组&lt;/li&gt;
&lt;li&gt;一个与世隔绝的岛屿上有13个黑人、15个白人和17个黄种人。任何两种不同皮肤的人遇到一起，就会都变成另外一种颜色。问是否可能所有人都变成同一种颜色？&lt;/li&gt;
&lt;li&gt;你有100个硬币。首先你将它分成两堆，分别有x枚和y枚硬币，得到它们的乘积。再任意将其中的一堆分成两堆，得到两个小堆的硬币数量的乘积。这样一直分下去直到每个堆只有一枚硬币无法再分为止。将所有得到的乘积加起来，问最后这样的乘积和最大是多少？&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sun, 14 Sep 2014 08:36:56 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-09-14:/pages/2014/09/mian-shi-ti-ji-jin.html</guid><category>misc</category></item><item><title>碰撞检测</title><link>http://heloman.github.io/pages/2014/09/peng-zhuang-jian-ce.html</link><description>&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;向量点乘&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 10 Sep 2014 20:47:26 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-09-10:/pages/2014/09/peng-zhuang-jian-ce.html</guid><category>misc</category></item><item><title>20140908《全景探秘游戏设计艺术》精华 用户体验 游戏平衡性</title><link>http://heloman.github.io/pages/2014/09/20140908quan-jing-tan-mi-you-xi-she-ji-yi-zhu-jing-hua-yong-hu-ti-yan-you-xi-ping-heng-xing.html</link><description>&lt;h1&gt;《全景探秘游戏设计艺术》精华 用户体验 游戏平衡性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;一本很好的游戏设计书籍，暂时关注的是用户体验部分，比如，用户喜欢什么，什么可以带来乐趣，以及游戏的平衡性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;男性与女性的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;男性喜欢的游戏要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;征服：控制一切&lt;/li&gt;
&lt;li&gt;竞争：与他人竞争来表明自己是最棒的&lt;/li&gt;
&lt;li&gt;破坏：破坏带来快感&lt;/li&gt;
&lt;li&gt;空间谜题：男性有更好的空间推理能力&lt;/li&gt;
&lt;li&gt;尝试和失败：男性不喜欢阅读说明，更喜欢通过尝试和失败来学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;女性喜欢的游戏要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情感：比如爱情与浪漫&lt;/li&gt;
&lt;li&gt;与真实世界关联：如换装、虚拟人生、偷菜&lt;/li&gt;
&lt;li&gt;照料别人：如宠物养成和游戏中的治疗师&lt;/li&gt;
&lt;li&gt;对话和字谜：如填字游戏，仙剑&lt;/li&gt;
&lt;li&gt;照实例学习：按照教程来学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;游戏的乐趣&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;美学：精美的画面和优美的背景音乐，是感官的乐趣，如三位一体，梦幻的画面&lt;/li&gt;
&lt;li&gt;幻想：把自己幻想成现实中无法成为的事物，如凡人修仙传&lt;/li&gt;
&lt;li&gt;叙述：一个连续事件的戏剧性揭示过程，仙剑系列&lt;/li&gt;
&lt;li&gt;挑战 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 09 Sep 2014 01:05:16 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-09-09:/pages/2014/09/20140908quan-jing-tan-mi-you-xi-she-ji-yi-zhu-jing-hua-yong-hu-ti-yan-you-xi-ping-heng-xing.html</guid><category>misc</category></item><item><title>20140908《金领简历》精华 创业公司 面试机会 简历</title><link>http://heloman.github.io/pages/2014/09/20140908jin-ling-jian-li-jing-hua-chuang-ye-gong-si-mian-shi-ji-hui-jian-li.html</link><description>&lt;h1&gt;《金领简历》精华 创业公司 面试机会 简历&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《金领简历》在我看来是一本非常好的书，把面试之前的提前准备工作讲的非常到位，可惜在图书馆里没人借这本书。&lt;/li&gt;
&lt;li&gt;本文主要讲关于是否选择去创业公司、如何得到面试机会、如何写出优秀的简历。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;创业公司的特点&lt;/h2&gt;
&lt;h3&gt;创业公司的有利之处&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;全面锻炼能力： 有机会培养各种技能，但如果是只专注某个领域的人才，应该避免加入创业公司&lt;/li&gt;
&lt;li&gt;晋升机会更大：如果公司扩大规模，很容易成为团队领导&lt;/li&gt;
&lt;li&gt;控制力与影响力：可以凭借自己的工作表现影响公司的发展，可以对具体事项提意见&lt;/li&gt;
&lt;li&gt;能够迅速知道结果：通常几个月就能知道自己的决策是好是坏&lt;/li&gt;
&lt;li&gt;高回报：有可能变得富有，但同时承担风险&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创业公司的不利因素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;需要长时间工作：需要大量的加班&lt;/li&gt;
&lt;li&gt;工作职责不清晰：各种杂事都要做&lt;/li&gt;
&lt;li&gt;低收入：薪酬低于业界标准，只能靠给股票期权来弥补，公司倒闭则成了废纸&lt;/li&gt;
&lt;li&gt;信誉度低：如果公司倒闭，重新找工作时简历上工作经历是污点&lt;/li&gt;
&lt;li&gt;得到的指导少：只能摸索着学习，而大公司或专业人士能够教给你一套解决问题的有效方法&lt;/li&gt;
&lt;li&gt;像免费午餐等大公司提供的福利并不是关键，无关紧要&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在大公司和创业公司之间做选择&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;去创业公司的机会随时都有&lt;/li&gt;
&lt;li&gt;大公司能够学会真正的软件开发：代码审查 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 09 Sep 2014 00:16:49 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-09-09:/pages/2014/09/20140908jin-ling-jian-li-jing-hua-chuang-ye-gong-si-mian-shi-ji-hui-jian-li.html</guid><category>misc</category></item><item><title>reactive programming scala</title><link>http://heloman.github.io/pages/2014/09/reactive-programming-scala.html</link><description>&lt;h2&gt;第一周 Quickcheck&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现一个heap&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第二周 Simulations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;电路仿真&lt;ul&gt;
&lt;li&gt;每个器件固定时延，线路没有时延&lt;/li&gt;
&lt;li&gt;或门仿真&lt;/li&gt;
&lt;li&gt;多路分离器仿真&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流行病仿真&lt;ul&gt;
&lt;li&gt;使用矩阵模拟城市&lt;/li&gt;
&lt;li&gt;飞机使用概率对结果又影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图形显示接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三周 NodeScala&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用future实现一个异步服务器&lt;/li&gt;
&lt;li&gt;可以对系统库中已有的类添加方法&lt;/li&gt;
&lt;li&gt;扩展future对象，并添加取消方法&lt;/li&gt;
&lt;li&gt;实现异步HTTP服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第四周 Wikipedia Suggestions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;开发一个维基百科建议应用的图形界面，允许用户输入字符时实时显示可能的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五周 Actor Binary Tree&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现一个基于actor的二叉树，可以全异步的并行执行&lt;/li&gt;
&lt;li&gt;插入和contains查询都是自顶向下一条路径，remove采用标记的方法&lt;/li&gt;
&lt;li&gt;实现GC方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第六周 Replicated KV Store&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KV是一个最简单的数据库形式&lt;/li&gt;
&lt;li&gt;本次实现一个分布式有备份的KV存储，分布式系统中的每个节点为一个actor，同时需要一些辅助的actor&lt;/li&gt;
&lt;li&gt;系统包含一个主节点，负责复制所有改变到所有副节点。所有节点组成一个分布式数据库，备份节点随时可能加入或掉线&lt;/li&gt;
&lt;li&gt;仅有主节点接受修改事件（插入与删除），所有的节点接受查找事件 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 04 Sep 2014 07:11:22 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-09-04:/pages/2014/09/reactive-programming-scala.html</guid><category>misc</category></item><item><title>20140727如何写出一个较好的快速排序程序</title><link>http://heloman.github.io/pages/2014/08/20140727ru-he-xie-chu-yi-ge-jiao-hao-de-kuai-su-pai-xu-cheng-xu.html</link><description>&lt;h2&gt;写出一个较好的快速排序程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;快速排序是常用的排序算法之一，但要想写出一个又快又准的使用程序，就不是那么简单了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;需要注意的事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先要写正确。通常使用递归实现。其递归相当于二叉树展开，因此如果要用迭代实现的话需要使用一个队列来保存后续遍历信息。&lt;/li&gt;
&lt;li&gt;快速排序需要找到一个pivot值，如果顺序选择pivot则易造成N^2的复杂度，如果使用随机数则效果最好，但开销又太大，采取三数中值法比较合适。三数中值法指的是选取第一个值，最后一个值，数组中间的值的中值。有文献表明可以提升5%的运行时间。&lt;/li&gt;
&lt;li&gt;当数组长度较小时，如10个元素以下，最好使用插入排序或者选择排序完成，以防止复杂度常数因子过大或多次函数调用带来的开销。而递归到底层数组长度总是会变小的，因此这么做非常有必要。&lt;/li&gt;
&lt;li&gt;在合并前后两部分数组时，采用两边夹方法，在前后两部分各找到一个大于和小于的值再交换。相比通常情况下找到比pivot小的值就进行交换，能提高运行效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;实现代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代码如下。包括插入排序insert_sort，递归函数，三分中值函数三个辅助函数。&lt;/li&gt;
&lt;li&gt;三分中值函数其实采用的是插入排序。通过三次比较，确定中值。&lt;/li&gt;
&lt;li&gt;插值算法使用临时变量tmp避免了大量swap函数调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iomanip&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cstdlib&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ctime …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 20 Aug 2014 22:31:13 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-20:/pages/2014/08/20140727ru-he-xie-chu-yi-ge-jiao-hao-de-kuai-su-pai-xu-cheng-xu.html</guid><category>misc</category></item><item><title>20140820火车运煤问题</title><link>http://heloman.github.io/pages/2014/08/20140820huo-che-yun-mei-wen-ti.html</link><description>&lt;h1&gt;火车运煤问题&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;刚面试问到这个题，可惜一直没有为此类问题准备，差点就回答出来了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;题目内容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大——每一公里需要耗一吨煤。请问，作为一个懂编程的煤老板的你，你会怎么运送才能运最多的煤到集市？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;很显然每次走全程的话是无法到达终点的，更别说剩余部分煤。必然把煤全部运到中间某点，然后再继续运&lt;/li&gt;
&lt;li&gt;假设第一次把煤全部运输到中间某点A，距离为x，那么消耗的煤的数量为5x，因为要往返两次，再单程一次把剩下的1000吨运往A点。&lt;/li&gt;
&lt;li&gt;如果A点剩余煤量3000-5x大于2000，那么下一次假设从A运输到B，距离为y，消耗的煤的数量同样是5y。&lt;/li&gt;
&lt;li&gt;如果A点剩余煤量小于2000，那么从A到B只需往返一次，再单程一次，消耗煤的数量为3y。&lt;/li&gt;
&lt;li&gt;由此可见，从一点到另外一点距离为s，中途不折返，如果初始煤量在3000~2000之间，需要消耗5s吨煤&lt;/li&gt;
&lt;li&gt;同理得到，s距离不折返初始煤量在2000~1000之间，需要消耗3s吨煤&lt;/li&gt;
&lt;li&gt;s距离不折返初始煤量在1000~0之间，需要消耗s吨煤&lt;/li&gt;
&lt;li&gt;那么最终的策略为每次选择单位消耗最小的方式运输，第一次消耗5x，第二次消耗3y，第三次消耗z …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 20 Aug 2014 08:40:58 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-20:/pages/2014/08/20140820huo-che-yun-mei-wen-ti.html</guid><category>misc</category></item><item><title>20140811thttpd源码解析 定时器模块</title><link>http://heloman.github.io/pages/2014/08/20140811thttpdyuan-ma-jie-xi-ding-shi-qi-mo-kuai.html</link><description>&lt;h1&gt;thttpd源码解析 定时器模块&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;thttpd是非常轻量级的http服务器，可执行文件仅50kB。名称中的第一个&lt;code&gt;t&lt;/code&gt;表示tiny, turbo, 或throttling&lt;/li&gt;
&lt;li&gt;与lighttpd、memcached、redis相比非常小巧，仅有不到8k行，而后三者大小分别为：60k,13k,86k&lt;/li&gt;
&lt;li&gt;支持HTTP/1.1和CGI；采用IO复用实现，单线程，可移植；实现了基于URL的文件流量限制功能&lt;/li&gt;
&lt;li&gt;特别适用于大量静态数据访问的场景，如图片存储&lt;/li&gt;
&lt;li&gt;2004年已经停止维护，有一个关于X-Forwarded-For HTTP header的bug。后来出现stthhpd基于此项目&lt;/li&gt;
&lt;li&gt;性能比较参考&lt;a href="http://www.acme.com/software/thttpd/benchmarks.html"&gt;对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文针对timer模块进行分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;timer模块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;包括timer.h,timer.c两个文件&lt;/li&gt;
&lt;li&gt;使用全局开放式散列表，默认大小67，每个hash节点上的值按照时间顺序排列&lt;/li&gt;
&lt;li&gt;ClientData定义如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;typedef union {&lt;/span&gt;
&lt;span class="err"&gt;    void* p;&lt;/span&gt;
&lt;span class="err"&gt;    int i;&lt;/span&gt;
&lt;span class="err"&gt;    long …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 11 Aug 2014 12:51:21 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-11:/pages/2014/08/20140811thttpdyuan-ma-jie-xi-ding-shi-qi-mo-kuai.html</guid><category>misc</category></item><item><title>《算法之道》精华</title><link>http://heloman.github.io/pages/2014/08/suan-fa-zhi-dao-jing-hua.html</link><description>&lt;h1&gt;《算法之道》精华&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书&lt;/li&gt;
&lt;li&gt;这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考&lt;/li&gt;
&lt;li&gt;本文仅包括算法设计部分，算法分析略去，并没有严格按照章节顺序来记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;附录 算法随想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有人喜欢遍历，希望踏遍千山万水，人生丰富多彩；有人一生贪婪，眼界不宽，及时行乐；有人注定穷搜，辛辛苦苦，收获有限；有人善用时空均衡，用最少的时间办最多的事情，十分精明；有人会分治，再难的问题也能解决；有人动态规划，积少成多&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三章 分治与递归&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;生活中的例子：天平秤球以辨明次品；乘法运算；世界杯晋级赛；秦国合纵连横&lt;/li&gt;
&lt;li&gt;分治策略步骤：1，将问题分为若干小问题；2，递归解决这些子问题；3，合并子问题的解答，得到大问题的解&lt;/li&gt;
&lt;li&gt;标准分治策略的定义里面包含递归：&lt;code&gt;T(n …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 09 Aug 2014 13:00:17 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-09:/pages/2014/08/suan-fa-zhi-dao-jing-hua.html</guid><category>misc</category></item><item><title>20140809《算法之道》精华 难解问题部分</title><link>http://heloman.github.io/pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-nan-jie-wen-ti-bu-fen.html</link><description>&lt;h1&gt;《算法之道》精华 难解问题部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书&lt;/li&gt;
&lt;li&gt;这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考&lt;/li&gt;
&lt;li&gt;本文包括难解问题部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第十三章 易解与难解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;易解指的是多项式问题，难解指的是指数级问题&lt;/li&gt;
&lt;li&gt;决策问题&lt;ul&gt;
&lt;li&gt;需要输出答案是/否&lt;/li&gt;
&lt;li&gt;若回答为是，通常需要一个证人来证明。对一个潜在证人，证明之后即为真证人&lt;/li&gt;
&lt;li&gt;优化问题和决策问题之间可以相互转化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;P类问题&lt;ul&gt;
&lt;li&gt;确定性多项式时间可解&lt;/li&gt;
&lt;li&gt;对于一个决策问题，输入的大小为n，能在n的多项式时间内解决，正确输出是/否&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NP类问题&lt;ul&gt;
&lt;li&gt;非确定性多项式时间可解&lt;/li&gt;
&lt;li&gt;对于一个决策问题，大小为n的潜在证人，能在n的多项式时间内解决，正确输出此证人是否为真&lt;/li&gt;
&lt;li&gt;P类问题指的是能否多项式时间给出答案，NP类问题指的是能否在多项式时间内判断一个潜在答案是否正确&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;（确定性）图灵机&lt;ul&gt;
&lt;li&gt;图灵机为一个状态机，根据当前状态、下一个输入字符确定输出、磁头移动方向、下一个状态&lt;/li&gt;
&lt;li&gt;任一个问题、算法都能表述为一个字符串，因此图灵机可以解决很多问题 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 09 Aug 2014 13:00:16 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-09:/pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-nan-jie-wen-ti-bu-fen.html</guid><category>misc</category></item><item><title>20140809《算法之道》精华 经典算法部分</title><link>http://heloman.github.io/pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-jing-dian-suan-fa-bu-fen.html</link><description>&lt;h1&gt;《算法之道》精华 经典算法部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书&lt;/li&gt;
&lt;li&gt;这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考&lt;/li&gt;
&lt;li&gt;本文包括经典算法部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第十章 排序与次序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;插入排序&lt;ul&gt;
&lt;li&gt;从无序部分抽取一张插入有序部分&lt;/li&gt;
&lt;li&gt;为原地排序，无需占用临时存储空间&lt;/li&gt;
&lt;li&gt;最优情况下为O(n)，平均O(n^2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;折半插入排序&lt;ul&gt;
&lt;li&gt;插入时使用二分查找&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;归并排序&lt;ul&gt;
&lt;li&gt;分治，从中间分解，分别排序后进行仔细的合并&lt;/li&gt;
&lt;li&gt;异地排序，需要占用额外空间&lt;/li&gt;
&lt;li&gt;n&amp;gt;=30时性能比插入排序更好。复杂度固定为O(nlog(n))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快排&lt;ul&gt;
&lt;li&gt;分治，复杂的部分在于分解，而归并复杂在于合并&lt;/li&gt;
&lt;li&gt;原地排序&lt;/li&gt;
&lt;li&gt;最坏情况为O(n^2)，但只要不是每次都是最坏，复杂度就不是n^2，具有韧性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任何基于比较的排序 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 09 Aug 2014 13:00:15 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-09:/pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-jing-dian-suan-fa-bu-fen.html</guid><category>misc</category></item><item><title>20140809《算法之道》精华 算法设计部分</title><link>http://heloman.github.io/pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-suan-fa-she-ji-bu-fen.html</link><description>&lt;h1&gt;《算法之道》精华 算法设计部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本书作者邹恒明，作者另有一本书《数据结构之弦》，以及《操作系统之哲学原理》都是很好的书&lt;/li&gt;
&lt;li&gt;这本书可以算得上是深入浅出，文笔很好，作者添加了很多自己的思考&lt;/li&gt;
&lt;li&gt;本文仅包括算法设计部分，算法分析略去，并没有严格按照章节顺序来记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;附录 算法随想&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有人喜欢遍历，希望踏遍千山万水，人生丰富多彩；有人一生贪婪，眼界不宽，及时行乐；有人注定穷搜，辛辛苦苦，收获有限；有人善用时空均衡，用最少的时间办最多的事情，十分精明；有人会分治，再难的问题也能解决；有人动态规划，积少成多&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三章 分治与递归&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;生活中的例子：天平秤球以辨明次品；乘法运算；世界杯晋级赛；秦国合纵连横&lt;/li&gt;
&lt;li&gt;分治策略步骤：1，将问题分为若干小问题；2，递归解决这些子问题；3，合并子问题的解答，得到大问题的解&lt;/li&gt;
&lt;li&gt;标准分治策略的定义里面包含递归：&lt;code&gt;T …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 09 Aug 2014 13:00:12 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-09:/pages/2014/08/20140809suan-fa-zhi-dao-jing-hua-suan-fa-she-ji-bu-fen.html</guid><category>misc</category></item><item><title>20140807《程序员面试宝典》精华 底层部分</title><link>http://heloman.github.io/pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-di-ceng-bu-fen.html</link><description>&lt;h1&gt;《程序员面试宝典》精华 底层部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。书里是没有糟粕的，只是指不那么重要，或者比较简单的地方略过而已，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。&lt;/li&gt;
&lt;li&gt;本文专注位运算、操作系统、数据库、网络部分，包括第十二章以后的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第十二章 位运算与嵌入式编程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;12.1 printf的%f说明符可以输出float和double型，float型会被提升为double型。&lt;code&gt;printf("%f",5);printf("%d",5.01)&lt;/code&gt;，前者会从存放5的位置取double型的8个字节，内存越界，并按bit解释，后者会按照整数来解释5.01的比特，输出为0，一个大整数。&lt;strong&gt;真的是越界&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;12.1 &lt;code&gt;struct a{int z:33 …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 07 Aug 2014 07:33:54 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-07:/pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-di-ceng-bu-fen.html</guid><category>misc</category></item><item><title>20140807《程序员面试宝典》精华 面向对象部分</title><link>http://heloman.github.io/pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-mian-xiang-dui-xiang-bu-fen.html</link><description>&lt;h1&gt;《程序员面试宝典》精华 面向对象部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。书里是没有糟粕的，只是指不那么重要，或者比较简单的地方略过而已，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。&lt;/li&gt;
&lt;li&gt;文中有少许bug，亦摘录在此。&lt;/li&gt;
&lt;li&gt;本文专注面向对象部分，包括第十章到第十一章的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第十章 面向对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;10.2 类与结构体的区别：都能继承、拥有析构等成员函数，唯一的区别是struct成员默认为public，而class默认为private。C++是为了兼容C代码才保留struct关键字&lt;/li&gt;
&lt;li&gt;10.3 &lt;code&gt;class B{...}; B b(); b.f();&lt;/code&gt;是错误的，b声明为了一个函数&lt;/li&gt;
&lt;li&gt;10.3 静态成员变量必须显式初始化，例如&lt;code&gt;int A::i  0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;10 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 07 Aug 2014 00:00:36 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-07:/pages/2014/08/20140807cheng-xu-yuan-mian-shi-bao-dian-jing-hua-mian-xiang-dui-xiang-bu-fen.html</guid><category>misc</category></item><item><title>《程序员面试宝典》精华</title><link>http://heloman.github.io/pages/2014/08/cheng-xu-yuan-mian-shi-bao-dian-jing-hua.html</link><description>&lt;h1&gt;《程序员面试宝典》精华&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。当然这里的糟粕只是指不那么重要，或者比较简单，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。&lt;/li&gt;
&lt;li&gt;文中有少许bug，亦摘录在此。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五章 语言细节&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;5.1 &lt;code&gt;y = z = 5&lt;/code&gt;，等号先计算右边，返回值是赋值后的左边的变量值&lt;/li&gt;
&lt;li&gt;5.1 printf函数中的表达式从右向左压栈，应该先计算右方的值&lt;/li&gt;
&lt;li&gt;5.4 float型1.0f在内存中表示为：0x3f 80 00 00&lt;/li&gt;
&lt;li&gt;5.5 出现int常数的表达式中的变量通常都要提升至int型&lt;/li&gt;
&lt;li&gt;5.5 赋值运算符默认从右向左结合，也就是先计算右方的值&lt;/li&gt;
&lt;li&gt;5.5 (x&amp;amp;y) + ((x^y …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 06 Aug 2014 20:54:52 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-06:/pages/2014/08/cheng-xu-yuan-mian-shi-bao-dian-jing-hua.html</guid><category>misc</category></item><item><title>20140806《程序员面试宝典》精华 语言部分</title><link>http://heloman.github.io/pages/2014/08/20140806cheng-xu-yuan-mian-shi-bao-dian-jing-hua-yu-yan-bu-fen.html</link><description>&lt;h1&gt;《程序员面试宝典》精华 编程语言部分&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;正所谓取其精华，去其糟粕。本文谨记录下《程序员面试宝典》一些关键的知识点、易错点，对于一些虽然重要但书中没有解释清楚的地方不做记录。当然这里的糟粕只是指不那么重要，或者比较简单，并不是说书写的不好。希望以后回顾时无需再看此书，只看保留在文中的精华即可。&lt;/li&gt;
&lt;li&gt;文中有少许bug，亦摘录在此。&lt;/li&gt;
&lt;li&gt;本文专注编程语言部分，包括第五章到第九章的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五章 语言细节&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;5.1 &lt;code&gt;y = z = 5&lt;/code&gt;，等号先计算右边，返回值是赋值后的左边的变量值&lt;/li&gt;
&lt;li&gt;5.1 printf函数中的表达式从右向左压栈，应该先计算右方的值&lt;/li&gt;
&lt;li&gt;5.4 float型1.0f在内存中表示为：0x3f 80 00 00&lt;/li&gt;
&lt;li&gt;5.5 出现int常数的表达式中的变量通常都要提升至int型&lt;/li&gt;
&lt;li&gt;5.5 赋值运算符默认从右向左结合，也就是先计算右方的值&lt;/li&gt;
&lt;li&gt;5.5 (x …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 06 Aug 2014 00:43:22 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-06:/pages/2014/08/20140806cheng-xu-yuan-mian-shi-bao-dian-jing-hua-yu-yan-bu-fen.html</guid><category>misc</category></item><item><title>20140805NeutrinoRDP源码分析 utils库</title><link>http://heloman.github.io/pages/2014/08/20140805neutrinordpyuan-ma-fen-xi-utilsku.html</link><description>&lt;h1&gt;NeutrinoRDP源码分析 一 utils库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;首先分析utils库，代码位于/libfreerdp-utils下，包括api, bitmap, dsp, event, file, list, memory, mutex, rail, semaphore, signal, sleep, stopwatch, stream, string, thread等文件&lt;/li&gt;
&lt;li&gt;以下分文件进行解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;api&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;头文件中定义了FREERDP_API，在linux下为&lt;code&gt;__attribute__((visibility("default")))&lt;/code&gt;，作用&lt;strong&gt;是什么&lt;/strong&gt;？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;bitmap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这段源码为位图格式文件工具&lt;/li&gt;
&lt;li&gt;定义结构体：&lt;ul&gt;
&lt;li&gt;bmpfile_magic 文件的魔数 &lt;/li&gt;
&lt;li&gt;bmpfile_header 数据起始位置以及文件大小 &lt;/li&gt;
&lt;li&gt;BITMAPINFOHEADER 文件头，包括位图相对位置与尺寸，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;freerdp_bitmap_write函数：把位图数据与尺寸写入指定的文件中，以'w+b'的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;dsp&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数字音频处理工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;event&lt;/h2&gt;
&lt;h2&gt;file&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;文件操作工具 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 05 Aug 2014 02:33:16 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-05:/pages/2014/08/20140805neutrinordpyuan-ma-fen-xi-utilsku.html</guid><category>misc</category></item><item><title>20140803软硬件接口第0周作业</title><link>http://heloman.github.io/pages/2014/08/20140803ruan-ying-jian-jie-kou-di-0zhou-zuo-ye.html</link><description>&lt;h1&gt;软硬件接口第0周作业&lt;/h1&gt;
&lt;h3&gt;内存寻址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无论是4字节机器字还是8字节机器字，地址都按照实际地址来取，即每个机器字的数个字节每个均有单独的地址&lt;/li&gt;
&lt;li&gt;指针使用一个机器字存储&lt;/li&gt;
&lt;li&gt;X86架构使用小头字节序，低字节在前，internet使用大头字节序。对于char数组，在两种字节序下兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;整数的表示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有符号整数用补码形式表示，可以把减法转换为加法：&lt;code&gt;a - b = a + (-b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;补码表示的负数的最高位表示&lt;code&gt;-2^(N-1)&lt;/code&gt;，其他位与整数相同，表示&lt;code&gt;2^(N-2), ... 2^1, 2^0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如下图：&lt;/li&gt;
&lt;li&gt;&lt;img alt="" src="20140803Swhdinterface.JPG"&gt;&lt;/li&gt;
&lt;li&gt;例如：1111表示&lt;code&gt;-8 + 4 + 2 + 1 = -1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;要得到负数-x的补码表示，有如下关系：&lt;code&gt;~x + 1 = -x&lt;/code&gt;，即绝对值的反码加1&lt;/li&gt;
&lt;li&gt;最大值参考&lt;code&gt;/usr/include/limits.h&lt;/code&gt;，与平台有关&lt;/li&gt;
&lt;li&gt;C语言中的常数默认为int …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sun, 03 Aug 2014 12:51:37 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-03:/pages/2014/08/20140803ruan-ying-jian-jie-kou-di-0zhou-zuo-ye.html</guid><category>misc</category></item><item><title>排序算法分析及实现</title><link>http://heloman.github.io/pages/2014/08/pai-xu-suan-fa-fen-xi-ji-shi-xian.html</link><description>&lt;p&gt;排序算法分析及实现&lt;/p&gt;
&lt;h2&gt;算法稳定性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不稳定的排序算法共有四种，快排，选择排序，希尔排序，堆排序。首字母为qssh，简记为“去死”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;不稳定算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 02 Aug 2014 13:00:21 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-02:/pages/2014/08/pai-xu-suan-fa-fen-xi-ji-shi-xian.html</guid><category>misc</category></item><item><title>20140802如何统计代码行数</title><link>http://heloman.github.io/pages/2014/08/20140802ru-he-tong-ji-dai-ma-xing-shu.html</link><description>&lt;h1&gt;如何统计代码行数&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;linux下提供了很多实用工具，甚至在安卓上，都有移植的busybox包含这些工具。 &lt;/li&gt;
&lt;li&gt;根据KISS理念，这些工具的功能很单一。但这些工具组合起来，就可以很方面的统计代码量了。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;统计代码行数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;流程为：首先使用find命令找到所有后缀名符合规则的源代码文件，之后使用wc命令统计行数。文件数可能过多，为防止出错使用xargs命令分割参数列表，最后得到的结果可以使用sort排序&lt;/li&gt;
&lt;li&gt;统计所有c源代码行数的命令：&lt;code&gt;find -name *.c | xargs wc -l |sort -r&lt;/code&gt;。结果按照反序排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find -name *.c | xargs wc -l |sort -k2&lt;/code&gt; 结果按照文件名排列&lt;/li&gt;
&lt;li&gt;如需统计c++代码，将&lt;code&gt;*.c&lt;/code&gt;更改为&lt;code&gt;*.cc&lt;/code&gt;即可。如果c++使用cpp后缀名，改为&lt;code&gt;*.cpp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;用到的命令详解&lt;/h2&gt;
&lt;h3&gt;find命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;find命令递归搜索目录，若任一文件使表达式为真则放入结果&lt;/li&gt;
&lt;li&gt;使用方法 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sat, 02 Aug 2014 09:29:07 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-02:/pages/2014/08/20140802ru-he-tong-ji-dai-ma-xing-shu.html</guid><category>misc</category></item><item><title>20140801socket套接字socket套接字TCP API</title><link>http://heloman.github.io/pages/2014/08/20140801sockettao-jie-zi-sockettao-jie-zi-tcp-api.html</link><description>&lt;h1&gt;socket套接字TCP API&lt;/h1&gt;
&lt;h2&gt;socket概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;socket又称“套接字”，是计算机网络中进程间通信数据通道的一个端点，或称之为句柄。IP地址+端口号就可以唯一确定一个socket。&lt;/li&gt;
&lt;li&gt;TCP/IP协议族包括传输层（TCP/UDP），网络层（ICMP/IP/IGMP），链路层（ARP/RARP）。应用层通常使用socket地址，即IP地址+端口号来确定通信的对端。而socket正是TCP/IP协议族与应用层之间的接口层，可以说对上层提供了TCP/IP协议族的一种封装，无需关心更底层的实现。&lt;/li&gt;
&lt;li&gt;应用上通常使用一些更高层的协议库来编程，socket更多归类于底层驱动编程。不过熟悉socket总归是有好处的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;套接字地址结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IP地址+端口号可以唯一确定一个socket套接字地址，命名为&lt;code&gt;sockaddr_in&lt;/code&gt;，位于&lt;code&gt;netinet/in.h&lt;/code&gt;头文件中，定义如下。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;struct in_addr{&lt;/span&gt;
&lt;span class="err"&gt;    in_addr_t s_addr;&lt;/span&gt;
&lt;span class="err"&gt;};&lt;/span&gt;
&lt;span class="err"&gt;struct sockaddr_in{&lt;/span&gt;
&lt;span class="err"&gt;    uint8_t sin_len …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 01 Aug 2014 08:54:31 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-01:/pages/2014/08/20140801sockettao-jie-zi-sockettao-jie-zi-tcp-api.html</guid><category>misc</category></item><item><title>使用Markdown写简历</title><link>http://heloman.github.io/pages/2014/08/shi-yong-markdownxie-jian-li.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 01 Aug 2014 08:51:44 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-08-01:/pages/2014/08/shi-yong-markdownxie-jian-li.html</guid><category>misc</category></item><item><title>剑指offer思路笔记</title><link>http://heloman.github.io/pages/2014/07/jian-zhi-offersi-lu-bi-ji.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 31 Jul 2014 23:40:48 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-31:/pages/2014/07/jian-zhi-offersi-lu-bi-ji.html</guid><category>misc</category></item><item><title>20140728Matlab并行编程</title><link>http://heloman.github.io/pages/2014/07/20140728matlabbing-xing-bian-cheng.html</link><description>&lt;h1&gt;Matlab的parfor并行编程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;通常消耗最多计算资源的程序往往是循环。把循环并行化，或者优化循环体中的代码是最常用的加快程序运行速度的思路。&lt;/li&gt;
&lt;li&gt;Matlab提供了parfor关键字，可以很方便的在多核机器或集群上实现并行计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;parfor关键字的使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由for关键字引导的循环通常为串行运行，如果改为parfor则可以由多个worker以并行方式执行。&lt;/li&gt;
&lt;li&gt;parfor可以将n次循环分解为独立不相关的m部分，然后将各部分分别交给一个worker执行。&lt;/li&gt;
&lt;li&gt;循环执行的结果应该与n次循环执行的顺序无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;parfor中的变量类型&lt;/h2&gt;
&lt;h3&gt;简约变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一般parfor中各次循环对应的运算应该相互独立，但简约操作可以在多次循环内同时对一个变量操作。这种变量称为简约变量。例如下方代码中a就是简约变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;a = 0;&lt;/span&gt;
&lt;span class="err"&gt;for i = 1:1000&lt;/span&gt;
&lt;span class="err"&gt;    a = a+i;&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;简约操作包括&lt;code&gt;+ - * .* &amp;amp; | [,] [;] {,} {;} min max union intersect&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;同一个parfor循环对简约变量的操作必须一致，即必须是同一种简约操作符。而且与操作符的相对位置也必须一致。&lt;/li&gt;
&lt;li&gt;简约变量赋值表达式应该满足结合律和交换律。&lt;code&gt;* [] {}&lt;/code&gt;底层有特殊处理保证结果的正确性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;切片变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;parfor中可能需要读取或写入parfor之外的矩阵，读取写入位置与循环变量相关。这样就需要向worker传输大量的数据。&lt;/li&gt;
&lt;li&gt;矩阵如果被Matlab识别为切片变量，则数据可以分段传输到各worker，提高传输效率。&lt;/li&gt;
&lt;li&gt;切片变量矩阵的大小是不可在parfor中改变的，且为了保证Matlab识别正确，每次循环中只能读取由同一个索引值索引的切片，如&lt;code&gt;a …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 28 Jul 2014 17:27:37 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-28:/pages/2014/07/20140728matlabbing-xing-bian-cheng.html</guid><category>misc</category></item><item><title>多普勒失真信号重采样的Matlab仿真分析</title><link>http://heloman.github.io/pages/2014/07/duo-pu-le-shi-zhen-xin-hao-zhong-cai-yang-de-matlabfang-zhen-fen-xi.html</link><description>&lt;h1&gt;多普勒失真信号重采样的Matlab仿真分析&lt;/h1&gt;
&lt;h2&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;水声通信指的是使用声信号在水中传输数据。相对而言，电磁信号在水中吸收严重衰减过快，光信号受水中悬浮颗粒的影响，也无法完成远距离传输。这两种信号的传播距离约为数百米，而声信号在水中传播距离达到数十千米，成为水下通信的首选方式。&lt;/li&gt;
&lt;li&gt;水声通信的一个重大挑战就是运动带来的多普勒。多普勒造成信号的频率漂移，影响系统性能，因此非常有必要消除多普勒带来的影响。而多普勒在时域的表现为信号的长度压缩和扩展，即'y(t) = x((1+a) * t)'，其中&lt;code&gt;a&lt;/code&gt;为多普勒因子。而如果估计出多普勒因子，之后采用重采样技术就可以恢复得到原始信号&lt;code&gt;x(t) = y( t/(a+a) )&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;重采样的意义就是插值，从一个信号插值得到多普勒影响前后的信号。而&lt;code&gt;1+a&lt;/code&gt;一般为小数，虽然采用多相滤波可以达到很好的插值效果，但复杂度太高。相比之下，线性插值、样条插值等方式运算量小，在做数字系统的时候更加合适&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Matlab一维插值&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MATLAB中的插值函数为&lt;code&gt;interp1()&lt;/code&gt;,其调用格式为 &lt;code&gt;yi=interp1 …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Thu, 24 Jul 2014 16:48:26 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-24:/pages/2014/07/duo-pu-le-shi-zhen-xin-hao-zhong-cai-yang-de-matlabfang-zhen-fen-xi.html</guid><category>misc</category></item><item><title>coursera_dl</title><link>http://heloman.github.io/pages/2014/07/coursera_dl.html</link><description>&lt;h1&gt;Coursera下载工具源码解析&lt;/h1&gt;
&lt;h2&gt;入口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;coursera-dl脚本中调用了coursera/coursera_dl.py中的coursera_dl.main()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;coursera_dl中加载的库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BeautifulSoup与html5lib&lt;/li&gt;
&lt;li&gt;argparse用以解析参数&lt;/li&gt;
&lt;li&gt;json解析json数据&lt;/li&gt;
&lt;li&gt;subprocess子进程管理&lt;/li&gt;
&lt;li&gt;requests&lt;/li&gt;
&lt;li&gt;six&lt;/li&gt;
&lt;li&gt;logging&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参数args解析&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 23 Jul 2014 15:59:54 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-23:/pages/2014/07/coursera_dl.html</guid><category>misc</category></item><item><title>20140722《剑指offer》解题笔记</title><link>http://heloman.github.io/pages/2014/07/20140722jian-zhi-offer-jie-ti-bi-ji.html</link><description>&lt;h1&gt;《剑指offer》解题笔记&lt;/h1&gt;
&lt;p&gt;《剑指offer》共50题，这两周使用C++花时间做了一遍，谨在此把一些很巧妙的方法、写代码遇到的难点、易犯错的细节等做一个简单的标注，但不会太过详细，具体算法还是请参考书本。
做的比较急，代码还有很多不完善的地方，如有错误，欢迎改正，地址为：&lt;a href="https://github.com/heLomaN/sword_of_offer.git"&gt;github:sword_of_offer&lt;/a&gt;。可以使用&lt;code&gt;git clone https://github.com/heLomaN/sword_of_offer.git&lt;/code&gt;命令获取代码。
其中，少数无法验证正确与否的题目没有写代码，部分二叉树的题目写了代码，但由于生成二叉树太过麻烦没有验证。&lt;/p&gt;
&lt;h2&gt;解题笔记&lt;/h2&gt;
&lt;h3&gt;Q3&lt;/h3&gt;
&lt;p&gt;声明并初始化二维数组的语句如何写？
cin如何判断输入结束？&lt;/p&gt;
&lt;h3&gt;Q4&lt;/h3&gt;
&lt;p&gt;字符数组的末尾位置计算差了1，忘了加上\0，要小心&lt;/p&gt;
&lt;h3&gt;Q5&lt;/h3&gt;
&lt;p&gt;递归的方法更简洁&lt;/p&gt;
&lt;h3&gt;Q6&lt;/h3&gt;
&lt;p&gt;stl的find算法
vector传值性能差，应该用引用
截取一段时要根据左右子树的长度来截，再次find是错误的&lt;/p&gt;
&lt;h3&gt;Q7 …&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 22 Jul 2014 08:43:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-22:/pages/2014/07/20140722jian-zhi-offer-jie-ti-bi-ji.html</guid><category>misc</category></item><item><title>20140716hard_soft_interface</title><link>http://heloman.github.io/pages/2014/07/20140716hard_soft_interface.html</link><description>&lt;h1&gt;《软硬件接口》课程大纲&lt;/h1&gt;
&lt;p&gt;Coursera课程 &lt;a href="https://class.coursera.org/hwswinterface-002"&gt;The Hardware/Software Interface&lt;/a&gt;是华盛顿大学提供的一门课程，其中汇编语言、进程结构、Java实现等章节内容我认为对于学编程的同学来说非常有用。教学环境是Fedora，顺带介绍了一些常用工具的使用。&lt;/p&gt;
&lt;h2&gt;课程大纲&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这门课程将会让学生知道当软件运行时到底发生了什么，并说明这个问题可以通过硬件架构层、汇编层、C语言层和Java层等数层抽象解答。- &lt;/li&gt;
&lt;li&gt;这门课程的核心是关于C、汇编、以及底层数据表示的，但同时与更高层（Java语言实现机理）、更底层（处理器通用架构）、操作系统（无关操作系统的实现）相关。&lt;/li&gt;
&lt;li&gt;对于那些想要专注于高层抽象的计算机专业学生来说，这门课可能是他们学习到的关于C语言及以更下层的唯一课程。不过，他们大多能够同时学到一些系统编程、硬件设计与实现、操作系统、编译器等知识。&lt;/li&gt;
&lt;li&gt;对于对硬件、嵌入式系统、计算机工程、计算机架构等感兴趣的学生来说，这门课程是一门入门课程，后续课程会在特定领域更加深入，并且会关注更下层的硬件实现、电路设计等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;课程主题&lt;/h3&gt;
&lt;p&gt;本课程主要有三个主题。
1. 表示：不同的数据类型，如整数和结构体数组，在内存中如何存在 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 16 Jul 2014 10:46:57 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-16:/pages/2014/07/20140716hard_soft_interface.html</guid><category>misc</category></item><item><title>substring</title><link>http://heloman.github.io/pages/2014/07/substring.html</link><description>&lt;h1&gt;字符串查找算法&lt;/h1&gt;
&lt;p&gt;字符串查找常用于电子监控，网络数据提取，文本编辑器。
字符串查找要求在一段长度为N的文本text中找到长度为N的pattern字符串的起始位置。常用算法如下。&lt;/p&gt;
&lt;h2&gt;暴力搜索&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;遍历text，以text中每个字符开始与pattern做比较。&lt;/li&gt;
&lt;li&gt;算法复杂度为MN，比如在AAAAAAAAB中查找AAB&lt;/li&gt;
&lt;li&gt;算法需要回退，如果发现一次不匹配，需要回退text的指针。可以通过缓冲M个字符解决&lt;/li&gt;
&lt;li&gt;算法实现&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;public static int search(String pat, String txt)&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="err"&gt;    int i, N = txt.length();&lt;/span&gt;
&lt;span class="err"&gt;    int j, M = pat.length();&lt;/span&gt;
&lt;span class="err"&gt;    for(i = 0, j = 0; i &amp;lt; N &amp;amp;&amp;amp; j &amp;lt; M; i++)&lt;/span&gt;
&lt;span class="err"&gt;    {&lt;/span&gt;
&lt;span class="err"&gt;        if (txt.charAt(i) == pat.charAt …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 15 Jul 2014 12:05:30 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-15:/pages/2014/07/substring.html</guid><category>misc</category></item><item><title>Python的特性</title><link>http://heloman.github.io/pages/2014/07/pythonde-te-xing.html</link><description>&lt;p&gt;Python的特性
Python于1991年发布，创始人现在在Google&lt;/p&gt;
&lt;h2&gt;特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量在运行时绑定，获得一个数据类型之后还可以更改，数据类型在赋值后确定&lt;/li&gt;
&lt;li&gt;变量皆为对象的引用&lt;/li&gt;
&lt;li&gt;修改不可变类型时会创建新的对象，而可变类型（list,dict）则是直接修改对象&lt;/li&gt;
&lt;li&gt;特别注意在函数传递时，传递的都是引用，如有对对象的修改要当心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1+"2"会报错，不能自动进行类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动内存管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数与短字符串对象会被缓存重用&lt;/li&gt;
&lt;li&gt;每个对象都保存有引用计数&lt;/li&gt;
&lt;li&gt;使用引用计数完成GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释型交互语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;自省&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;为什么选择python&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持OO中的多重继承
C++支持，但Java不支持，但可以使用接口实现相同的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开源 免费&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;真正的易于移植&lt;/li&gt;
&lt;li&gt;强大的库&lt;/li&gt;
&lt;li&gt;易于与其他语言混合&lt;/li&gt;
&lt;li&gt;易学易用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;空格缩进对齐，换行表示一行代码的结束&lt;/li&gt;
&lt;li&gt;赋值操作的是reference，x=y使x指向y指向的对象&lt;/li&gt;
&lt;li&gt;执行方式：&lt;ul&gt;
&lt;li&gt;python -i a …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 02 Jul 2014 16:11:15 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-07-02:/pages/2014/07/pythonde-te-xing.html</guid><category>misc</category></item><item><title>20140604c traps and pitfalls</title><link>http://heloman.github.io/pages/2014/06/20140604c-traps-and-pitfalls.html</link><description>&lt;p&gt;看完《C陷阱与缺陷》，忍不住要重新翻一下，记录一下与自己的惯性思维不符合的地方。记录的是知识的增量，是这几天的流量，而不是存量。
这本书是在ASCI C/C89订制之前写的，有些地方有疏漏。&lt;/p&gt;
&lt;h2&gt;第一章 词法陷阱&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.3 C语言中解析符号时使用贪心策略，如&lt;code&gt;x+++++y&lt;/code&gt;将被解析为&lt;code&gt;x++ ++ +y&lt;/code&gt;，并编译出错。&lt;/li&gt;
&lt;li&gt;1.5 单引号引起的一个字符代表一个对应的整数，对于采用ASCII字符集的编译器而言，'a'与0141、97含义一致。&lt;/li&gt;
&lt;li&gt;练习1.1 嵌套注释（如&lt;code&gt;/*/**/*/&lt;/code&gt;）只在某些C编译器中允许，如gcc4.8.2编译时是不支持的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第二章 语法陷阱&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2.6 else始终与同一个括号内最近的未匹配的if结合&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三章 语义陷阱&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;3.1 &lt;code&gt;int a[12][31 …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 30 Jun 2014 02:55:57 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-06-30:/pages/2014/06/20140604c-traps-and-pitfalls.html</guid><category>misc</category></item><item><title>Python源码剖析</title><link>http://heloman.github.io/pages/2014/06/pythonyuan-ma-pou-xi.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 30 Jun 2014 01:42:11 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-06-30:/pages/2014/06/pythonyuan-ma-pou-xi.html</guid><category>misc</category></item><item><title>程序员的自我修养</title><link>http://heloman.github.io/pages/2014/06/cheng-xu-yuan-de-zi-wo-xiu-yang.html</link><description>&lt;h3&gt;第十章&lt;/h3&gt;
&lt;h4&gt;10.1 程序的内存布局&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;linux下从0xc0000000开始到0xffffffff的1GB空间映射给内核，剩余3GB为用户空间&lt;/li&gt;
&lt;li&gt;0x08048000开始为代码区和数据区，即可执行文件。之前为系统保留区，约128MB&lt;/li&gt;
&lt;li&gt;可执行文件被映射到计算机内存中，包括只读的.text、.rodata，以及可读写的.data、.bss数据段。其中bss段由于保存的是未初始化的全局变量，在可执行文件中占用空间极少，并在加载程序时初始化为0&lt;/li&gt;
&lt;li&gt;动态链接库映射区从0x40000000开始，2.6内核之后已经挪到0xbfxxxxxx附近&lt;/li&gt;
&lt;li&gt;堆在可读写区之后，栈在内核空间之前，自高向下增长。堆和栈都可以动态增长&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;10.2.1 “烫”“屯”出现的原因&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;VC调试程序时，未初始化的变量或内存值通常是烫，这是因为debug模式下所有分配的栈空间字节初始化为0xCC，而0xCCCC就是汉字中的“烫”。而未初始化的堆内存则全部是0xCD，0xCDCD对应的汉字为“屯”。&lt;/li&gt;
&lt;li&gt;这些是为了方便调试时判断一个变量是否初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;10.2.2 函数调用规范&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;调用惯例规定了函数的参数传递顺序与方式、栈的维护方、名字修饰策略&lt;/li&gt;
&lt;li&gt;C语言默认惯例是cdecl …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 25 Jun 2014 03:44:33 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-06-25:/pages/2014/06/cheng-xu-yuan-de-zi-wo-xiu-yang.html</guid><category>misc</category></item><item><title>20140624codeforces解初体验</title><link>http://heloman.github.io/pages/2014/06/20140624codeforcesjie-chu-ti-yan.html</link><description>&lt;h2&gt;Codeforces印象&lt;/h2&gt;
&lt;p&gt;这两天抽时间去codeforces体验了一把。
首先，果然有众多大牛存在，很多名人一直参加每周一次的比赛，积分2000+，并参与出题。
另外，上面题目很多，估计至少一千题。比赛结束后，题目将转为练习题，可以持续尝试。每道题目都有标签，如greedy， math， matrices等等，可以点击相应的标签只做相关的题目。可惜我做了好几道之后才发现。&lt;/p&gt;
&lt;h2&gt;这次解决的题目&lt;/h2&gt;
&lt;p&gt;首次尝试，这次做的几个都是选的完成人数最多的，比较简单，但还是有些东西是从中新学习到的。以后最好分类练习。&lt;/p&gt;
&lt;h3&gt;1A    Theatre Square&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用a x a的砖块去铺满面积m x n的广场，不准破坏砖块，允许超出广场，求砖块数目&lt;/li&gt;
&lt;li&gt;分别计算长宽至少多少块即可&lt;/li&gt;
&lt;li&gt;小技巧：(m-1)/a+1来计算长度方向的砖块数目&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;limits&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 24 Jun 2014 15:30:46 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-06-24:/pages/2014/06/20140624codeforcesjie-chu-ti-yan.html</guid><category>misc</category></item><item><title>20140603Memcached</title><link>http://heloman.github.io/pages/2014/06/20140603memcached.html</link><description>&lt;h1&gt;Memcached&lt;/h1&gt;
&lt;p&gt;Memcached是一套分布式的内存对象缓存系统，使用C语言编写，作为数据库的前端cache，缓存数据库查询结果可以减轻数据库负载。
类似一张巨大的hash表，缓存的对象以key-value对的形式存在。&lt;/p&gt;
&lt;h2&gt;工作流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;检查客户端请求的数据是否在Memcached中存在，若存在直接返回结果&lt;/li&gt;
&lt;li&gt;若不存在，查询数据库，返回结果并把结果缓存&lt;/li&gt;
&lt;li&gt;每次修改数据库时要同时更新Memcached数据&lt;/li&gt;
&lt;li&gt;内存空间用完之后使用LRU算法替换缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基于文本行的协议，可以直接通过telnet管理&lt;/li&gt;
&lt;li&gt;基于libevent，异步io，高性能。libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能 封装成统一的接口。&lt;/li&gt;
&lt;li&gt;对被缓存的数据没有备份，重启后对数据库产生较大的压力&lt;/li&gt;
&lt;li&gt;memcached不互相通信的分布式，分布式由客户端完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;工作原理&lt;/h2&gt;
&lt;p&gt;服务守护进程运行后，客户端连接到服务进程进行操作。目前支持python,c,php等多种客户端。服务进程基于事件的单进程单线程实现。
- 内存管理
内存使用slab分配器分配，这种方案可以减少内存碎片和内存分配释放次数，加快处理速度。服务进程把分配的内存分割成各种固定尺寸的块，根据待缓存数据的大小选择一个最合适大小的块存入。分配的内存不会释放，而是重复利用。
数据大小和块的大小不匹配时会造成内存利用率低下。默认情况下不同大小的块的尺寸以2的增长因子扩大，可以使用'-f'选项调整增长因子。
- 分布式
分布式由客户端实现，客户端根据key来选择不同的memcached服务器 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 03 Jun 2014 21:11:53 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-06-03:/pages/2014/06/20140603memcached.html</guid><category>misc</category></item><item><title>git</title><link>http://heloman.github.io/pages/2014/05/git.html</link><description>&lt;h1&gt;使用Git完成版本控制&lt;/h1&gt;
&lt;p&gt;我经常同时保存一个程序或一个文档的不同版本，采取的方式就是文件名上面加上日期。
版本控制在团队开发大型项目中是必须的&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 21 May 2014 13:55:58 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-05-21:/pages/2014/05/git.html</guid><category>misc</category></item><item><title>20140520Ruby on Rails开发Web应用的基本概念</title><link>http://heloman.github.io/pages/2014/05/20140520ruby-on-railskai-fa-webying-yong-de-ji-ben-gai-nian.html</link><description>&lt;h2&gt;Web应用架构&lt;/h2&gt;
&lt;h3&gt;C/S架构&lt;/h3&gt;
&lt;p&gt;Web应用从最初就采用C/S架构。Server负责监听客户端请求，提供资源，Client向server发起请求并渲染页面。两者通过TCP/IP协议栈之上的HTTP协议通信。&lt;/p&gt;
&lt;h3&gt;多层架构&lt;/h3&gt;
&lt;p&gt;在Web 2.0时代，随着交互性的要求，这个架构变得更为复杂。Server需要提供更复杂的服务，Client也要完成更多的交互任务，涌现出很多新的提供更快更好服务的技术。相应的，C/S架构需要以一种更复杂的方式来组织，即多层架构。
多层架构中的每一层负责提供一个特定的功能，与其他层通过良好的接口进行交互，易于升级维护。原始的C/S架构可以视作Server、Client两层。&lt;/p&gt;
&lt;h4&gt;3层架构&lt;/h4&gt;
&lt;p&gt;典型的3层架构为表示层，逻辑层，数据层
- 表示层由浏览器负责渲染
- 逻辑层由服务器端操纵数据，并发往表示层
- 数据层负责存储数据。&lt;/p&gt;
&lt;h4&gt;6层架构&lt;/h4&gt;
&lt;p&gt;如果进一步分割，就得到6层架构，如下图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层分为Client层和表示逻辑层&lt;/li&gt;
&lt;li&gt;Client层负责渲染展示页面&lt;/li&gt;
&lt;li&gt;表示逻辑层为Server根据脚本生成网页&lt;/li&gt;
&lt;li&gt;逻辑层分为商业逻辑层和数据访问层&lt;/li&gt;
&lt;li&gt;事务逻辑层表征事务逻辑和流程&lt;/li&gt;
&lt;li&gt;数据访问层负责存取数据，发往事务逻辑层 &lt;/li&gt;
&lt;li&gt;服务端通常有网络层负责网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Ruby …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 20 May 2014 10:39:23 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-05-20:/pages/2014/05/20140520ruby-on-railskai-fa-webying-yong-de-ji-ben-gai-nian.html</guid><category>misc</category></item><item><title>20140518C++11新特性</title><link>http://heloman.github.io/pages/2014/05/20140518c11xin-te-xing.html</link><description>&lt;h1&gt;C++11新特性&lt;/h1&gt;
&lt;p&gt;C++11已经推出三年了（2011），编译器GCC4.7、Clang3.1在2012年已经逐渐完善，VS2013也已经支持相关特性，GCC4.8.1支持全部特性。不过新特性似乎在工业界并未得到太多应用，可能出于兼容性和稳定性的考虑吧。
推出的新特性还是相当的丰富，看下面这张图就知道了。我仅仅在这里提一下相对比较容易应用的部分，包括语法上的一些扩展以及改进，lambda表达式以及正则式等比较复杂，暂且不提。&lt;/p&gt;
&lt;h2&gt;统一初始化&lt;/h2&gt;
&lt;p&gt;以往的C++可以使用很多种方法完成初始化，而且传统的构造函数类似于函数声明，不是非常直观。而新标准把数组的初始化方法推广为统一的初始化方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;int i{0};&lt;/span&gt;
&lt;span class="err"&gt;float f{2.0};&lt;/span&gt;
&lt;span class="err"&gt;ClassA a{a,&amp;#39;c&amp;#39;,&amp;quot;foo&amp;quot;}; &lt;/span&gt;
&lt;span class="err"&gt;int i{2.0};//error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方法不会造成narrowing，编程风格更为统一。&lt;/p&gt;
&lt;h2&gt;类型推导&lt;/h2&gt;
&lt;p&gt;引入auto和decltype关键字。auto可以根据表达式或函数返回值在编译阶段得到正确的类型。而decltype可以在编译时确定一个表达式的类型 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sun, 18 May 2014 10:09:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-05-18:/pages/2014/05/20140518c11xin-te-xing.html</guid><category>misc</category></item><item><title>20140429主定理</title><link>http://heloman.github.io/pages/2014/04/20140429zhu-ding-li.html</link><description>&lt;h2&gt;主定理&lt;/h2&gt;
&lt;p&gt;主定理最早出现在《算法导论》中，提供了分治方法带来的递归表达式的渐近复杂度分析。&lt;br&gt;
规模为n的问题通过分治，得到a个规模为n/b的问题，每次递归带来的额外计算为c(n^d)&lt;br&gt;
&lt;strong&gt;T(n) &amp;lt;= aT(n/b)+c(n^d)&lt;/strong&gt;&lt;br&gt;
那么就可以得到问题的复杂度为：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^d log(n)), if a = b^d&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^d ), if a &amp;lt; b^d&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T(n) = O(n^logb(a))), if a &amp;gt; b^d …&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 29 Apr 2014 18:54:26 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-04-29:/pages/2014/04/20140429zhu-ding-li.html</guid><category>misc</category></item><item><title>20140422Map_reduce</title><link>http://heloman.github.io/pages/2014/04/20140422map_reduce.html</link><description>&lt;h1&gt;Map-Reduce&lt;/h1&gt;
&lt;p&gt;Map-Reduce是由Google在2004年提出的大数据并行编程架构，分为Map（映射）和Reduce（化简）两个步骤，因此得名。它隐藏并行化、容错、数据分布、负载均衡等细节，可以搭建在普通PC上，程序员可以很方便完成大数据并行编程。&lt;/p&gt;
&lt;h2&gt;并行运算的效率&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;假如使用1个处理器花费T1时长可以完成任务，而使用了p个处理器需要Tp时长。那么加速比为：S(Speeup) = T1/Tp，效率为：E = S/p = T1 / (p Tp)   &lt;/li&gt;
&lt;li&gt;一般效率都小于1，而且p越大效率越低，但是在数据集增大时，效率会相应的有所提高。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;传统的并行处理架构&lt;/h2&gt;
&lt;h3&gt;数据并行架构：共享内存-分割任务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;内存（数据）是共享的，把任务分为p个部分，分别由p个处理器完成。为防止冲突，每个处理器都要在开始工作时对使用的数据段加锁，以阻塞其他任务使用这一数据段。任务完成之后，才会解锁。  &lt;/li&gt;
&lt;li&gt;很显然，如果p个处理器同时对不同的数据段进行处理，效率是很高的。但如果有冲突 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 22 Apr 2014 17:55:48 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2014-04-22:/pages/2014/04/20140422map_reduce.html</guid><category>misc</category></item><item><title>django开发视频网站项目记录</title><link>http://heloman.github.io/pages/2013/11/djangokai-fa-shi-pin-wang-zhan-xiang-mu-ji-lu.html</link><description>&lt;h3&gt;20131108启动&lt;/h3&gt;
&lt;p&gt;下载了Owntube，尝试运行。官方文档给出的运行方式是virtualenv，一个虚拟的python环境。我索性直接在系统环境内安装了相关的软件。django版本真的比较低。  &lt;/p&gt;
&lt;p&gt;在settings.py中很多变量需要配置，根据官方给出的&lt;a href="https://docs.djangoproject.com/en/1.3/howto/static-files/"&gt;文档&lt;/a&gt;：  &lt;/p&gt;
&lt;p&gt;使用django.contrib.staticfiles应用，默认配置包含的 AppDirectoriesFinder 会搜索所有已经安装的应用的 &lt;code&gt;static/&lt;/code&gt; 子目录。   &lt;/p&gt;
&lt;p&gt;并且对于一些不适合放进相关app的文件， &lt;code&gt;STATICFILES_DIRS&lt;/code&gt;是默认的搜索路径。不过这些只适用本地开发，并且要安装FileSystemFinder应用。  &lt;/p&gt;
&lt;p&gt;这些文件会以 &lt;code&gt;STATIC_URL&lt;/code&gt; 提供。&lt;/p&gt;
&lt;p&gt;这个服务只在DEBUG为True时，即本地开发时有效。发布网站时，要使用 &lt;code&gt;./manage.py collectstatic&lt;/code&gt; 命令来搜集所有STATICFILES_DIRS路径以及app下的静态文件到STATIC_ROOT文件夹下面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;os.path.dirname(__file__)&lt;/code&gt; 可以输出当前路径。  &lt;/p&gt;
&lt;p&gt;当前配置为：&lt;br&gt;
    STATIC_ROOT = '/home/czk/djangoproject/OwnTube/colect_staitic/'
    STATIC_URL = '/static/'
    import …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Fri, 08 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2013-11-08:/pages/2013/11/djangokai-fa-shi-pin-wang-zhan-xiang-mu-ji-lu.html</guid><category>App</category><category>django</category></item><item><title>Ubuntu系统安装Matlab2012a</title><link>http://heloman.github.io/pages/2013/09/ubuntuxi-tong-an-zhuang-matlab2012a.html</link><description>&lt;h3&gt;下载安装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载matlab的安装镜像，注意一定是unix版本到。 &lt;/li&gt;
&lt;li&gt;挂载iso文件： &lt;code&gt;sudo mount -o loop Mathworks.Matlab.R2012a.UNIX.iso /mnt/tmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;到tmp目录下面执行 &lt;code&gt;sudo ./install&lt;/code&gt;，安装并激活&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;启动程序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;运行matlab的方式为：&lt;code&gt;sudo /usr/local/MATLAB/R2012a/bin/matlab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行的时候的警告信息，&lt;code&gt;/usr/local/MATLAB/R2012a/bin/util/oscheck.sh: /lib/libc.so.6: not found&lt;/code&gt;。需要创建一个链接解决:&lt;code&gt;sudo ln -s /lib/i386-linux-gnu/libc …&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Wed, 04 Sep 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2013-09-04:/pages/2013/09/ubuntuxi-tong-an-zhuang-matlab2012a.html</guid><category>App</category><category>ubuntu</category><category>matlab</category></item><item><title>Project Euler 001-006 解法总结</title><link>http://heloman.github.io/pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html</link><description>&lt;h4&gt;Problem 1&lt;/h4&gt;
&lt;p&gt;Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;p&gt;题目要求找出所有1000以下的3或者5的倍数之和。&lt;br&gt;
最简便的方法是，计算出1000以下总共有多少个3、5、15的倍数，然后用等差数列求三种数分别之和，最后3、5的倍数和减去15的倍数和就得到了结果。&lt;br&gt;
NOte：这是因为15的倍数多算了一遍，所以要减去。  &lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;Problem 2&lt;/h4&gt;
&lt;p&gt;Find the sum of all the even-valued terms in the Fibonacci sequence which do not exceed four million.&lt;/p&gt;
&lt;p&gt;题目要求找出斐波那契数列中偶数之和。&lt;br&gt;
我的方法是，斐波那契数列每三个连续的数中有一个为偶数，计算斐波那契数时用一个长度为3的数据完成缓存 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 27 Aug 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2013-08-27:/pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html</guid><category>Competition</category><category>project euler</category></item><item><title>国外大学生谈经验：如何在Github参与开源（Open Source on Github: Your First Contribution）</title><link>http://heloman.github.io/pages/2013/08/guo-wai-da-xue-sheng-tan-jing-yan-ru-he-zai-githubcan-yu-kai-yuan-open-source-on-github-your-first-contribution.html</link><description>&lt;p&gt;原作者：spencerpmoran&lt;br&gt;
转载自&lt;a href="http://spencermoran.me/2013/08/13/open-source-on-github-your-first-contribution/"&gt;http://spencermoran.me/2013/08/13/open-source-on-github-your-first-contribution/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我是一个即将毕业的计算机大四学生，我经常听人谈论对github上的开源项目做出贡献是多么有意义的事情。许多职位要求里面都写明这种经历是一个很重要的基本条件或加分项，而且这种事情经常在各种seminar课程和活动中提到。做出贡献确实挺起来很酷，我也应该做啊。可唯一的问题是，我是一个大菜鸟。我的计算机课程学的很好，而且我做过几个被家人同学称赞的项目。可是，我确信我不可能对一个真正有用户的项目做出任何有意义的贡献，对吧？这种想法是正确的吗？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大错特错！即使你是一名新手，也可以以很多方式对github上面的项目做出实质的贡献。如果想要做一些真正有意义的影响用户的贡献，你大可不必读懂所有项目代码或者知道如何解决类似于bootstrap里的动态窗格问题。对于每个人都有合适的做出贡献的方法。&lt;/p&gt;
&lt;p&gt;最近，我的第一个实质性的贡献在一个开源项目上完成了。尽管贡献很小，我获得了全新的成就感，因为你知道有人在用你参与完成的东西。你必须从非常小的项目开始并持续前进。下面是我对想要对github上开源项目做出贡献但感觉困难而不敢尝试的同学的建议：&lt;/p&gt;
&lt;p&gt;你要做的第一步就是找到一个有pull request的仓库（项目）。有很多种方式可以找到。最简单直接的办法是读仓库的readme文件，里面经常明确的写明仓库所有者希望有人来完成pull request。如果readme文件没有提到这一点，你可以看看问题然后把代码下载下来。检查一下pull request的日期，看看哪些pull request已经关闭 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Sun, 25 Aug 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2013-08-25:/pages/2013/08/guo-wai-da-xue-sheng-tan-jing-yan-ru-he-zai-githubcan-yu-kai-yuan-open-source-on-github-your-first-contribution.html</guid><category>Coding</category><category>github</category><category>open source</category><category>blog</category><category>translation</category></item><item><title>My first git blog</title><link>http://heloman.github.io/pages/2013/08/my-first-git-blog.html</link><description>&lt;h2&gt;How to build you blog on github&lt;/h2&gt;
&lt;h4&gt;name.github.io&lt;/h4&gt;
&lt;p&gt;Github offer everyone a site:name.github.io, where you can publish you blogs.&lt;/p&gt;
&lt;h3&gt;Use git to publish&lt;/h3&gt;
&lt;p&gt;A very good startup:&lt;a href="http://frantic1048.com/blog/bo-ke-dan-sheng-ji-ji-yu-githubpelicanchuang-jian-bo-ke-de-zheng-ge-guo-cheng.html"&gt;frantic1048's startup&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Improve:google anylytics,sitemap,disqus&lt;/h3&gt;
&lt;p&gt;&lt;a href="&amp;lt;http://www.lizherui.com/pages/2013/08/17/build_blog.html"&gt;Lizherui's blog&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;How to use images and robots.txt&lt;/h3&gt;
&lt;p&gt;Very nice …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Mon, 19 Aug 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:heloman.github.io,2013-08-19:/pages/2013/08/my-first-git-blog.html</guid><category>Web</category><category>pelican</category><category>blog</category></item></channel></rss>