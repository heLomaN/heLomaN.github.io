<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Focus</title><link>http://heloman.github.io/</link><description></description><atom:link href="http://heloman.github.io/feeds/competition.rss.xml" rel="self"></atom:link><lastBuildDate>Tue, 27 Aug 2013 00:00:00 +0800</lastBuildDate><item><title>Project Euler 001-006 解法总结</title><link>http://heloman.github.io/pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html</link><description>&lt;h4&gt;Problem 1&lt;/h4&gt;
&lt;p&gt;Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;p&gt;题目要求找出所有1000以下的3或者5的倍数之和。&lt;br /&gt;
最简便的方法是，计算出1000以下总共有多少个3、5、15的倍数，然后用等差数列求三种数分别之和，最后3、5的倍数和减去15的倍数和就得到了结果。&lt;br /&gt;
NOte：这是因为15的倍数多算了一遍，所以要减去。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 2&lt;/h4&gt;
&lt;p&gt;Find the sum of all the even-valued terms in the Fibonacci sequence which do not exceed four million.&lt;/p&gt;
&lt;p&gt;题目要求找出斐波那契数列中偶数之和。&lt;br /&gt;
我的方法是，斐波那契数列每三个连续的数中有一个为偶数，计算斐波那契数时用一个长度为3的数据完成缓存，每次循环完成三个数的更新，即计算三次斐波那契数，取偶数位相加即可。&lt;br /&gt;
最简便的方法是，既然没三个连续数就有一个为偶数，那个可以推出连续的三个偶数斐波那契数之间的关系，这样就可以用长度为2的数据完成计算，而且计算量减少很多。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 3&lt;/h4&gt;
&lt;p&gt;Find the largest prime factor of a composite number&lt;/p&gt;
&lt;p&gt;题目要求找出一个数的最大质因子。&lt;br /&gt;
我的方法是，首先除以所有为2的质因子，然后从3到sqrt(n)依次找出质因子。排序得到最大的，应该用遍历法得到。过程中参考了CSDN的一篇剪枝的方法（回退法除以所有同一个质因子）。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 4&lt;/h4&gt;
&lt;p&gt;Find the largest palindrome made from the product of two 3-digit numbers.&lt;/p&gt;
&lt;p&gt;题目要求找出能分解为两个三位数相乘的最大回文数。&lt;br /&gt;
我的方法是，判断是否为回文数把每一位都提取出来，看前后是否相等。然后按照因此从999到100遍历啊和b的乘积判断是否为回文数，避免重复。找到第一个回文数后，计算出还有可能的a、b是多少，然后再次遍历。最后对遍历的结果取最大值。&lt;br /&gt;
最简便的方法是，在上述方法的基础上，经过分析知道这个回文数一定是11的倍数，因为11是质数，则a或b必须为质数。在遍历时，可以判断出a不是11的倍数时b的可能值范围变成原来的1/11，运算量大大减少。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 5&lt;/h4&gt;
&lt;p&gt;What is the smallest number divisible by each of the numbers 1 to 20?&lt;/p&gt;
&lt;p&gt;题目要求找出1~20的最小公倍数。&lt;br /&gt;
我的方法是首先用费马方法实现最大公因子gcd的计算。然后从大到小依次计算前者最小公倍数与下一个数的最小公因子，然后得到所有数的最小公倍数。&lt;br /&gt;
最简单的方法是，对这个公倍数进行分析，必然是小于k的一系列质数的乘积。如果知道质数表，那么对于每一个小于k的质数为底计算floor(log)，然后把所有这些质数的幂相乘就得到了最小公倍数。可以优化的一点是，对于大于sqrt(k)的质数，已经不可能为1次以上的幂了，直接设幂指数为1即可。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;Problem 6&lt;/h4&gt;
&lt;p&gt;What is the di erence between the sum of the squares and the square of the sums?&lt;/p&gt;
&lt;p&gt;题目要求算出和的平方与平方和的差。&lt;br /&gt;
我的方法就是直接算，因为没有想到一种方法可以减少运算量。&lt;br /&gt;
最简便的方式，是把求和用高斯的方法计算，即n*(n+1)/2，同样的，最好能得到平方和的计算公式。其实计算方法也很简单，假设为三次多项式，用前四个值（含0）来解出系数。也可以参考百度百科平方和的排列组合法。  &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">heLomaN</dc:creator><pubDate>Tue, 27 Aug 2013 00:00:00 +0800</pubDate><guid>tag:heloman.github.io,2013-08-27:pages/2013/08/project-euler-001-006-jie-fa-zong-jie.html</guid><category>project euler</category></item></channel></rss>